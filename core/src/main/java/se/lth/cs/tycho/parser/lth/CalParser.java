/* 
 *  @author Per Andersson<Per.Andersson@cs.lth.se>, Lund University
 *  To parse a CAL file use one of the methods:
 *  - public se.lth.cs.tycho.ir.entity.cal.CalActor parse(String path, String fileName)
 *  - public se.lth.cs.tycho.ir.entity.cal.CalActor parse(File file)
 *
 *  After parsing check for errors in the attribute parseProblems.
 *
 *  The parser is created using jflex and beaver.
 */
 
package se.lth.cs.tycho.parser.lth;

import se.lth.cs.tycho.ir.entity.cal.*;
import java.util.Arrays;
import se.lth.cs.tycho.ir.decl.*;
import se.lth.cs.tycho.ir.entity.cal.Action;
import se.lth.cs.tycho.ir.util.ImmutableList;
import se.lth.cs.tycho.ir.expr.*;
import se.lth.cs.tycho.ir.stmt.lvalue.*;
import java.util.TreeSet;
import java.util.ArrayList;
import se.lth.cs.tycho.ir.*;
import se.lth.cs.tycho.ir.IRNode;
import se.lth.cs.tycho.ir.stmt.*;
import java.util.Map;
import se.lth.cs.tycho.parser.SourceCodeOracle;
import beaver.*;
import se.lth.cs.tycho.ir.decl.GlobalDecl.Availability;
import se.lth.cs.tycho.errorhandling.BasicErrorModule;
import java.io.PrintStream;
import java.util.Collection;
import se.lth.cs.tycho.errorhandling.ErrorModule;
import java.io.File;
import java.util.AbstractMap;
import se.lth.cs.tycho.ir.IRNode.Identifier;
import se.lth.cs.tycho.parser.SourceCodeOracle.SourceCodePosition;
import se.lth.cs.tycho.ir.entity.*;
import se.lth.cs.tycho.ir.util.ImmutableEntry;

/**
 * This class is a LALR parser generated by
 * <a href="http://beaver.sourceforge.net">Beaver</a> v0.9.6.1
 * from the grammar specification "CalParser.beaver".
 */
public class CalParser extends Parser {
	static public class Terminals {
		static public final short EOF = 0;
		static public final short ACTOR = 1;
		static public final short IDENTIFIER = 2;
		static public final short LPAREN = 3;
		static public final short RPAREN = 4;
		static public final short PORTCONN = 5;
		static public final short COLON = 6;
		static public final short EDGE = 7;
		static public final short SEMICOLON = 8;
		static public final short BAR = 9;
		static public final short IMPORT = 10;
		static public final short EQ = 11;
		static public final short IF = 12;
		static public final short THEN = 13;
		static public final short ELSE = 14;
		static public final short END = 15;
		static public final short MAP = 16;
		static public final short LBRACE = 17;
		static public final short RBRACE = 18;
		static public final short BEGIN = 19;
		static public final short VAR = 20;
		static public final short DO = 21;
		static public final short CHOOSE = 22;
		static public final short IN = 23;
		static public final short COMMA = 24;
		static public final short ALL = 25;
		static public final short SCHEDULE = 26;
		static public final short LBRACK = 27;
		static public final short RBRACK = 28;
		static public final short DOUBLECOLON = 29;
		static public final short ACTION = 30;
		static public final short INITIALIZE = 31;
		static public final short PRIORITY = 32;
		static public final short REGEXP = 33;
		static public final short DOT = 34;
		static public final short MUTABLE = 35;
		static public final short COLONEQ = 36;
		static public final short FUNCTION = 37;
		static public final short PROCEDURE = 38;
		static public final short MULTI = 39;
		static public final short LET = 40;
		static public final short CONST = 41;
		static public final short LAMBDA = 42;
		static public final short WHILE = 43;
		static public final short GUARD = 44;
		static public final short DELAY = 45;
		static public final short AT = 46;
		static public final short ATSTAR = 47;
		static public final short ANY = 48;
		static public final short REPEAT = 49;
		static public final short TIME = 50;
		static public final short INVARIANT = 51;
		static public final short FSM = 52;
		static public final short MULT = 53;
		static public final short GT = 54;
		static public final short ENDACTION = 55;
		static public final short ENDACTOR = 56;
		static public final short ENDINVARIANT = 57;
		static public final short ENDSCHEDULE = 58;
		static public final short LT = 59;
		static public final short ARROW = 60;
		static public final short INTEGER_LITERAL = 61;
		static public final short LONG_LITERAL = 62;
		static public final short FLOATING_POINT_LITERAL = 63;
		static public final short DOUBLE_LITERAL = 64;
		static public final short TRUE_LITERAL = 65;
		static public final short FALSE_LITERAL = 66;
		static public final short CHARACTER_LITERAL = 67;
		static public final short STRING_LITERAL = 68;
		static public final short NULL_LITERAL = 69;
		static public final short OLD = 70;
		static public final short PROC = 71;
		static public final short OPERATOR = 72;
		static public final short FOREACH = 73;
		static public final short FOR = 74;
		static public final short ENDCHOOSE = 75;
		static public final short ENDFOREACH = 76;
		static public final short ENDIF = 77;
		static public final short ENDLAMBDA = 78;
		static public final short ENDLET = 79;
		static public final short ENDPROC = 80;
		static public final short ENDWHILE = 81;

		static public final String[] NAMES = {
			"EOF",
			"ACTOR",
			"IDENTIFIER",
			"LPAREN",
			"RPAREN",
			"PORTCONN",
			"COLON",
			"EDGE",
			"SEMICOLON",
			"BAR",
			"IMPORT",
			"EQ",
			"IF",
			"THEN",
			"ELSE",
			"END",
			"MAP",
			"LBRACE",
			"RBRACE",
			"BEGIN",
			"VAR",
			"DO",
			"CHOOSE",
			"IN",
			"COMMA",
			"ALL",
			"SCHEDULE",
			"LBRACK",
			"RBRACK",
			"DOUBLECOLON",
			"ACTION",
			"INITIALIZE",
			"PRIORITY",
			"REGEXP",
			"DOT",
			"MUTABLE",
			"COLONEQ",
			"FUNCTION",
			"PROCEDURE",
			"MULTI",
			"LET",
			"CONST",
			"LAMBDA",
			"WHILE",
			"GUARD",
			"DELAY",
			"AT",
			"ATSTAR",
			"ANY",
			"REPEAT",
			"TIME",
			"INVARIANT",
			"FSM",
			"MULT",
			"GT",
			"ENDACTION",
			"ENDACTOR",
			"ENDINVARIANT",
			"ENDSCHEDULE",
			"LT",
			"ARROW",
			"INTEGER_LITERAL",
			"LONG_LITERAL",
			"FLOATING_POINT_LITERAL",
			"DOUBLE_LITERAL",
			"TRUE_LITERAL",
			"FALSE_LITERAL",
			"CHARACTER_LITERAL",
			"STRING_LITERAL",
			"NULL_LITERAL",
			"OLD",
			"PROC",
			"OPERATOR",
			"FOREACH",
			"FOR",
			"ENDCHOOSE",
			"ENDFOREACH",
			"ENDIF",
			"ENDLAMBDA",
			"ENDLET",
			"ENDPROC",
			"ENDWHILE"
		};
	}

	static final ParsingTables PARSING_TABLES = new ParsingTables(
		"U9pjd0TyLCNsny#vUpSaeIGq2IQA88ZjsG11qM33W15GH4Ga440GwKYlYbHfqWGf5gG9#X0" +
		"G4H0GHH0ie2XsHR4NK4JKXxhp$ysvitVlRhRvzF7oFdzkFkVEcPapCzyvK#xSP3T4vVPJAt" +
		"gUVBo3pkKfwWLgeXGrehLKWne6FgI1L4WshQ1Ll9TBKcFLWp#dKwYtsalDw4PgIfVH9dgEM" +
		"j3rr9nke04qckRJlVGzbwSlQG$lv4o#W$kflVmQNKlNy2Xem$aToYT57z4##fW#eVtqANr6" +
		"dzCNr98UeZpgIRqqaIdt5Jz9JNYL9kB9l95UqKJSW5RmXUekJSHFymPwYNfJUWAYataEdSV" +
		"4sNmvVqZlymD2j9OxqdIkHVcy816HUebEv$hSdZjH4zeZH4Tve$7HH13zWyyJegsy0RNsZi" +
		"x3Jxb4dwYsj9E7KQeQ9xLM4QAFgQhQBaJx4n7HQVGElG4$V#qIZUADF3mQ4LqUWsWaRtQ9x" +
		"kPkb87oTRa7jvLMG4Gxk2lVeebKwuIZTXllLd#0fNoGY5Ae5jKhGjIETj1Tr9j$YSfqjKjK" +
		"Zd$bVsa$KGNKzpRt5X$bygVgUar49H8IzU41V0HbqroYpdGhbIn2bClZrVMOsJiI49r47Ra" +
		"U7#2Bu7TTzpVYes$e07MGKVis8T5gwi8Lw7pATObsyqPL47KUZOmvZvuB4j5zT90lvWwyb1" +
		"VJ8leTQqlxg2FLu4tYewK9vz7f63VCGDxY4Y67fnKX6i7jk7bC8dA9Skas46rNgzH#lfBEe" +
		"aV5HrLvBntW4V1HWuH4rIYJrz0yq3HH#sLcDz3zaTL$EOZUePE5w1H#WHw9GNGr#XCSjKkn" +
		"Tnp4sgYF6a$53EWdFbeF3#lz8v$J4XBr5Qqp3OEFwegFXWQ9qDyLucrDL8k6q1qnY5g7YEX" +
		"9tWAciPmEedfqY8w8ZoOBpmuGvIUSHxLfB2tcnbJE7RL9yF1hGgH0z05Mhjwpsz0oAXs3g0" +
		"rA1ebUfPynf$M#MeDJuE5SyT4PgELpFWMh$#Q4FdeN##i9V9OUDRCVbUOAVBMCMXf6BGinP" +
		"wsLuaanYDholY2HNlSYTwAsN1ghFXQY5bn1NSUFm4S$9FJH9Vm4fyl#qKGrqqIg4xnxeX2z" +
		"1Q8Ht4k8Qa0R58FeTe#F6c963#OtrQiy4De4dgU9r3uUmx$pE13zaP08JpFLZFFu7ZpN1eF" +
		"ePioS4NZQWaWjvMLSWwhpV8pQ4bw6$JqwqIYi2OT8vpQ8oDK#UemVbrxdexUnYFGpRIS$8K" +
		"#XBq5JMzFmKVHMQAWcdqxZwHwQ0F$ift5qHWoQAR0FqLmNXUPTFaXdgcsOGxScd4CNyKTK6" +
		"mnrC8TiyS#5U2Rc2f5UOyzYFhv5ZQ6lGsfqehd14SCQ#v4FqHwBw4fgIAtu0xf9rbafbDK$" +
		"#TGf8L4kTUSzr5$swq52D9pk317fUeHe6eYcnY1wccQuHC$J77g0fj63j80U1j528Ig3aLz" +
		"2$mJHoeH4Jw75FSBV1AA9ScaxlIX4EsatlKoxw7KGxQKtwQqOHC$GUsRKSkbh#ev#f9$eL$" +
		"eN$KO1jcJKRAxAgTf7N3RXsUWAhiXLk98cuXoPHzMuElOdPtVCvNFuNFIuCP$F5w3NqOasS" +
		"ntZeyluAcw4KbNu1jnRSG6t4Q92ZE5O8ReztgpcxZm4vNg6$AC#uJlLoxBgH$D47ij3PDNV" +
		"YzasFGRDLZOZHZRFv5ayc#$dXtWkv45#M4Qi1Y$YXVmeQ9R4fLaEotyodX3mpKhnpJDg9Sj" +
		"eyUlygjggd2V7s$mUln63vaD#FpXQ$0LEFo$oTweZ$y3Vys7#INpp6mTOeOryY#FHM5WAvc" +
		"e2qNF7kVH8cKlJ63KwpGyKVDP7kxHlWbS#90wDfzI$JSDbZYKDBfT6xOhAK$c$GnELvSp$b" +
		"c#YqfnTh6WQ5YkQQueLpRN5YkR6OaNJkLZHz2rMDFsB5StGOaNpMGIDKvDppOgWQVmNQAGc" +
		"dEORSpUSJOQ3HgxWQPxlWbuJDOqnD1VGxEWqtENleZ6#oHVVw4kVczqIE3Vd1Ns3DwhP#Xt" +
		"Kuqsf0s$EVsQaTAj16fJ06vNGm2lUaSgZtkux3ebNY5ORYs8qKdoQyStKo97Yfd$tI6cQi9" +
		"6Y20$bSTsGRxYPItEBw$U$qJSKEM$S4lAsgaUm84WJUbjrHf9l$JTMUCIyeUWhF2#2ndl5c" +
		"ZVjZfrlJAlkcWhZx#hfwR7mZTS7HMc2rr#bkVjFqgpxZz8avvkDnyWtoT4a62dEA5Oq9nOh" +
		"cfR7YiRoKUGLGQF$NXALnf#0nkAVFJrDTBwXmBl9#SRLYiL87QSvJdESvd#SndlzzRUxecz" +
		"gZzEbiE$CVjn$eSVe3weVpufPh2wERsNgMfwKrHD9MQs9ORK#pEghfEhwDYchmqbP7Kt6Yd" +
		"r9MPM8PONpl$RzAs9rAgpq#RyoPLDEtB5w6VQNkFFYd1YV6T6sr$Ckr7aVxK6icpgYZj19K" +
		"cOYKlNVmryoTLIYB3gR$X6iahVXLZRw9ot4e6BKl9bnI5gxTTVcc$XYz5bVzqjAx3uxfPro" +
		"rndbAkapnR4#mVND5MBjNCvR#XL5#Zo21firsZx6foR0JprYjgVVwrzsr#XLCUh8Wm#2vv7" +
		"WYFHnHwG9HgIH7X6y2RxWxbHEsDWT4NqrfYqcV9Os68jj9YnQJkyVZOrzlXlJeTvDDf2pg#" +
		"HvFIGnRP7dMZhbyjro554kptCFXQ4hSXUBVkMHHJwwWpBePAf2API6j99K2gbPICl4V4oby" +
		"bG1yHCmTdvuAWEpfhBujmLytf9kmgvyCxN6MtmREftEe3FfB8pf$R2wY3fXpfnBvz45L8Sk" +
		"n6XMfbvK4oik0wigL$xwV3bcovKOluOoMjf$rmYHKsucJGLHeH1DGhXLY0g4gA8GTQLkj0j" +
		"jBKj8z9JyXRGJ3SCO5k0DIXFTWtf6extwD3qX4QFzkJ9tqz2U9af7YkEZKq5KWqvpYIh08Z" +
		"hFO9VeFgcr4pqAh#jQxnKYYsQGBKIB4n9Lmrn$7YtjT8bwWAXNL29V4aIJK7uvocVGIbZhL" +
		"XoYGMX94vL8I3IGz3hFHWr18iRULRS8qKHOpu75X8IZDWzFQLrpFTchnXgYaiP7LaAYX#XX" +
		"cesoFfUeBRL3wKWY2tNROfU8A0Mbjc3sPKlTsK9K1Zqk9qIl9YIQ9dkW7#q4YIpvf6IqKSj" +
		"AOjG6O0VfWtcqYJPJVo7HH1MaBIkfjLQ8STCpCDibqZaZe$Xe8bPEBA9ybqX$paiJMR3jZt" +
		"bzdH3DG3n3Y0eI4gN2orNHin1HWQHhec4WgebTr26gZVKRYoZR9Hg6FZQHzPiD4Zq3D97si" +
		"9PaV9GYcYwP1cjDbE8IDGUHrXsYSfYdYOdq$2d4#5wBi2xrDQDMKdYqZr8I4XMWz2ggZXDA" +
		"q4UTaPuYH1aWAcdsR1lFDdyIH5buQcRBlggb9kmT8ajydypgpy8SA01HQDJqJ1$W4kcOuwF" +
		"UCZUY4yrqYPmPx1DVDKVP727IjTZuIMRrPuc7BLdzAKAKWrYg#nInQ8mGwTLIEIaVPTE3D0" +
		"Ird0SjounQ3axTgQYfFbf8HBGMevu2N#u0qODczUiVvqcR1f92l0zK4hrQGg9ekPfekkoFl" +
		"hW#SfvfMHBUXzOAp3Cjsz0KOZxTHbteTj0ifkweDHQDbO16doKAPSHo4lgd8cplHakZG9Gg" +
		"H7SWlRaGwNnRvgEUGsb8JUIVR7gPNf7pYYqz7G9hJJG2vVHFVQpMH4Hwviq2kTwlomfHEQI" +
		"4Y7GzcaZFiU4nYMoNA0VZVoQiXqEMWCWsH1LeDNgSp5wKWJPcIRlQ1vf84pXF4BrYR9o#D5" +
		"41vbdilQZ07RLn#Ab8Js8NgaZzy5DHYFfX3nylFifAI6JB7EujH5b2L15biypks1nvkhTwr" +
		"9R4EOa4vv7UnGgaL6$nlaKl2j50MS$nYIof$tnOvNZyauqQiuL6p#uSv3kdsOeorwBJZ38q" +
		"gPY1QuJ9mddHmedKPsQr1VzE0qrgN1gVs5aoOvsJR1tepvWzA4L#d5sn8CxpFhJ6zEd7Xpx" +
		"eUcVBqrJJ5Cg#flVfmhWqgSfSb0O1ZOc1niq1ZT5Yq217Q5IKIzEuUdr871fFgVyH6iH2D3" +
		"dnpeh7dAPu#UOupN6QupJ7QOxJnA1nQZ9wHZWDJWF$DerJavp$Ug2cNfHjSeEd#K7GkwEcd" +
		"kP4SHSrZKv3a$yk6iStucMX2POp9TAeKT0tQBkfVlyCUTEfm#r5KYCb9GoDbBZOq1HuHmeb" +
		"ieDUaNXtI4zZyVzqf3IDTwH2D8w7GZGIRnQaeT91l$#TlecSDw4I#crLHh1Ca2RqjXeSoJ#" +
		"$mYFdJVGLhkUDYd4TktaJspTcH1gf8hkV$jr9gAV7mZTXFYX2usf$aOOk#NCqUhR#vsYIyu" +
		"t#3S#ny4roD8b6gdZDc$#lD3H1HLn5QERH$6Wqj3G#3JrDwq8zJNI#WUnEpZUkLYn6wZZDS" +
		"PhZDF$RD65aV$tjBjQRMbjgXtjxwa0TwTPuLjGt6QlawZfkbQmLpl$QzuL1AnKw$ySRAqlR" +
		"k$FYphYsKn2UAC#wJlBPc5EapAbAoT$37p1rBA17Q24jSkki1NaiLht8Mn#ZFt5zOUek04a" +
		"VAXIzlzmJzDcKcsF2JhhFaDXqKzmoGxMrqPqrkYAopxIDjfirEZIk9sFboLzHWciKVOlkcK" +
		"PXFd16P6XmHF0cU2hOz8YK8Tiztpl4bO8Z8g4vfo7CeUh6ugJWRo0Yopb$QJRszOCn2VLkK" +
		"jtiAet2FDJ8M0H3Kyw4zJsxKR1Sez0z58Qko5qi#gK$VMRPTpcVvve1ITMVxdFYV0wa3MGq" +
		"H7yMTXj2$VcviYXp05BBAMOrH58$v6NhSa4XAdTfUDpN9oA#6RUqKDowmgHlCU5ZH7O9ety" +
		"4lOgtl1Pqu0kKAu#sroAiWwHkiBi0uL643SFRetTDlwePFlGbPOV9#u78VpBAz7BYDlfT8e" +
		"EeJAN8DYC5TYrZvzbzFNOF49Ky0U5d2A#7gyz2kCZ9Ixq3NDCDorQKws5yelt$2FBNmtOV$" +
		"A3xDHXoPNWx#gDtrcJJl#UGFz3HoxI5FWRvUSYVPUhCHzeumtStygOuUgdJeEz5cSM8t0ax" +
		"$Gd67KNxP27VUeOeFGUstw6E1QRTcw0$0SOdKS#J4Nv0Mdf7f1yryQcGTKRVOCgFXBuHiXB" +
		"wMCWduNLmDqzzctM8yGz0Ns$ozRnS0aNN$PAJbhuS$Ug1l3KOxvQ87q9yZPDNiXxI2iBRA8" +
		"b#bsjl#laYwldOj8SnusSHVcxoTB#$CFeda6yDGncaVudm8eHlXEhrbOQKyRIpdIYZLgHlO" +
		"mdgcsd2Fz1MpV2yKgWx7NFVFeYygo5hmlEjmyX3lotzRKMp1kGpdsU5sza$mUOToFkct14m" +
		"LqNODzpEbmcfX7PRG7x3kkc4ilz2#7Z8nb$LXDLWYtLLQXvHwIiG1uiVvLCkZgWJSzAFjU7" +
		"h2gbk#jeQQHLDleqwziDdGr3F6GWnn$tdGSutxTI6r36sJQ1VQUfOYFWb4MrX7lZg6hqNRF" +
		"CyUJqHlmfjOBzB7s$I1ZXXwQU9Ch4$biQSIzyTVPpyw8VlSgmBx8cbxu5V9Y4DyypUwx5f5" +
		"bw6pBeiesrpmOovvM#0#1kOYwcc37pd6sRqfl0Vreh$EiX5kfEXkZ9EH1di9Hdj4MAVy7KB" +
		"RolZKQGFH$e8bCLwzMDj#6ys$HnfwiUUuqEz$WA8$lJnIIOV#uX$G4H$1o4TwuBVXduxvie" +
		"4XCPl5lOt$pJ850YUBRvx8yhUPy9PaBd8rpop8PWhlaq8vvXsjngxVqBq$eBrvSUpmR$AfA" +
		"ykEWxy3SQeNYXkDJUseprfQCU#mUWBeC$tiAs3hxx7$l9JqRe9Uvz$lSTs0vZmFFJhz1Mew" +
		"pF33GR$yuvkduiuvet$zL0v6$FNRcPucuNICo$46Cs1xLkGNPvsu6FVBGZXR$#xA8knzfkr" +
		"wb$agRTbIFVz4SvktuoqUQOCrfF$GwDZV$D$7svR#bhqVsgK$cVf47bct$RzRkhM$zcamFG" +
		"1VRLgXvShEoYohl1ynXXGdQBflYuUtRF7#Dw8j3LSvfakHmizNx2F#tReCqHulPcN6QuJ3B" +
		"#kSvA7TsgulOLzoouPhm$nk4mRrJtrOInix6KMdk$scVePWl0iq$PIZrzEzEX1dsE$ix5Nb" +
		"3tRsBlpoiJtUTh93kcsEMELRUN9hnTUbXOQMwnz7$OAksdeZE1RwhKrvUyqUI$e#QpxfECO" +
		"1pClodO6TzSelYYjzmrFl849iqnVFp1X7xJn3wIN3o#VUKFHEZCxX$JqoYPjiASDxFtsUAH" +
		"XhxMnLzaFGIQQlAyWayFhyv#hpoecVwmt3$sR4T6VvXxT#2kuTzfHrf7zaASTd4Nj5P4siG" +
		"IsGqpVDF$G26RidPRPLp9N8$$wYBBcd9c9yvqzm#ZQlpEBjfE9yu1zloat7$5l8$s0jinPA" +
		"mKBoDu4l#mqVJyGXVifOtijz3UXb7FYV67qVkfzn5xawEaTm$DIfYCFxmKfUY$SP#fVwsbh" +
		"Mj7wqfT7RuT$Zf5krbk9Kz1Fezi7JTfjq74UBu4ztyVHoziV6LkSfMoStShsSU9b3tji9aO" +
		"lmoCCSy09Ko$1sAQ4x6YEHs$jX1PuwBLGUkeebAcCy2M4OUzdJduQpip#awApasVTM8UTq5" +
		"S5jq0q#v1j#erWd#ZqruyN4tyLRx#qO8xePrZfy7B#L4$#eV0yhkcnyvoZVQsyTYQ$oFiOh" +
		"bpKUSJJd$9HRCOXtPmtkGFqY7S3ndF4d#JwzBVtC1PvRqL#b#ZbBFDkGfx#fhM2$HXJLuy8" +
		"vlSYwiqpTeiyQQCyzX7l1g6yYFJn4LmscKk$SOLVgeVSjq0sgvbgXdfMFQSsAfo6r0QrNgs" +
		"JtBNgATnngb6p5Voinahg$UffjKRXtL1z3ZcilbTVokWVKBFKVO4FrHU13mBlYMLbbIFXPG" +
		"gdQtMbobALr0cgeggWogjo2YSXbQrELTNKAQgMmlk$Eb#D2MCyJ#44hSuL$HmdBO1tbi0la" +
		"CE1xmC79L##JwdELbVXZjEhEaFYfoiydTNLeZSqzTsjHgZXQXYqeH2ybQZJtBQk2NmU#Cpe" +
		"ybq#LGDINRHc2ZkVQXBu9F0n#fSVU1$4fIIdf5i#NUW#DB7ISg#YJb8NYbP7xhLLMmdb$z#" +
		"e6#NUmgsXbRf9mdQg4FSRL0ELgovLbwZwwc9raQgdwYey1rMQRaEb1huCV64yekCb0li27x" +
		"cn5Bdx0zy6lZ4fjWbzWQy3Nvds66aAybi0QpxmWqdLTM2s18u6VWyS2XmovIp8I3LAuSr13" +
		"OJ8Dq1LNxdVeVhZtazQFn3uJZMLr38AkvJAL1bk$nf1caC6IwncuDF0VfKNE69wyIlaPyYF" +
		"0RpHggfgj3fP7LIWKkY3#XhobJgaVaIuszJtaVf0lQBUX$QsUbFXtAtUK7kKfdtTRVCroAS" +
		"UUsTUlgFULP#5pTtlZ0tULjHZQggwLpskLb3OfHP37lN45q4UKGlLClM4n9UhXt5$I3se7b" +
		"3p9MMUtEUg1QR4QZLTJLC$YR##LUQRxQexfAl2UKdX$LNXtLRrLDqaPxAQf2OexCeAfn$ez" +
		"wWfOKJjLHVLMU69fcvNsFlKR#geal$eeNwL#ozo$rdzZdtmDC8R9eHfDrcq3k4wX1CGQfb7" +
		"FeYVvfEjVui4OREHC4qKiUGxoIEXBw0qUeHIwG6a3VI8$hywToE43o4CyP7UPNf0rnvw0g5" +
		"UtsCGwfraBC99b48x4EwGR#vP8l0YXDtuWv39Y4#6pKhahOG#2ELw8NqfuaiHr#FoAC9b29" +
		"SXN8vmESBr8XRXpHF2z3ILePSGdmBTaP2#GKJ7VMxQ8kXhK7ODz8qY5c5FX30j1CD2#6iJz" +
		"4r8rxyPtGnzAdmp3NdJeKz7#S481oD$CFIkqBj2xuPGVqTJoxsalmFg4nc5T2sF6td6o3r6" +
		"dXNHtzyX2DDCb9s9#6BItodKtrZrqGq8NuJq5F5H7#JfbTeNONUa1UKsn6y3loCwxXFf35r" +
		"$iwmBzDiXGn0V8j#bqUAZ4QXh1D9cYVZePQJhxvc$WlXiwAz2VnNwJkHjGRW5uNC8dvFli3" +
		"7jGlukXFeRB7eDF2#wN#9ReM#5tVr6Lg2#qQJ$TmEJ$d#1$H4kWMzNGLybtpBnGqf0KcaRy" +
		"hQXp1pvbYr3VAJ$gzzGwBUWxfiG9f9M8Zw8dsw6xeW5AG7nGVnkk1rrRvTy6v9YyYoJRz6D" +
		"o7F49s5hX2sHtX9X2yHRG6#3i8ryfuXZoZ0HY#OYd0lR3cYl0#8TH4#1#24b8lGqO#UdzWZ" +
		"RIvW2AU49Ko5fyktOTiXlX$HsI0#5gVBjnzvejpVQQejGomj6#XaPRsISaG56rXfPRUH98n" +
		"tXjuu8RnMnwBN$0rDLZGu=");

/*******************************************************
 *  Code for error handling in the parser class.
 *******************************************************/
  // all errors encountered during parsing is stored in the array parseProblems. This includes lexical, syntactical and semantic error (multiple initialization actors et.c.)
  BasicErrorModule em;

  public ErrorModule getErrorModule(){ return em; }

  private void warning(String msg, Symbol startS, Symbol endS){
    int start = startS.getStart();
    int end = endS.getEnd();
    em.warning(msg + " between " + Symbol.getLine(start) + ":" + Symbol.getColumn(start) + " and " + Symbol.getLine(end) + ":" + Symbol.getColumn(end) + " in " + file.getName(), null);
  }
  
  String posToString(Symbol s){
	  int start = s.getStart();
	  int end = s.getEnd();
	  return Symbol.getLine(start) + ":" + Symbol.getColumn(start) + ", " + Symbol.getLine(end) + ":" + Symbol.getColumn(end) + " in " + file.getName();
  }

  private void warnPortIndex(Expression[] index){
    if(index != null && index.length != 0){
      em.warning("port index is ignored", index[0]);
    }
  }

  // parser plug-in methods that are called when the parser encounters a syntactical problem
  class Events extends Parser.Events {
    public void scannerError(Scanner.Exception e) {
      em.error(e.getMessage(), null);
    }
    public void syntaxError(Symbol token) {
      // This method is always called when a problem is encountered, even if it is repaired.
      // beaver.Parser$Exception is thrown if recovery fails.
      String value = token.value != null ? token.value.toString() : Terminals.NAMES[token.getId()];
      em.error("unexpected token \"" + value + "\" at " + Symbol.getLine(token.getStart()) + ", " + Symbol.getColumn(token.getStart()), null);
    }
    public void unexpectedTokenRemoved(Symbol token) {
      String value = token.value != null ? token.value.toString() : Terminals.NAMES[token.getId()];
      em.warning("parser recovered after removing token \"" + value + "\" at " + Symbol.getLine(token.getStart()) + ", " + Symbol.getColumn(token.getStart()), null);
    }
    public void missingTokenInserted(Symbol token) {
      String value = token.value != null ? token.value.toString() : Terminals.NAMES[token.getId()];
      em.warning("parser recovered after inserting token \"" + value + "\" at " + Symbol.getLine(token.getStart()) + ", " + Symbol.getColumn(token.getStart()), null);
    }
    public void misspelledTokenReplaced(Symbol token) {
      String value = token.value != null ? token.value.toString() : Terminals.NAMES[token.getId()];
      em.warning("parser recovered after replacing token \"" + value + "\" at " + Symbol.getLine(token.getStart()) + ", " + Symbol.getColumn(token.getStart()), null);
    }
    public void errorPhraseRemoved(Symbol token) {
      String value = token.value != null ? token.value.toString() : Terminals.NAMES[token.getId()];
      em.warning("parser recovered after removing token \"" + value + "\" at " + Symbol.getLine(token.getStart()) + ", " + Symbol.getColumn(token.getStart()), null);
    }
  }

  {
    // initialization, before the constructor
    report = new Events(); // Use error handler in parser
  }

/********************************************************
 * Store the source code position of the symbols.
 * The following IR-nodes have source file information:
 * Registered by NLParser.beaver:
 * - EntityIfExpr
 * - EntityInstanceExpr
 * - EntityListExpr
 * - NlNetwork
 * - PortReference
 * - StructureConnectionStmt
 * - StructureForeachStmt
 * - StructureIfStmt
 * - ToolValueAttribute
 * - ToolTypeAttribute
 *
 * Registered by CommonParser.beaver
 * - ExprLiteral
 * - Field
 * - Variable
 * - ExprVariable
 *
 * The following IRNodes do not have source code info:
 * - GeneratorFilter
 * - Import
 * - LValue
 ********************************************************/

  private File file;
  private Map<Identifier, SourceCodePosition> srcLocations;
  public Symbol register(Symbol start, Symbol end, IRNode node){
    if(srcLocations != null){
      srcLocations.put(node.getIdentifier(), SourceCodePosition.newIncluding(start, end, file));
    }
    return new Symbol(node);
  }
  public Symbol register(IRNode start, Symbol end, IRNode node){
    if(srcLocations != null){
      srcLocations.put(node.getIdentifier(), SourceCodePosition.newIncluding(srcLocations.get(start.getIdentifier()), end));
    }
    return new Symbol(node);
  }
  public Symbol register(Symbol start, IRNode end, IRNode node){
    if(srcLocations != null){
      srcLocations.put(node.getIdentifier(), SourceCodePosition.newIncluding(start, srcLocations.get(end.getIdentifier())));
    }
    return new Symbol(node);
  }
  public Symbol register(IRNode start, IRNode end, IRNode node){
    if(srcLocations != null){
      srcLocations.put(node.getIdentifier(), SourceCodePosition.newIncluding(srcLocations.get(start.getIdentifier()), srcLocations.get(end.getIdentifier())));
    }
    return new Symbol(node);
  }
/*******************************************************
 *  Help routine that parses a file, given its name.
 *  A compilation unit is always returned, containing all parseProblems encountered during parsing.
 *  If a Parser.exception is thrown a CompilationUnit with an empty AST is returned.
 *******************************************************/
  private GlobalEntityDecl makeEmptyEntityDecl(File file){
    String name;
    int lastPeriodPos = file.getName().lastIndexOf('.');
    if(lastPeriodPos >=0){
      name = file.getName().substring(0, lastPeriodPos);
    } else {
      name = file.getName();
    }
    return new GlobalEntityDecl(name, null, null);   
  }
  
  public se.lth.cs.tycho.ir.decl.GlobalEntityDecl parse(String path, String fileName, Map<Identifier, SourceCodePosition> srcLocations, SourceCodeOracle scOracle){
    return parse(new java.io.File(path + "/" + fileName), srcLocations, scOracle);
  }
  public se.lth.cs.tycho.ir.decl.GlobalEntityDecl parse(File file, Map<Identifier, SourceCodePosition> srcLocations, SourceCodeOracle scOracle){
     this.file = file;
     this.srcLocations = srcLocations;
     em = new BasicErrorModule(scOracle);
     GlobalEntityDecl actor;
     java.io.FileReader fr = null;
     try {
       try{
         fr = new java.io.FileReader(file);
  	     CalScanner scanner = new CalScanner(new java.io.BufferedReader(fr));
         actor = (GlobalEntityDecl)parse(scanner);
       } catch(CalParser.Exception e) {
         // build empty compilation unit for failed error recovery
         // The problem is added to parseProblems[] by the syntaxError() method added to the parser above.
         actor = makeEmptyEntityDecl(file);
       } finally {
         if(fr != null){
           fr.close();
         }
       }
     } catch (java.io.FileNotFoundException e){
       em.error("file not found: " + e.getMessage(), null);
       actor = makeEmptyEntityDecl(file);
     } catch (java.io.IOException e){
       em.error("error reading file: " + e.getMessage(), null);
       actor = makeEmptyEntityDecl(file);
     }
     return actor;
   }

  private enum ActionPartKind{ GUARD, DECL_LIST, DELAY; }
  private enum ActorPartKind{ DECL_VAR, INIT_ACTION, ACTION, FSM_SCHEDULE, PRIORITY, INVARIANT_LIST; }

  /****************************************************************************
   * Needed by CommonParser.beaver
   * Repeated in both NlParser.beaver and CalParser.beaver
   ***************************************************************************/
  private Symbol makeGeneratorFilter(Symbol start, TypeExpr t, ImmutableList<Symbol>varList, Expression e, ImmutableList<Expression> filterList, ImmutableList l){
    GeneratorFilter gen = makeGeneratorFilter2(t, varList, e, filterList);
    Expression end = e;
    if(filterList != null && !filterList.isEmpty()){
   	 end = filterList.get(filterList.size()-1);
    }
    register(start, end, gen);
    ImmutableList.Builder newList = ImmutableList.builder().add(gen);
    if(l != null){
   	 newList.addAll(l);
    }
    return new Symbol(newList);
  }
  private GeneratorFilter makeGeneratorFilter2(TypeExpr type, ImmutableList<Symbol> varList, Expression e, ImmutableList<Expression> filterList){
    ImmutableList.Builder<LocalVarDecl> vars = ImmutableList.builder();
    for(Symbol var : varList){
      LocalVarDecl decl = new LocalVarDecl(type, (String)var.value);
      register(var, var, decl);
      vars.add(decl);
    }
    return new GeneratorFilter(vars.build(), e, filterList);
  }
  class ParenthesSymbol extends Symbol{ // used by the parser to wrap subexpressions that are enclosed by parentheses, i.e. do not add them to a ExprBinaryOp sequence.
    ParenthesSymbol(Symbol s){
      super(s.getId(), s.getStart(), s.getEnd(), s.value);
    }
  }
  
  private LValue expressionToLValue(Expression expression) {
    if (expression instanceof ExprVariable) {
      Variable var = ((ExprVariable) expression).getVariable();
      return new LValueVariable(expression, var);
    } else if (expression instanceof ExprIndexer) {
      ExprIndexer exprIndexer = (ExprIndexer) expression;
      LValue structure = expressionToLValue(exprIndexer.getStructure());
      if (structure == null) return null;
      LValue result = new LValueIndexer(structure, exprIndexer.getIndex());
      register(structure, exprIndexer, result);
      return result;
    } else if (expression instanceof ExprField) {
      ExprField exprField = (ExprField) expression;
      LValue structure = expressionToLValue(exprField.getStructure());
      if (structure == null) return null;
      LValue result = new LValueField(structure, exprField.getField());
      register(structure, exprField, result);
      return result;
    } else {
      return null;
    }
  }

	public CalParser() {
		super(PARSING_TABLES);
	}

	protected Symbol invokeReduceAction(int rule_num, int offset) {
		switch(rule_num) {
			case 2: // goal = actor_decl.actor_decl opt$SEMICOLON
			{
					final Symbol _symbol_actor_decl = _symbols[offset + 1];
					final GlobalEntityDecl actor_decl = (GlobalEntityDecl) _symbol_actor_decl.value;
					 return _symbol_actor_decl;
			}
			case 3: // import_list = import_part.i
			{
					final Symbol _symbol_i = _symbols[offset + 1];
					final ArrayList i = (ArrayList) _symbol_i.value;
					 ArrayList l = new ArrayList(); l.add(i); return new Symbol(l);
			}
			case 4: // import_list = import_list.l import_part.i
			{
					final Symbol _symbol_l = _symbols[offset + 1];
					final ArrayList l = (ArrayList) _symbol_l.value;
					final Symbol _symbol_i = _symbols[offset + 2];
					final ArrayList i = (ArrayList) _symbol_i.value;
					 l.add(i); return _symbol_l;
			}
			case 5: // import_part = import_single.i
			{
					final Symbol _symbol_i = _symbols[offset + 1];
					final ArrayList i = (ArrayList) _symbol_i.value;
					 return _symbol_i;
			}
			case 6: // import_part = import_group.i
			{
					final Symbol _symbol_i = _symbols[offset + 1];
					final ArrayList i = (ArrayList) _symbol_i.value;
					 return _symbol_i;
			}
			case 7: // import_single = IMPORT qual_id.qual_id SEMICOLON
			{
					final Symbol _symbol_qual_id = _symbols[offset + 2];
					final ArrayList qual_id = (ArrayList) _symbol_qual_id.value;
					 return _symbol_qual_id;
			}
			case 8: // import_single = IMPORT qual_id.qual_id EQ IDENTIFIER.alias SEMICOLON
			{
					final Symbol _symbol_qual_id = _symbols[offset + 2];
					final ArrayList qual_id = (ArrayList) _symbol_qual_id.value;
					final Symbol alias = _symbols[offset + 4];
					 return _symbol_qual_id;
			}
			case 9: // import_group = IMPORT ALL qual_id.qual_id SEMICOLON
			{
					final Symbol _symbol_qual_id = _symbols[offset + 3];
					final ArrayList qual_id = (ArrayList) _symbol_qual_id.value;
					 return _symbol_qual_id;
			}
			case 14: // lst$action_head = action_head
			{
					ArrayList lst = new ArrayList(); lst.add(_symbols[offset + 1].value); return new Symbol(lst);
			}
			case 15: // lst$action_head = lst$action_head action_head
			{
					((ArrayList) _symbols[offset + 1].value).add(_symbols[offset + 2].value); return _symbols[offset + 1];
			}
			case 18: // action_decl = opt$action_tag.tag ACTION.start action_in_pattern_list.in_pattern_list PORTCONN opt$action_output_expression_list.out_expr_list opt$lst$action_head.head action_statement_body.body end_action.end opt$SEMICOLON
			{
					final Symbol _symbol_tag = _symbols[offset + 1];
					final QID tag = (QID) _symbol_tag.value;
					final Symbol start = _symbols[offset + 2];
					final Symbol _symbol_in_pattern_list = _symbols[offset + 3];
					final ImmutableList.Builder in_pattern_list = (ImmutableList.Builder) _symbol_in_pattern_list.value;
					final Symbol _symbol_out_expr_list = _symbols[offset + 5];
					final ImmutableList.Builder out_expr_list = (ImmutableList.Builder) _symbol_out_expr_list.value;
					final Symbol _symbol_head = _symbols[offset + 6];
					final ArrayList _list_head = (ArrayList) _symbol_head.value;
					final Map.Entry[] head = _list_head == null ? new Map.Entry[0] : (Map.Entry[]) _list_head.toArray(new Map.Entry[_list_head.size()]);
					final Symbol _symbol_body = _symbols[offset + 7];
					final ImmutableList body = (ImmutableList) _symbol_body.value;
					final Symbol end = _symbols[offset + 8];
					
           // split the action head to it's parts
           ImmutableList.Builder<Expression> guardList = ImmutableList.builder();
           Expression delay = null;
           ImmutableList.Builder<LocalVarDecl> declVarList = ImmutableList.builder();
           for(Map.Entry part : head){
             switch((ActionPartKind)part.getKey()){
               case GUARD:
                 guardList.addAll((Iterable)part.getValue());
                 break;
               case DECL_LIST:
                 declVarList.addAll((Iterable)part.getValue());
                 break;
               case DELAY:
                 if(delay != null){ em.error("multiple delays is not allowed in action.", (Expression)part.getValue()); }
                 delay = (Expression)part.getValue();
                 break;
             }
           }
            Action a = new Action(-1,              // id
                                  tag,             // tag
                                  in_pattern_list.build(), //inputPatterns
                                  out_expr_list == null ? null : out_expr_list.build(),   //outputExpressions
                                  null,            // typeDecls
                                  declVarList.build(),     // varDecls
                                  guardList.build(),       // guards 
                                  body,            // body
                                  delay,           // delay
                                  null,            // preconditions  NOTE, can not be expressed in CAL
                                  null);           // postconditions NOTE, can not be expressed in CAL
            return register(start, end, a);
			}
			case 19: // init_action_decl = opt$action_tag.tag INITIALIZE.start PORTCONN opt$action_output_expression_list.out_expr_list opt$lst$action_head.head action_statement_body.body end_action.end opt$SEMICOLON
			{
					final Symbol _symbol_tag = _symbols[offset + 1];
					final QID tag = (QID) _symbol_tag.value;
					final Symbol start = _symbols[offset + 2];
					final Symbol _symbol_out_expr_list = _symbols[offset + 4];
					final ImmutableList.Builder out_expr_list = (ImmutableList.Builder) _symbol_out_expr_list.value;
					final Symbol _symbol_head = _symbols[offset + 5];
					final ArrayList _list_head = (ArrayList) _symbol_head.value;
					final Map.Entry[] head = _list_head == null ? new Map.Entry[0] : (Map.Entry[]) _list_head.toArray(new Map.Entry[_list_head.size()]);
					final Symbol _symbol_body = _symbols[offset + 6];
					final ImmutableList body = (ImmutableList) _symbol_body.value;
					final Symbol end = _symbols[offset + 7];
					 
           // split the action head to it's parts
           ImmutableList.Builder<Expression> guardList = ImmutableList.builder();
           Expression delay = null;
           ImmutableList.Builder<LocalVarDecl> declVarList = ImmutableList.builder();
           for(Map.Entry part : head){
             switch((ActionPartKind)part.getKey()){
               case GUARD:
                 guardList.addAll((ArrayList)part.getValue());
                 break;
               case DECL_LIST:
                 declVarList.addAll((ArrayList<LocalVarDecl>)part.getValue());
                 break;
               case DELAY:
                 if(delay != null){ em.error("multiple delays is not allowed in action.", (Expression)part.getValue()); }
                 delay = (Expression)part.getValue();
                 break;
             }
           }
            Action a = new Action(-1,                        // id
                                  tag,                       // tag
                                  null,       //inputPatterns
                                  out_expr_list==null ? null : out_expr_list.build(),  //outputExpressions
                                  null,                                              // typeDecls
                                  declVarList.build(),         // varDecls
                                  guardList.build(),          // guards 
                                  body,        // body
                                  delay,                      // delay
                                  null,         // preconditions  NOTE, can not be expressed in CAL
                                  null);        // postconditions NOTE, can not be expressed in CAL
            return register(start, end, a);
			}
			case 20: // action_tag = qual_id.n COLON.end
			{
					final Symbol _symbol_n = _symbols[offset + 1];
					final ArrayList n = (ArrayList) _symbol_n.value;
					final Symbol end = _symbols[offset + 2];
					 return new Symbol(QID.of((String[])n.toArray(new String[n.size()])));
			}
			case 21: // action_head = GUARD expression_list.l
			{
					final Symbol _symbol_l = _symbols[offset + 2];
					final ImmutableList.Builder l = (ImmutableList.Builder) _symbol_l.value;
					 return new Symbol(new AbstractMap.SimpleEntry(ActionPartKind.GUARD, l.build()));
			}
			case 22: // action_head = VAR decl_list.d
			{
					final Symbol _symbol_d = _symbols[offset + 2];
					final ImmutableList.Builder d = (ImmutableList.Builder) _symbol_d.value;
					 return new Symbol(new AbstractMap.SimpleEntry(ActionPartKind.DECL_LIST, d.build()));
			}
			case 23: // action_head = DELAY.s expression.e
			{
					final Symbol s = _symbols[offset + 1];
					final Symbol _symbol_e = _symbols[offset + 2];
					final Expression e = (Expression) _symbol_e.value;
					 register(s, e, e); return new Symbol(new AbstractMap.SimpleEntry(ActionPartKind.DELAY, e));
			}
			case 24: // action_statement_body = 
			{
					 return new Symbol(ImmutableList.empty());
			}
			case 25: // action_statement_body = DO statement_list_opt.s
			{
					final Symbol _symbol_s = _symbols[offset + 2];
					final ImmutableList s = (ImmutableList) _symbol_s.value;
					 return new Symbol(s);
			}
			case 26: // action_in_pattern_list = 
			{
					 return new Symbol(ImmutableList.builder());
			}
			case 27: // action_in_pattern_list = action_in_pattern.p
			{
					final Symbol _symbol_p = _symbols[offset + 1];
					final InputPattern p = (InputPattern) _symbol_p.value;
					 return new Symbol(ImmutableList.builder().add(p));
			}
			case 28: // action_in_pattern_list = action_in_pattern_list.l COMMA action_in_pattern.p
			{
					final Symbol _symbol_l = _symbols[offset + 1];
					final ImmutableList.Builder l = (ImmutableList.Builder) _symbol_l.value;
					final Symbol _symbol_p = _symbols[offset + 3];
					final InputPattern p = (InputPattern) _symbol_p.value;
					 l.add(p); return _symbol_l;
			}
			case 37: // action_in_pattern = opt$port_name_colon.actor_port_name LBRACK.start opt$token_name_list.tokens RBRACK.end opt$repeat.r opt$channel_selector.c
			{
					final Symbol _symbol_actor_port_name = _symbols[offset + 1];
					final Port actor_port_name = (Port) _symbol_actor_port_name.value;
					final Symbol start = _symbols[offset + 2];
					final Symbol _symbol_tokens = _symbols[offset + 3];
					final ImmutableList.Builder tokens = (ImmutableList.Builder) _symbol_tokens.value;
					final Symbol end = _symbols[offset + 4];
					final Symbol _symbol_r = _symbols[offset + 5];
					final Expression r = (Expression) _symbol_r.value;
					final Symbol _symbol_c = _symbols[offset + 6];
					final String c = (String) _symbol_c.value;
					 Symbol s = actor_port_name == null ? start : _symbol_actor_port_name;
        Symbol e = r == null ? end : _symbol_r;  // FIXME, ignores channel selector
        return register(s, e, new InputPattern(actor_port_name, tokens==null ? null : tokens.build(), r));
			}
			case 38: // token_name_list = IDENTIFIER.ID
			{
					final Symbol ID = _symbols[offset + 1];
					 LocalVarDecl decl = new LocalVarDecl(null, (String) ID.value);
                                               register(ID, ID, decl);
                                               return new Symbol(ImmutableList.builder().add(decl));
			}
			case 39: // token_name_list = token_name_list.l COMMA IDENTIFIER.ID
			{
					final Symbol _symbol_l = _symbols[offset + 1];
					final ImmutableList.Builder l = (ImmutableList.Builder) _symbol_l.value;
					final Symbol ID = _symbols[offset + 3];
					 Decl decl = new LocalVarDecl(null, (String) ID.value);
                                               register(ID, ID, decl);
                                               l.add(decl); return _symbol_l;
			}
			case 40: // channel_selector = AT.a expression.e
			{
					final Symbol a = _symbols[offset + 1];
					final Symbol _symbol_e = _symbols[offset + 2];
					final Expression e = (Expression) _symbol_e.value;
					 em.error("channel selector is not supported, at found at " + posToString(a), null);
                                return _symbol_e;
			}
			case 41: // channel_selector = ATSTAR.a expression.e
			{
					final Symbol a = _symbols[offset + 1];
					final Symbol _symbol_e = _symbols[offset + 2];
					final Expression e = (Expression) _symbol_e.value;
					 em.error("channel selector is not supported, at* found at " + posToString(a), null);
                                return _symbol_e;
			}
			case 44: // channel_selector = opt$ATSTAR ANY.a
			{
					final Symbol a = _symbols[offset + 2];
					 em.error("channel selector is not supported, any found at " + posToString(a), null);
                                return a;
			}
			case 45: // channel_selector = opt$ATSTAR ALL.a
			{
					final Symbol a = _symbols[offset + 2];
					 em.error("channel selector is not supported, all found at " + posToString(a), null);
                                return a;
			}
			case 46: // repeat = REPEAT expression.e
			{
					final Symbol _symbol_e = _symbols[offset + 2];
					final Expression e = (Expression) _symbol_e.value;
					 return _symbol_e;
			}
			case 47: // action_output_expression_list = action_output_expression.e
			{
					final Symbol _symbol_e = _symbols[offset + 1];
					final OutputExpression e = (OutputExpression) _symbol_e.value;
					 return new Symbol(ImmutableList.builder().add(e));
			}
			case 48: // action_output_expression_list = action_output_expression_list.l COMMA action_output_expression.e
			{
					final Symbol _symbol_l = _symbols[offset + 1];
					final ImmutableList.Builder l = (ImmutableList.Builder) _symbol_l.value;
					final Symbol _symbol_e = _symbols[offset + 3];
					final OutputExpression e = (OutputExpression) _symbol_e.value;
					 l.add(e); return _symbol_l;
			}
			case 51: // action_output_expression = opt$port_name_colon.actor_port_name LBRACK.start opt$expression_list.values RBRACK.end opt$repeat.r opt$channel_selector.c
			{
					final Symbol _symbol_actor_port_name = _symbols[offset + 1];
					final Port actor_port_name = (Port) _symbol_actor_port_name.value;
					final Symbol start = _symbols[offset + 2];
					final Symbol _symbol_values = _symbols[offset + 3];
					final ImmutableList.Builder values = (ImmutableList.Builder) _symbol_values.value;
					final Symbol end = _symbols[offset + 4];
					final Symbol _symbol_r = _symbols[offset + 5];
					final Expression r = (Expression) _symbol_r.value;
					final Symbol _symbol_c = _symbols[offset + 6];
					final String c = (String) _symbol_c.value;
					 OutputExpression out = new OutputExpression(actor_port_name, values == null ? null : values.build(), r);
         if(actor_port_name == null){
           if(r == null){
             return register(start, end, out);
           } else {
             return register(start, r, out);
           }
         } else {
           if(r == null){
             return register(actor_port_name, end, out);
           } else {
             return register(actor_port_name, r, out);
           }
         }
			}
			case 52: // port_name_colon = IDENTIFIER.id COLON
			{
					final Symbol id = _symbols[offset + 1];
					 return register(id, id, new Port((String)id.value));
			}
			case 61: // lst$actor_body = actor_body
			{
					ArrayList lst = new ArrayList(); lst.add(_symbols[offset + 1].value); return new Symbol(lst);
			}
			case 62: // lst$actor_body = lst$actor_body actor_body
			{
					((ArrayList) _symbols[offset + 1].value).add(_symbols[offset + 2].value); return _symbols[offset + 1];
			}
			case 65: // actor_decl = opt$import_list.imports ACTOR.start IDENTIFIER.name opt$type_parameter_block.typePars LPAREN opt$actor_parameter_list.valuePars RPAREN port_decl_list_opt.in PORTCONN port_decl_list_opt.out opt$time.t COLON opt$lst$actor_body.body end_actor.end
			{
					final Symbol _symbol_imports = _symbols[offset + 1];
					final ArrayList imports = (ArrayList) _symbol_imports.value;
					final Symbol start = _symbols[offset + 2];
					final Symbol name = _symbols[offset + 3];
					final Symbol _symbol_typePars = _symbols[offset + 4];
					final ImmutableList typePars = (ImmutableList) _symbol_typePars.value;
					final Symbol _symbol_valuePars = _symbols[offset + 6];
					final ImmutableList.Builder valuePars = (ImmutableList.Builder) _symbol_valuePars.value;
					final Symbol _symbol_in = _symbols[offset + 8];
					final ImmutableList in = (ImmutableList) _symbol_in.value;
					final Symbol _symbol_out = _symbols[offset + 10];
					final ImmutableList out = (ImmutableList) _symbol_out.value;
					final Symbol _symbol_t = _symbols[offset + 11];
					final TypeExpr t = (TypeExpr) _symbol_t.value;
					final Symbol _symbol_body = _symbols[offset + 13];
					final ArrayList _list_body = (ArrayList) _symbol_body.value;
					final Map.Entry[] body = _list_body == null ? new Map.Entry[0] : (Map.Entry[]) _list_body.toArray(new Map.Entry[_list_body.size()]);
					final Symbol end = _symbols[offset + 14];
					
    if(t != null){ 
      em.warning("time is not supported", t); 
    }
    ImmutableList.Builder varDecls = ImmutableList.builder();
    ImmutableList.Builder initializers = ImmutableList.builder();
    ImmutableList.Builder actions = ImmutableList.builder();
    ScheduleFSM scheduleFSM = null;
    ImmutableList.Builder priorities = ImmutableList.builder();
    ImmutableList.Builder invariants = ImmutableList.builder();
    for(Map.Entry part : body){
      switch((ActorPartKind)part.getKey()){
        case DECL_VAR:
          varDecls.add(part.getValue());
          break;
        case INIT_ACTION:
          initializers.add(part.getValue());
          break;
        case ACTION:
          actions.add(part.getValue());
          break;
        case FSM_SCHEDULE:
          scheduleFSM = (ScheduleFSM)part.getValue();
          break;
        case PRIORITY:
          priorities.addAll((Collection)part.getValue());
          break;
        case INVARIANT_LIST:
          invariants.addAll((Collection)part.getValue());
          break;
      }
    }
    CalActor a = new CalActor(
                         typePars,     // typePars,
                         valuePars == null ? null : valuePars.build(), // valuePars,
                         null,      // typeDecls, NOTE, can not be expressed in CAL
                         varDecls.build(),             // varDecls
                         in,
                         out,
                         initializers.build(),
                         actions.build(),
                         scheduleFSM,
                         priorities.build(),
                         invariants.build()
                        );
    GlobalEntityDecl d = new GlobalEntityDecl((String) name.value, a, Availability.PUBLIC);
    return register(start, end, d);
			}
			case 66: // time = TIME.start type.t
			{
					final Symbol start = _symbols[offset + 1];
					final Symbol _symbol_t = _symbols[offset + 2];
					final TypeExpr t = (TypeExpr) _symbol_t.value;
					 return register(start, _symbol_t, t);
			}
			case 67: // actor_body = action_decl.a
			{
					final Symbol _symbol_a = _symbols[offset + 1];
					final Action a = (Action) _symbol_a.value;
					 return new Symbol(new AbstractMap.SimpleEntry(ActorPartKind.ACTION, a));
			}
			case 68: // actor_body = init_action_decl.a
			{
					final Symbol _symbol_a = _symbols[offset + 1];
					final Action a = (Action) _symbol_a.value;
					 return new Symbol(new AbstractMap.SimpleEntry(ActorPartKind.INIT_ACTION, a));
			}
			case 69: // actor_body = var_decl.d SEMICOLON
			{
					final Symbol _symbol_d = _symbols[offset + 1];
					final LocalVarDecl d = (LocalVarDecl) _symbol_d.value;
					 return new Symbol(new AbstractMap.SimpleEntry(ActorPartKind.DECL_VAR, d));
			}
			case 70: // actor_body = fun_decl.d
			{
					final Symbol _symbol_d = _symbols[offset + 1];
					final LocalVarDecl d = (LocalVarDecl) _symbol_d.value;
					 return new Symbol(new AbstractMap.SimpleEntry(ActorPartKind.DECL_VAR, d));
			}
			case 71: // actor_body = proc_decl.d
			{
					final Symbol _symbol_d = _symbols[offset + 1];
					final LocalVarDecl d = (LocalVarDecl) _symbol_d.value;
					 return new Symbol(new AbstractMap.SimpleEntry(ActorPartKind.DECL_VAR, d));
			}
			case 72: // lst$pri_inequality_list = pri_inequality_list
			{
					ArrayList lst = new ArrayList(); lst.add(_symbols[offset + 1].value); return new Symbol(lst);
			}
			case 73: // lst$pri_inequality_list = lst$pri_inequality_list pri_inequality_list
			{
					((ArrayList) _symbols[offset + 1].value).add(_symbols[offset + 2].value); return _symbols[offset + 1];
			}
			case 74: // actor_body = PRIORITY lst$pri_inequality_list.l END
			{
					final Symbol _symbol_l = _symbols[offset + 2];
					final ArrayList _list_l = (ArrayList) _symbol_l.value;
					final ImmutableList[] l = _list_l == null ? new ImmutableList[0] : (ImmutableList[]) _list_l.toArray(new ImmutableList[_list_l.size()]);
					 return new Symbol(new AbstractMap.SimpleEntry(ActorPartKind.PRIORITY, _list_l));
			}
			case 75: // actor_body = schedule.s
			{
					final Symbol _symbol_s = _symbols[offset + 1];
					final ScheduleFSM s = (ScheduleFSM) _symbol_s.value;
					 return new Symbol(new AbstractMap.SimpleEntry(ActorPartKind.FSM_SCHEDULE, s));
			}
			case 76: // actor_body = invariant.i
			{
					final Symbol _symbol_i = _symbols[offset + 1];
					final ImmutableList i = (ImmutableList) _symbol_i.value;
					 return new Symbol(new AbstractMap.SimpleEntry(ActorPartKind.INVARIANT_LIST, i));
			}
			case 77: // invariant = INVARIANT expression_list.l end_invariant
			{
					final Symbol _symbol_l = _symbols[offset + 2];
					final ImmutableList.Builder l = (ImmutableList.Builder) _symbol_l.value;
					 return new Symbol(l.build());
			}
			case 80: // lst$fsm_state_transitions = fsm_state_transitions
			{
					ArrayList lst = new ArrayList(); lst.add(_symbols[offset + 1].value); return new Symbol(lst);
			}
			case 81: // lst$fsm_state_transitions = lst$fsm_state_transitions fsm_state_transitions
			{
					((ArrayList) _symbols[offset + 1].value).add(_symbols[offset + 2].value); return _symbols[offset + 1];
			}
			case 84: // schedule = SCHEDULE.start opt$FSM IDENTIFIER.ID COLON opt$lst$fsm_state_transitions.trans end_schedule.end
			{
					final Symbol start = _symbols[offset + 1];
					final Symbol ID = _symbols[offset + 3];
					final Symbol _symbol_trans = _symbols[offset + 5];
					final ArrayList _list_trans = (ArrayList) _symbol_trans.value;
					final ImmutableList.Builder[] trans = _list_trans == null ? new ImmutableList.Builder[0] : (ImmutableList.Builder[]) _list_trans.toArray(new ImmutableList.Builder[_list_trans.size()]);
					final Symbol end = _symbols[offset + 6];
					  ImmutableList.Builder tl = trans.length>0 ? trans[0] : new ImmutableList.Builder();
          for(int i=1; i<trans.length; i++){
            tl.addAll(trans[i].build());
          }
          return register(start, end, new ScheduleFSM(tl.build(), (String)ID.value));
			}
			case 85: // schedule = SCHEDULE.start REGEXP regexpr.r end_schedule.end
			{
					final Symbol start = _symbols[offset + 1];
					final Symbol r = _symbols[offset + 3];
					final Symbol end = _symbols[offset + 4];
					 IRNode pos = new ScheduleFSM(ImmutableList.<Transition>empty(), "$regexpr"); // dummy node needed for error reporting
       Symbol result = register(start, end, pos);
       em.error("Regular expression schedules is not supported", pos); 
       return result;
			}
			case 86: // lst$fsm_state_target = fsm_state_target
			{
					ArrayList lst = new ArrayList(); lst.add(_symbols[offset + 1].value); return new Symbol(lst);
			}
			case 87: // lst$fsm_state_target = lst$fsm_state_target fsm_state_target
			{
					((ArrayList) _symbols[offset + 1].value).add(_symbols[offset + 2].value); return _symbols[offset + 1];
			}
			case 90: // fsm_state_transitions = IDENTIFIER.Src_state LPAREN action_tag_list.tags RPAREN EDGE IDENTIFIER.Dst_state opt$lst$fsm_state_target.more SEMICOLON.end
			{
					final Symbol Src_state = _symbols[offset + 1];
					final Symbol _symbol_tags = _symbols[offset + 3];
					final ImmutableList.Builder tags = (ImmutableList.Builder) _symbol_tags.value;
					final Symbol Dst_state = _symbols[offset + 6];
					final Symbol _symbol_more = _symbols[offset + 7];
					final ArrayList _list_more = (ArrayList) _symbol_more.value;
					final Transition[] more = _list_more == null ? new Transition[0] : (Transition[]) _list_more.toArray(new Transition[_list_more.size()]);
					final Symbol end = _symbols[offset + 8];
					 ImmutableList.Builder result = ImmutableList.builder();
          String startState = (String)Src_state.value;
          Transition trans = new Transition(startState,
                                    (String)Dst_state.value,
                                    tags.build());
          register(Src_state, end, trans);
          result.add(trans);
          for(Transition t : more){
            trans = new Transition(startState, t.getDestinationState(), t.getActionTags());
            register(Src_state, end, trans);
            result.add(trans);
          }
          return new Symbol(result);
			}
			case 91: // fsm_state_target = BAR LPAREN action_tag_list.tags RPAREN EDGE IDENTIFIER.Dst_state
			{
					final Symbol _symbol_tags = _symbols[offset + 3];
					final ImmutableList.Builder tags = (ImmutableList.Builder) _symbol_tags.value;
					final Symbol Dst_state = _symbols[offset + 6];
					 return new Symbol(new Transition(null,  // the start state is unknown. This is filled in later.
                                           (String)Dst_state.value,
                                           tags.build()));
			}
			case 92: // action_tag_list = qual_id.id
			{
					final Symbol _symbol_id = _symbols[offset + 1];
					final ArrayList id = (ArrayList) _symbol_id.value;
					 QID qid = QID.of((String[])id.toArray(new String[id.size()]));
                                          return new Symbol(ImmutableList.builder().add(qid));
			}
			case 93: // action_tag_list = action_tag_list.l COMMA qual_id.id
			{
					final Symbol _symbol_l = _symbols[offset + 1];
					final ImmutableList.Builder l = (ImmutableList.Builder) _symbol_l.value;
					final Symbol _symbol_id = _symbols[offset + 3];
					final ArrayList id = (ArrayList) _symbol_id.value;
					 QID qid = QID.of((String[])id.toArray(new String[id.size()]));
                                          l.add(qid);
                                          return _symbol_l;
			}
			case 94: // regexpr = regexpr_kleene.r
			{
					final Symbol r = _symbols[offset + 1];
					 return r;
			}
			case 95: // regexpr = regexpr.r1 regexpr_kleene.r2
			{
					final Symbol r1 = _symbols[offset + 1];
					final Symbol r2 = _symbols[offset + 2];
					 return r1;
			}
			case 96: // regexpr = regexpr.r1 BAR regexpr_kleene.r2
			{
					final Symbol r1 = _symbols[offset + 1];
					final Symbol r2 = _symbols[offset + 3];
					 return r1;
			}
			case 97: // regexpr_kleene = regexpr_simple.r
			{
					final Symbol r = _symbols[offset + 1];
					 return r;
			}
			case 98: // regexpr_kleene = regexpr_simple.r MULT
			{
					final Symbol r = _symbols[offset + 1];
					 return r;
			}
			case 99: // regexpr_simple = qual_id.n
			{
					final Symbol _symbol_n = _symbols[offset + 1];
					final ArrayList n = (ArrayList) _symbol_n.value;
					 return _symbol_n;
			}
			case 100: // regexpr_simple = LPAREN regexpr.r RPAREN
			{
					final Symbol r = _symbols[offset + 2];
					 return r;
			}
			case 101: // regexpr_simple = LBRACK regexpr.r RBRACK
			{
					final Symbol r = _symbols[offset + 2];
					 return r;
			}
			case 102: // pri_inequality_list = pri_inequality.p SEMICOLON
			{
					final Symbol _symbol_p = _symbols[offset + 1];
					final ImmutableList.Builder p = (ImmutableList.Builder) _symbol_p.value;
					 return new Symbol(p.build());
			}
			case 103: // pri_inequality = qual_id.high GT qual_id.low
			{
					final Symbol _symbol_high = _symbols[offset + 1];
					final ArrayList high = (ArrayList) _symbol_high.value;
					final Symbol _symbol_low = _symbols[offset + 3];
					final ArrayList low = (ArrayList) _symbol_low.value;
					 QID lowQID = QID.of((String[])low.toArray(new String[low.size()]));
                                          QID highQID = QID.of((String[])high.toArray(new String[high.size()]));
                                          return new Symbol(ImmutableList.builder().add(highQID).add(lowQID));
			}
			case 104: // pri_inequality = pri_inequality.l GT qual_id.n
			{
					final Symbol _symbol_l = _symbols[offset + 1];
					final ImmutableList.Builder l = (ImmutableList.Builder) _symbol_l.value;
					final Symbol _symbol_n = _symbols[offset + 3];
					final ArrayList n = (ArrayList) _symbol_n.value;
					 QID qid = QID.of((String[])n.toArray(new String[n.size()]));
                                          l.add(qid);
                                          return _symbol_l;
			}
			case 113: // actor_parameter_list = actor_parameter.p
			{
					final Symbol _symbol_p = _symbols[offset + 1];
					final ParDeclValue p = (ParDeclValue) _symbol_p.value;
					 return new Symbol(ImmutableList.builder().add(p));
			}
			case 114: // actor_parameter_list = actor_parameter_list.l COMMA actor_parameter.p
			{
					final Symbol _symbol_l = _symbols[offset + 1];
					final ImmutableList.Builder l = (ImmutableList.Builder) _symbol_l.value;
					final Symbol _symbol_p = _symbols[offset + 3];
					final ParDeclValue p = (ParDeclValue) _symbol_p.value;
					 l.add(p); return _symbol_l;
			}
			case 117: // actor_parameter = IDENTIFIER.id opt$actor_parameter_init_expression.e
			{
					final Symbol id = _symbols[offset + 1];
					final Symbol _symbol_e = _symbols[offset + 2];
					final Expression e = (Expression) _symbol_e.value;
					 ParDeclValue decl = new ParDeclValue((String)id.value, null);
                                                               Symbol result = register(id, id, decl);
                                                               if(e != null){ register(id, e, decl); em.warning("default value for parameter " + (String)id.value + " is ignored.", decl);}; 
                                                               return result;
			}
			case 118: // actor_parameter = type.t IDENTIFIER.id opt$actor_parameter_init_expression.e
			{
					final Symbol _symbol_t = _symbols[offset + 1];
					final TypeExpr t = (TypeExpr) _symbol_t.value;
					final Symbol id = _symbols[offset + 2];
					final Symbol _symbol_e = _symbols[offset + 3];
					final Expression e = (Expression) _symbol_e.value;
					 ParDecl decl = new ParDeclValue((String)id.value, t);
                                                               Symbol result = register(t, id, decl);
                                                               if(e != null){ register(t, e, decl); em.warning("default value for parameter " + (String)id.value + " is ignored.", decl);}; 
                                                               return result;
			}
			case 119: // actor_parameter_init_expression = EQ expression.e
			{
					final Symbol _symbol_e = _symbols[offset + 2];
					final Expression e = (Expression) _symbol_e.value;
					 return _symbol_e;
			}
			case 120: // qual_id = IDENTIFIER.id
			{
					final Symbol id = _symbols[offset + 1];
					 ArrayList l = new ArrayList(); l.add(id.value); return new Symbol(id.getId(), id.getStart(), id.getEnd(), l);
			}
			case 121: // qual_id = IDENTIFIER.id DOT qual_id.l
			{
					final Symbol id = _symbols[offset + 1];
					final Symbol _symbol_l = _symbols[offset + 3];
					final ArrayList l = (ArrayList) _symbol_l.value;
					 l.add(0, id.value); return new Symbol(id.getId(), id.getStart(), _symbol_l.getEnd(), l);
			}
			case 122: // variable = IDENTIFIER.id
			{
					final Symbol id = _symbols[offset + 1];
					 return register(id, id, Variable.variable((String) id.value));
			}
			case 123: // field = IDENTIFIER.id
			{
					final Symbol id = _symbols[offset + 1];
					 return register(id, id, new Field((String) id.value));
			}
			case 124: // decl_list = decl.d
			{
					final Symbol _symbol_d = _symbols[offset + 1];
					final LocalVarDecl d = (LocalVarDecl) _symbol_d.value;
					 return new Symbol(ImmutableList.builder().add(d));
			}
			case 125: // decl_list = decl_list.l COMMA decl.d
			{
					final Symbol _symbol_l = _symbols[offset + 1];
					final ImmutableList.Builder l = (ImmutableList.Builder) _symbol_l.value;
					final Symbol _symbol_d = _symbols[offset + 3];
					final LocalVarDecl d = (LocalVarDecl) _symbol_d.value;
					 l.add(d); return _symbol_l;
			}
			case 126: // decl_block = VAR decl_list.d
			{
					final Symbol _symbol_d = _symbols[offset + 2];
					final ImmutableList.Builder d = (ImmutableList.Builder) _symbol_d.value;
					 return new Symbol(d.build());
			}
			case 127: // decl_block_opt = 
			{
					 return new Symbol(ImmutableList.empty());
			}
			case 128: // decl_block_opt = VAR decl_list.d
			{
					final Symbol _symbol_d = _symbols[offset + 2];
					final ImmutableList.Builder d = (ImmutableList.Builder) _symbol_d.value;
					 return new Symbol(d.build());
			}
			case 129: // decl = var_decl.d
			{
					final Symbol _symbol_d = _symbols[offset + 1];
					final LocalVarDecl d = (LocalVarDecl) _symbol_d.value;
					 return _symbol_d;
			}
			case 130: // decl = fun_decl.d
			{
					final Symbol _symbol_d = _symbols[offset + 1];
					final LocalVarDecl d = (LocalVarDecl) _symbol_d.value;
					 return _symbol_d;
			}
			case 131: // decl = proc_decl.d
			{
					final Symbol _symbol_d = _symbols[offset + 1];
					final LocalVarDecl d = (LocalVarDecl) _symbol_d.value;
					 return _symbol_d;
			}
			case 132: // var_decl = MUTABLE.m var_name_type.v
			{
					final Symbol m = _symbols[offset + 1];
					final Symbol _symbol_v = _symbols[offset + 2];
					final LocalVarDecl v = (LocalVarDecl) _symbol_v.value;
					 em.warning("mutable is ignored for " + v.getName(), v); 
                                                         register(m, v, v);
                                                         return _symbol_v;
			}
			case 133: // var_decl = MUTABLE.m var_name_type.v EQ expression.init
			{
					final Symbol m = _symbols[offset + 1];
					final Symbol _symbol_v = _symbols[offset + 2];
					final LocalVarDecl v = (LocalVarDecl) _symbol_v.value;
					final Symbol _symbol_init = _symbols[offset + 4];
					final Expression init = (Expression) _symbol_init.value;
					 em.warning("mutable is ignored for " + v.getName(), v);
                                                         return register(m, init, v.copy(v.getType(), v.getName(), init, false));
			}
			case 134: // var_decl = MUTABLE.m var_name_type.v COLONEQ expression.init
			{
					final Symbol m = _symbols[offset + 1];
					final Symbol _symbol_v = _symbols[offset + 2];
					final LocalVarDecl v = (LocalVarDecl) _symbol_v.value;
					final Symbol _symbol_init = _symbols[offset + 4];
					final Expression init = (Expression) _symbol_init.value;
					 em.warning("mutable is ignored for " + v.getName(), v);
                                                         return register(m, init, v.copy(v.getType(), v.getName(), init, true));
			}
			case 135: // var_decl = var_name_type.v
			{
					final Symbol _symbol_v = _symbols[offset + 1];
					final LocalVarDecl v = (LocalVarDecl) _symbol_v.value;
					 return _symbol_v;
			}
			case 136: // var_decl = var_name_type.v EQ expression.init
			{
					final Symbol _symbol_v = _symbols[offset + 1];
					final LocalVarDecl v = (LocalVarDecl) _symbol_v.value;
					final Symbol _symbol_init = _symbols[offset + 3];
					final Expression init = (Expression) _symbol_init.value;
					 return register(v, init, v.copy(v.getType(), v.getName(), init, false));
			}
			case 137: // var_decl = var_name_type.v COLONEQ expression.init
			{
					final Symbol _symbol_v = _symbols[offset + 1];
					final LocalVarDecl v = (LocalVarDecl) _symbol_v.value;
					final Symbol _symbol_init = _symbols[offset + 3];
					final Expression init = (Expression) _symbol_init.value;
					 return register(v, init, v.copy(v.getType(), v.getName(), init, true));
			}
			case 138: // var_name_type = IDENTIFIER.id
			{
					final Symbol id = _symbols[offset + 1];
					 return register(id, id, new LocalVarDecl(null, (String)id.value, null, true));
			}
			case 139: // var_name_type = type.type IDENTIFIER.id
			{
					final Symbol _symbol_type = _symbols[offset + 1];
					final TypeExpr type = (TypeExpr) _symbol_type.value;
					final Symbol id = _symbols[offset + 2];
					 return register(id, id, new LocalVarDecl(type, (String)id.value, null, true));
			}
			case 140: // fun_decl = FUNCTION.start IDENTIFIER.id lambda_expr_body.lambda
			{
					final Symbol start = _symbols[offset + 1];
					final Symbol id = _symbols[offset + 2];
					final Symbol _symbol_lambda = _symbols[offset + 3];
					final ExprLambda lambda = (ExprLambda) _symbol_lambda.value;
					 register(start, lambda, lambda); return register(start, lambda, new LocalVarDecl(null, (String)id.value, lambda, false));
			}
			case 141: // proc_decl = PROCEDURE.start IDENTIFIER.id procedure_expr_body.body
			{
					final Symbol start = _symbols[offset + 1];
					final Symbol id = _symbols[offset + 2];
					final Symbol _symbol_body = _symbols[offset + 3];
					final ExprProc body = (ExprProc) _symbol_body.value;
					 register(start, body, body); return register(start, body, new LocalVarDecl(null, (String)id.value, body, false));
			}
			case 142: // port_decl = IDENTIFIER.id
			{
					final Symbol id = _symbols[offset + 1];
					 return register(id, id, new PortDecl((String)id.value, null));
			}
			case 143: // port_decl = type.type IDENTIFIER.id
			{
					final Symbol _symbol_type = _symbols[offset + 1];
					final TypeExpr type = (TypeExpr) _symbol_type.value;
					final Symbol id = _symbols[offset + 2];
					 return register(type, id, new PortDecl((String)id.value, type));
			}
			case 144: // port_decl = MULTI.m IDENTIFIER.id
			{
					final Symbol m = _symbols[offset + 1];
					final Symbol id = _symbols[offset + 2];
					 em.warning("multi is ignored for " + (String)id.value, null);
                                       return register(m, id, new PortDecl((String)id.value, null));
			}
			case 145: // port_decl = MULTI.m type.type IDENTIFIER.id
			{
					final Symbol m = _symbols[offset + 1];
					final Symbol _symbol_type = _symbols[offset + 2];
					final TypeExpr type = (TypeExpr) _symbol_type.value;
					final Symbol id = _symbols[offset + 3];
					 em.warning("multi is ignored for " + (String)id.value, null);
                                       return register(m, id, new PortDecl((String)id.value, type));
			}
			case 146: // port_decl_list_opt = 
			{
					 return new Symbol(null);
			}
			case 147: // port_decl_list_opt = port_decl_list.l
			{
					final Symbol _symbol_l = _symbols[offset + 1];
					final ImmutableList.Builder l = (ImmutableList.Builder) _symbol_l.value;
					 return new Symbol(l.build());
			}
			case 148: // port_decl_list = port_decl.port_decl
			{
					final Symbol _symbol_port_decl = _symbols[offset + 1];
					final PortDecl port_decl = (PortDecl) _symbol_port_decl.value;
					 return new Symbol(ImmutableList.builder().add(port_decl));
			}
			case 149: // port_decl_list = port_decl_list.l COMMA port_decl.d
			{
					final Symbol _symbol_l = _symbols[offset + 1];
					final ImmutableList.Builder l = (ImmutableList.Builder) _symbol_l.value;
					final Symbol _symbol_d = _symbols[offset + 3];
					final PortDecl d = (PortDecl) _symbol_d.value;
					 l.add(d); return _symbol_l;
			}
			case 150: // type_bound = LT type.type
			{
					final Symbol _symbol_type = _symbols[offset + 2];
					final TypeExpr type = (TypeExpr) _symbol_type.value;
					 return _symbol_type;
			}
			case 151: // type_bound_opt = 
			{
					 return new Symbol(null);
			}
			case 152: // type_bound_opt = type_bound.n
			{
					final Symbol _symbol_n = _symbols[offset + 1];
					final TypeExpr n = (TypeExpr) _symbol_n.value;
					 return _symbol_n;
			}
			case 153: // type_parameter = IDENTIFIER.id type_bound_opt.type_bound
			{
					final Symbol id = _symbols[offset + 1];
					final Symbol _symbol_type_bound = _symbols[offset + 2];
					final TypeExpr type_bound = (TypeExpr) _symbol_type_bound.value;
					 ParDeclType decl = new ParDeclType((String)id.value);
                                               Symbol result;
                                               if(type_bound == null){
                                                 result = register(id, id, decl);
                                               } else {
                                                 em.warning("type bound is ignored", type_bound);
                                                 result = register(id, type_bound, decl);
                                               }
                                               return result;
			}
			case 156: // type_parameter_block = LBRACK opt$type_parameter_list.l RBRACK
			{
					final Symbol _symbol_l = _symbols[offset + 2];
					final ImmutableList.Builder l = (ImmutableList.Builder) _symbol_l.value;
					 return new Symbol(l == null ? null : l.build());
			}
			case 157: // type_parameter_list = type_parameter.tp
			{
					final Symbol _symbol_tp = _symbols[offset + 1];
					final ParDeclType tp = (ParDeclType) _symbol_tp.value;
					 return new Symbol(ImmutableList.builder().add(tp));
			}
			case 158: // type_parameter_list = type_parameter_list.l COMMA type_parameter.tp
			{
					final Symbol _symbol_l = _symbols[offset + 1];
					final ImmutableList.Builder l = (ImmutableList.Builder) _symbol_l.value;
					final Symbol _symbol_tp = _symbols[offset + 3];
					final ParDeclType tp = (ParDeclType) _symbol_tp.value;
					 l.add(tp); return _symbol_l;
			}
			case 159: // type_list = type.t
			{
					final Symbol _symbol_t = _symbols[offset + 1];
					final TypeExpr t = (TypeExpr) _symbol_t.value;
					 return new Symbol(ImmutableList.builder().add(t));
			}
			case 160: // type_list = type_list.l COMMA type.t
			{
					final Symbol _symbol_l = _symbols[offset + 1];
					final ImmutableList.Builder l = (ImmutableList.Builder) _symbol_l.value;
					final Symbol _symbol_t = _symbols[offset + 3];
					final TypeExpr t = (TypeExpr) _symbol_t.value;
					 l.add(t); return _symbol_l;
			}
			case 161: // type = IDENTIFIER.id
			{
					final Symbol id = _symbols[offset + 1];
					 return register(id, id, new TypeExpr((String)id.value));
			}
			case 164: // type = IDENTIFIER.id LPAREN opt$type_attribute_list.attributes RPAREN.end
			{
					final Symbol id = _symbols[offset + 1];
					final Symbol _symbol_attributes = _symbols[offset + 3];
					final ArrayList attributes = (ArrayList) _symbol_attributes.value;
					final Symbol end = _symbols[offset + 4];
					 ImmutableList.Builder valueParameters = ImmutableList.builder();
                             ImmutableList.Builder typeParameters = ImmutableList.builder();
                             for(Map.Entry map : (ArrayList<Map.Entry>)attributes){
                               if(map.getValue() instanceof Expression){
                                 valueParameters.add(ImmutableEntry.of(map.getKey(), map.getValue()));
                               } else {
                                 typeParameters.add(ImmutableEntry.of(map.getKey(), map.getValue()));
                               }
                             }
                             return register(id, end, new TypeExpr((String)id.value, typeParameters.build(), valueParameters.build()));
			}
			case 167: // type = LBRACK.l opt$type_list.param EDGE type.result_type RBRACK.e
			{
					final Symbol l = _symbols[offset + 1];
					final Symbol _symbol_param = _symbols[offset + 2];
					final ImmutableList.Builder param = (ImmutableList.Builder) _symbol_param.value;
					final Symbol _symbol_result_type = _symbols[offset + 4];
					final TypeExpr result_type = (TypeExpr) _symbol_result_type.value;
					final Symbol e = _symbols[offset + 5];
					 warning("types involving -> is not supported", l, e); return new Symbol(null);
			}
			case 168: // type = LBRACK.l opt$type_list.param EDGE RBRACK.e
			{
					final Symbol l = _symbols[offset + 1];
					final Symbol _symbol_param = _symbols[offset + 2];
					final ImmutableList.Builder param = (ImmutableList.Builder) _symbol_param.value;
					final Symbol e = _symbols[offset + 4];
					 warning("types involving -> is not supported", l, e); return new Symbol(null);
			}
			case 169: // type_attribute_list = type_attribute.t
			{
					final Symbol _symbol_t = _symbols[offset + 1];
					final Map.Entry t = (Map.Entry) _symbol_t.value;
					 ArrayList l = new ArrayList(); l.add(t); return new Symbol(l);
			}
			case 170: // type_attribute_list = type_attribute_list.l COMMA type_attribute.t
			{
					final Symbol _symbol_l = _symbols[offset + 1];
					final ArrayList l = (ArrayList) _symbol_l.value;
					final Symbol _symbol_t = _symbols[offset + 3];
					final Map.Entry t = (Map.Entry) _symbol_t.value;
					 l.add(t); return _symbol_l;
			}
			case 171: // type_attribute = IDENTIFIER.id COLON type.type
			{
					final Symbol id = _symbols[offset + 1];
					final Symbol _symbol_type = _symbols[offset + 3];
					final TypeExpr type = (TypeExpr) _symbol_type.value;
					 return new Symbol(new AbstractMap.SimpleEntry((String)id.value, type));
			}
			case 172: // type_attribute = IDENTIFIER.id EQ expression.e
			{
					final Symbol id = _symbols[offset + 1];
					final Symbol _symbol_e = _symbols[offset + 3];
					final Expression e = (Expression) _symbol_e.value;
					 return new Symbol(new AbstractMap.SimpleEntry((String)id.value, e));
			}
			case 173: // edge_type = EDGE type.t
			{
					final Symbol _symbol_t = _symbols[offset + 2];
					final TypeExpr t = (TypeExpr) _symbol_t.value;
					 return _symbol_t;
			}
			case 178: // procedure_expr_body = LPAREN.start opt$formal_parameter_list.param RPAREN opt$decl_block.decl stmt_block_opt.body end_proc.end
			{
					final Symbol start = _symbols[offset + 1];
					final Symbol _symbol_param = _symbols[offset + 2];
					final ImmutableList.Builder param = (ImmutableList.Builder) _symbol_param.value;
					final Symbol _symbol_decl = _symbols[offset + 4];
					final ImmutableList decl = (ImmutableList) _symbol_decl.value;
					final Symbol _symbol_body = _symbols[offset + 5];
					final ImmutableList body = (ImmutableList) _symbol_body.value;
					final Symbol end = _symbols[offset + 6];
					  return register(start, end,
            new ExprProc(
              ImmutableList.<ParDeclType>empty(), 
              param==null ? ImmutableList.empty() : param.build(),
              new StmtBlock(null, decl, body)
            )
          );
			}
			case 179: // stmt_block_opt = 
			{
					 return new Symbol(ImmutableList.empty());
			}
			case 180: // stmt_block_opt = do_begin statement_list_opt.s
			{
					final Symbol _symbol_s = _symbols[offset + 2];
					final ImmutableList s = (ImmutableList) _symbol_s.value;
					 return _symbol_s;
			}
			case 181: // lambda_expr_body = LPAREN.s opt$formal_parameter_list.param RPAREN expression.body end_lambda.e
			{
					final Symbol s = _symbols[offset + 1];
					final Symbol _symbol_param = _symbols[offset + 2];
					final ImmutableList.Builder param = (ImmutableList.Builder) _symbol_param.value;
					final Symbol _symbol_body = _symbols[offset + 4];
					final Expression body = (Expression) _symbol_body.value;
					final Symbol e = _symbols[offset + 5];
					 return register(s, e, new ExprLambda(ImmutableList.<ParDeclType>empty(),
                                             param==null ? null : param.build(),
                                             body,
                                             null));
			}
			case 182: // lambda_expr_body = LPAREN.s opt$formal_parameter_list.param RPAREN opt$decl_block.decl COLON expression.body end_lambda.e
			{
					final Symbol s = _symbols[offset + 1];
					final Symbol _symbol_param = _symbols[offset + 2];
					final ImmutableList.Builder param = (ImmutableList.Builder) _symbol_param.value;
					final Symbol _symbol_decl = _symbols[offset + 4];
					final ImmutableList decl = (ImmutableList) _symbol_decl.value;
					final Symbol _symbol_body = _symbols[offset + 6];
					final Expression body = (Expression) _symbol_body.value;
					final Symbol e = _symbols[offset + 7];
					 return register(s, e, new ExprLambda(ImmutableList.<ParDeclType>empty(),
                                             param==null ? null : param.build(),
                                             new ExprLet(null, decl, body),
                                             null));
			}
			case 183: // lambda_expr_body = LPAREN.s opt$formal_parameter_list.param RPAREN edge_type.t opt$decl_block.decl COLON expression.body end_lambda.e
			{
					final Symbol s = _symbols[offset + 1];
					final Symbol _symbol_param = _symbols[offset + 2];
					final ImmutableList.Builder param = (ImmutableList.Builder) _symbol_param.value;
					final Symbol _symbol_t = _symbols[offset + 4];
					final TypeExpr t = (TypeExpr) _symbol_t.value;
					final Symbol _symbol_decl = _symbols[offset + 5];
					final ImmutableList decl = (ImmutableList) _symbol_decl.value;
					final Symbol _symbol_body = _symbols[offset + 7];
					final Expression body = (Expression) _symbol_body.value;
					final Symbol e = _symbols[offset + 8];
					 return register(s, e, new ExprLambda(ImmutableList.<ParDeclType>empty(),
                                             param==null ? null : param.build(),
                                             new ExprLet(null, decl, body),
                                             t));
			}
			case 184: // map_list = map_entry.m
			{
					final Symbol _symbol_m = _symbols[offset + 1];
					final Map.Entry m = (Map.Entry) _symbol_m.value;
					 return new Symbol(ImmutableList.builder().add(m));
			}
			case 185: // map_list = map_list.l COMMA map_entry.m
			{
					final Symbol _symbol_l = _symbols[offset + 1];
					final ImmutableList.Builder l = (ImmutableList.Builder) _symbol_l.value;
					final Symbol _symbol_m = _symbols[offset + 3];
					final Map.Entry m = (Map.Entry) _symbol_m.value;
					 l.add(m); return _symbol_l;
			}
			case 186: // map_entry = expression.e1 ARROW expression.e2
			{
					final Symbol _symbol_e1 = _symbols[offset + 1];
					final Expression e1 = (Expression) _symbol_e1.value;
					final Symbol _symbol_e2 = _symbols[offset + 3];
					final Expression e2 = (Expression) _symbol_e2.value;
					 return new Symbol(new ImmutableEntry(e1, e2));
			}
			case 187: // expression_list = expression.e
			{
					final Symbol _symbol_e = _symbols[offset + 1];
					final Expression e = (Expression) _symbol_e.value;
					 return new Symbol(ImmutableList.builder().add(e));
			}
			case 188: // expression_list = expression_list.l COMMA expression.e
			{
					final Symbol _symbol_l = _symbols[offset + 1];
					final ImmutableList.Builder l = (ImmutableList.Builder) _symbol_l.value;
					final Symbol _symbol_e = _symbols[offset + 3];
					final Expression e = (Expression) _symbol_e.value;
					 l.add(e); return _symbol_l;
			}
			case 189: // expression_list_opt = 
			{
					 return new Symbol(ImmutableList.empty());
			}
			case 190: // expression_list_opt = expression_list.n
			{
					final Symbol _symbol_n = _symbols[offset + 1];
					final ImmutableList.Builder n = (ImmutableList.Builder) _symbol_n.value;
					 return new Symbol(n.build());
			}
			case 191: // method_invocation = indexing_expression.function LPAREN expression_list_opt.args RPAREN.end
			{
					final Symbol _symbol_function = _symbols[offset + 1];
					final Expression function = (Expression) _symbol_function.value;
					final Symbol _symbol_args = _symbols[offset + 3];
					final ImmutableList args = (ImmutableList) _symbol_args.value;
					final Symbol end = _symbols[offset + 4];
					 return register(function, end, new ExprApplication(function, args));
			}
			case 192: // literal = INTEGER_LITERAL.txt
			{
					final Symbol txt = _symbols[offset + 1];
					 return register(txt, txt, new ExprLiteral(ExprLiteral.Kind.Integer, ((String)txt.value)));
			}
			case 193: // literal = LONG_LITERAL.txt
			{
					final Symbol txt = _symbols[offset + 1];
					 return register(txt, txt, new ExprLiteral(ExprLiteral.Kind.Integer, ((String)txt.value)));
			}
			case 194: // literal = FLOATING_POINT_LITERAL.txt
			{
					final Symbol txt = _symbols[offset + 1];
					 return register(txt, txt, new ExprLiteral(ExprLiteral.Kind.Real, ((String)txt.value)));
			}
			case 195: // literal = DOUBLE_LITERAL.txt
			{
					final Symbol txt = _symbols[offset + 1];
					 return register(txt, txt, new ExprLiteral(ExprLiteral.Kind.Real, ((String)txt.value)));
			}
			case 196: // literal = TRUE_LITERAL.txt
			{
					final Symbol txt = _symbols[offset + 1];
					 return register(txt, txt, new ExprLiteral(ExprLiteral.Kind.True, ((String)txt.value)));
			}
			case 197: // literal = FALSE_LITERAL.txt
			{
					final Symbol txt = _symbols[offset + 1];
					 return register(txt, txt, new ExprLiteral(ExprLiteral.Kind.False, ((String)txt.value)));
			}
			case 198: // literal = CHARACTER_LITERAL.txt
			{
					final Symbol txt = _symbols[offset + 1];
					 return register(txt, txt, new ExprLiteral(ExprLiteral.Kind.Char, ((String)txt.value)));
			}
			case 199: // literal = STRING_LITERAL.txt
			{
					final Symbol txt = _symbols[offset + 1];
					 return register(txt, txt, new ExprLiteral(ExprLiteral.Kind.String, ((String)txt.value)));
			}
			case 200: // literal = NULL_LITERAL.txt
			{
					final Symbol txt = _symbols[offset + 1];
					 return register(txt, txt, new ExprLiteral(ExprLiteral.Kind.Null, ((String)txt.value)));
			}
			case 201: // primary = literal.l
			{
					final Symbol _symbol_l = _symbols[offset + 1];
					final ExprLiteral l = (ExprLiteral) _symbol_l.value;
					 return _symbol_l;
			}
			case 202: // primary = LPAREN expression.e RPAREN
			{
					final Symbol _symbol_e = _symbols[offset + 2];
					final Expression e = (Expression) _symbol_e.value;
					 return new ParenthesSymbol(_symbol_e);
			}
			case 203: // primary = LPAREN.start expression.e DOUBLECOLON type.t RPAREN.end
			{
					final Symbol start = _symbols[offset + 1];
					final Symbol _symbol_e = _symbols[offset + 2];
					final Expression e = (Expression) _symbol_e.value;
					final Symbol _symbol_t = _symbols[offset + 4];
					final TypeExpr t = (TypeExpr) _symbol_t.value;
					final Symbol end = _symbols[offset + 5];
					 em.warning("Type assertion is not supported. Assertion is ignored at " + Symbol.getLine(start.getStart()) + ", " + Symbol.getColumn(start.getStart()), null); 
                                                               return register(start, end, new ExprLiteral(ExprLiteral.Kind.String, "type assertion"));
			}
			case 204: // simple_expression = primary.p
			{
					final Symbol _symbol_p = _symbols[offset + 1];
					final Expression p = (Expression) _symbol_p.value;
					 return _symbol_p;
			}
			case 205: // simple_expression = variable.v
			{
					final Symbol _symbol_v = _symbols[offset + 1];
					final Variable v = (Variable) _symbol_v.value;
					 return register(v, v, new ExprVariable(v));
			}
			case 206: // simple_expression = OLD.old variable.v
			{
					final Symbol old = _symbols[offset + 1];
					final Symbol _symbol_v = _symbols[offset + 2];
					final Variable v = (Variable) _symbol_v.value;
					 em.warning("old is not supported for " + v.getName() + ", at " + Symbol.getLine(old.getStart()) + ", " + Symbol.getColumn(old.getStart()), null); 
                                                                             return register(v, v, new ExprVariable(v));
			}
			case 207: // simple_expression = IF.s expression.c THEN expression.e1 ELSE expression.e2 END.end
			{
					final Symbol s = _symbols[offset + 1];
					final Symbol _symbol_c = _symbols[offset + 2];
					final Expression c = (Expression) _symbol_c.value;
					final Symbol _symbol_e1 = _symbols[offset + 4];
					final Expression e1 = (Expression) _symbol_e1.value;
					final Symbol _symbol_e2 = _symbols[offset + 6];
					final Expression e2 = (Expression) _symbol_e2.value;
					final Symbol end = _symbols[offset + 7];
					 return register(s, end, new ExprIf(c, e1, e2));
			}
			case 208: // simple_expression = LBRACE.s expression_list_opt.e RBRACE.end
			{
					final Symbol s = _symbols[offset + 1];
					final Symbol _symbol_e = _symbols[offset + 2];
					final ImmutableList e = (ImmutableList) _symbol_e.value;
					final Symbol end = _symbols[offset + 3];
					 return register(s, end, new ExprSet(e));
			}
			case 209: // simple_expression = LBRACE.s expression_list_opt.e COLON for_generator_list.l RBRACE.end
			{
					final Symbol s = _symbols[offset + 1];
					final Symbol _symbol_e = _symbols[offset + 2];
					final ImmutableList e = (ImmutableList) _symbol_e.value;
					final Symbol _symbol_l = _symbols[offset + 4];
					final ImmutableList.Builder l = (ImmutableList.Builder) _symbol_l.value;
					final Symbol end = _symbols[offset + 5];
					 return register(s, end, new ExprSet(e, l.build()));
			}
			case 210: // simple_expression = LBRACK.s expression_list_opt.e RBRACK.end
			{
					final Symbol s = _symbols[offset + 1];
					final Symbol _symbol_e = _symbols[offset + 2];
					final ImmutableList e = (ImmutableList) _symbol_e.value;
					final Symbol end = _symbols[offset + 3];
					 return register(s, end, new ExprList(e));
			}
			case 211: // simple_expression = LBRACK.s expression_list_opt.e COLON for_generator_list.l RBRACK.end
			{
					final Symbol s = _symbols[offset + 1];
					final Symbol _symbol_e = _symbols[offset + 2];
					final ImmutableList e = (ImmutableList) _symbol_e.value;
					final Symbol _symbol_l = _symbols[offset + 4];
					final ImmutableList.Builder l = (ImmutableList.Builder) _symbol_l.value;
					final Symbol end = _symbols[offset + 5];
					 return register(s, end, new ExprList(e, l.build()));
			}
			case 214: // simple_expression = MAP.s LBRACE opt$map_list.m RBRACE.end
			{
					final Symbol s = _symbols[offset + 1];
					final Symbol _symbol_m = _symbols[offset + 3];
					final ImmutableList.Builder m = (ImmutableList.Builder) _symbol_m.value;
					final Symbol end = _symbols[offset + 4];
					 return register(s, end, new ExprMap(m==null? null : m.build()));
			}
			case 215: // simple_expression = MAP.s LBRACE opt$map_list.m COLON for_generator_list.generators RBRACE.end
			{
					final Symbol s = _symbols[offset + 1];
					final Symbol _symbol_m = _symbols[offset + 3];
					final ImmutableList.Builder m = (ImmutableList.Builder) _symbol_m.value;
					final Symbol _symbol_generators = _symbols[offset + 5];
					final ImmutableList.Builder generators = (ImmutableList.Builder) _symbol_generators.value;
					final Symbol end = _symbols[offset + 6];
					 return register(s, end, new ExprMap(m==null? null : m.build(), generators.build()));
			}
			case 216: // simple_expression = LET.s decl_list.l COLON expression.e end_let.end
			{
					final Symbol s = _symbols[offset + 1];
					final Symbol _symbol_l = _symbols[offset + 2];
					final ImmutableList.Builder l = (ImmutableList.Builder) _symbol_l.value;
					final Symbol _symbol_e = _symbols[offset + 4];
					final Expression e = (Expression) _symbol_e.value;
					final Symbol end = _symbols[offset + 5];
					 return register(s, end, new ExprLet(null, l.build(), e));
			}
			case 217: // simple_expression = LAMBDA.start lambda_expr_body.lambda
			{
					final Symbol start = _symbols[offset + 1];
					final Symbol _symbol_lambda = _symbols[offset + 2];
					final ExprLambda lambda = (ExprLambda) _symbol_lambda.value;
					 return register(start, lambda, lambda);
			}
			case 218: // simple_expression = CONST.start LAMBDA lambda_expr_body.lambda
			{
					final Symbol start = _symbols[offset + 1];
					final Symbol _symbol_lambda = _symbols[offset + 3];
					final ExprLambda lambda = (ExprLambda) _symbol_lambda.value;
					 register(start, lambda, lambda); 
                                                                             em.warning("const is ignored in lambda expression", lambda); 
                                                                             return _symbol_lambda;
			}
			case 219: // simple_expression = PROC.start procedure_expr_body.p
			{
					final Symbol start = _symbols[offset + 1];
					final Symbol _symbol_p = _symbols[offset + 2];
					final ExprProc p = (ExprProc) _symbol_p.value;
					 return register(start, p, p);
			}
			case 220: // indexing_expression = simple_expression.e
			{
					final Symbol _symbol_e = _symbols[offset + 1];
					final Expression e = (Expression) _symbol_e.value;
					 return _symbol_e;
			}
			case 221: // indexing_expression = indexer.i
			{
					final Symbol i = _symbols[offset + 1];
					 return i;
			}
			case 222: // indexing_expression = indexing_expression.p DOT field.f
			{
					final Symbol _symbol_p = _symbols[offset + 1];
					final Expression p = (Expression) _symbol_p.value;
					final Symbol _symbol_f = _symbols[offset + 3];
					final Field f = (Field) _symbol_f.value;
					 return register(p, f, new ExprField(p, f));
			}
			case 223: // indexing_expression = method_invocation.m
			{
					final Symbol _symbol_m = _symbols[offset + 1];
					final ExprApplication m = (ExprApplication) _symbol_m.value;
					 return _symbol_m;
			}
			case 224: // indexer = indexer_start.s expression.i RBRACK.e
			{
					final Symbol _symbol_s = _symbols[offset + 1];
					final Expression s = (Expression) _symbol_s.value;
					final Symbol _symbol_i = _symbols[offset + 2];
					final Expression i = (Expression) _symbol_i.value;
					final Symbol e = _symbols[offset + 3];
					 return register(s,e, new ExprIndexer(s, i));
			}
			case 225: // indexer_start = indexing_expression.e LBRACK
			{
					final Symbol _symbol_e = _symbols[offset + 1];
					final Expression e = (Expression) _symbol_e.value;
					 return _symbol_e;
			}
			case 226: // indexer_start = indexer_start.s expression.i COMMA.e
			{
					final Symbol _symbol_s = _symbols[offset + 1];
					final Expression s = (Expression) _symbol_s.value;
					final Symbol _symbol_i = _symbols[offset + 2];
					final Expression i = (Expression) _symbol_i.value;
					final Symbol e = _symbols[offset + 3];
					 return register(s, e, new ExprIndexer(s, i));
			}
			case 227: // unary_expression = indexing_expression.e
			{
					final Symbol _symbol_e = _symbols[offset + 1];
					final Expression e = (Expression) _symbol_e.value;
					 return _symbol_e;
			}
			case 228: // unary_expression = operator.operator unary_expression.expr
			{
					final Symbol _symbol_operator = _symbols[offset + 1];
					final String operator = (String) _symbol_operator.value;
					final Symbol _symbol_expr = _symbols[offset + 2];
					final Expression expr = (Expression) _symbol_expr.value;
					 return register(_symbol_operator, expr, new ExprUnaryOp(operator, expr));
			}
			case 229: // expression = unary_expression.e
			{
					final Symbol _symbol_e = _symbols[offset + 1];
					final Expression e = (Expression) _symbol_e.value;
					 return _symbol_e;
			}
			case 230: // expression = expression.arg1 operator.operator unary_expression.arg2
			{
					final Symbol _symbol_arg1 = _symbols[offset + 1];
					final Expression arg1 = (Expression) _symbol_arg1.value;
					final Symbol _symbol_operator = _symbols[offset + 2];
					final String operator = (String) _symbol_operator.value;
					final Symbol _symbol_arg2 = _symbols[offset + 3];
					final Expression arg2 = (Expression) _symbol_arg2.value;
					 ImmutableList<String> operators;
                                                               ImmutableList<Expression> operands;
                                                               boolean arg1IsPar = _symbol_arg1 instanceof ParenthesSymbol;
                                                               ExprBinaryOp expr = null;
                                                               if((arg1 instanceof ExprBinaryOp) && !(arg1IsPar)){
                                                                 expr = (ExprBinaryOp)arg1;
                                                                 operators = ImmutableList.<String>builder().addAll(expr.getOperations()).add(operator).build();
                                                                 operands = ImmutableList.<Expression>builder().addAll(expr.getOperands()).add(arg2).build();
                                                               } else {
                                                                 operators = ImmutableList.of(operator);
                                                                 operands = ImmutableList.of(arg1, arg2);
                                                               }
                                                               return register(operands.get(0), arg2, new ExprBinaryOp(expr, operators, operands));  // reuse the Identifier from the previous expr.
			}
			case 231: // operator = OPERATOR.op
			{
					final Symbol op = _symbols[offset + 1];
					 return op;
			}
			case 232: // operator = EQ.op
			{
					final Symbol op = _symbols[offset + 1];
					 return op;
			}
			case 233: // operator = IN.op
			{
					final Symbol op = _symbols[offset + 1];
					 return op;
			}
			case 234: // operator = GT.op
			{
					final Symbol op = _symbols[offset + 1];
					 return op;
			}
			case 235: // operator = LT.op
			{
					final Symbol op = _symbols[offset + 1];
					 return op;
			}
			case 236: // operator = MULT.op
			{
					final Symbol op = _symbols[offset + 1];
					 return op;
			}
			case 237: // operator = BAR.op
			{
					final Symbol op = _symbols[offset + 1];
					 return op;
			}
			case 238: // formal_parameter = IDENTIFIER.id
			{
					final Symbol id = _symbols[offset + 1];
					 return register(id, id, new ParDeclValue((String)id.value, null));
			}
			case 239: // formal_parameter = type.t IDENTIFIER.id
			{
					final Symbol _symbol_t = _symbols[offset + 1];
					final TypeExpr t = (TypeExpr) _symbol_t.value;
					final Symbol id = _symbols[offset + 2];
					 return register(t, id, new ParDeclValue((String)id.value, t));
			}
			case 240: // formal_parameter_list = formal_parameter.p
			{
					final Symbol _symbol_p = _symbols[offset + 1];
					final ParDeclValue p = (ParDeclValue) _symbol_p.value;
					 return new Symbol(ImmutableList.builder().add(p));
			}
			case 241: // formal_parameter_list = formal_parameter_list.l COMMA formal_parameter.p
			{
					final Symbol _symbol_l = _symbols[offset + 1];
					final ImmutableList.Builder l = (ImmutableList.Builder) _symbol_l.value;
					final Symbol _symbol_p = _symbols[offset + 3];
					final ParDeclValue p = (ParDeclValue) _symbol_p.value;
					 l.add(p);  return _symbol_l;
			}
			case 242: // statement = expression.lhs COLONEQ expression.value SEMICOLON.end
			{
					final Symbol _symbol_lhs = _symbols[offset + 1];
					final Expression lhs = (Expression) _symbol_lhs.value;
					final Symbol _symbol_value = _symbols[offset + 3];
					final Expression value = (Expression) _symbol_value.value;
					final Symbol end = _symbols[offset + 4];
					 LValue lvalue = expressionToLValue(lhs);
                                                             if (lvalue != null) return register(lhs, end, new StmtAssignment(lvalue, value));
                                                             em.error("Illegal left hand sign of assignment.", lhs);
                                                             return register(lhs, end, new StmtAssignment(new LValueVariable(Variable.variable("$illegal")), value));
			}
			case 243: // statement = method_invocation.m SEMICOLON.end
			{
					final Symbol _symbol_m = _symbols[offset + 1];
					final ExprApplication m = (ExprApplication) _symbol_m.value;
					final Symbol end = _symbols[offset + 2];
					 return register(m, end, new StmtCall(m.getFunction(), m.getArgs()));
			}
			case 244: // statement = BEGIN.start statement_list_opt.s END.end
			{
					final Symbol start = _symbols[offset + 1];
					final Symbol _symbol_s = _symbols[offset + 2];
					final ImmutableList s = (ImmutableList) _symbol_s.value;
					final Symbol end = _symbols[offset + 3];
					 return register(start, end, new StmtBlock(null, null, s));
			}
			case 245: // statement = BEGIN.start VAR decl_list.d DO statement_list_opt.s END.end
			{
					final Symbol start = _symbols[offset + 1];
					final Symbol _symbol_d = _symbols[offset + 3];
					final ImmutableList.Builder d = (ImmutableList.Builder) _symbol_d.value;
					final Symbol _symbol_s = _symbols[offset + 5];
					final ImmutableList s = (ImmutableList) _symbol_s.value;
					final Symbol end = _symbols[offset + 6];
					 return register(start, end, new StmtBlock(null, d.build(), s));
			}
			case 246: // statement = IF.start expression.e THEN statement_list_opt.s end_if.end
			{
					final Symbol start = _symbols[offset + 1];
					final Symbol _symbol_e = _symbols[offset + 2];
					final Expression e = (Expression) _symbol_e.value;
					final Symbol _symbol_s = _symbols[offset + 4];
					final ImmutableList s = (ImmutableList) _symbol_s.value;
					final Symbol end = _symbols[offset + 5];
					 return register(start, end, new StmtIf(e, new StmtBlock(null, null, s), null));
			}
			case 247: // statement = IF.start expression.e THEN statement_list_opt.s1 ELSE statement_list_opt.s2 end_if.end
			{
					final Symbol start = _symbols[offset + 1];
					final Symbol _symbol_e = _symbols[offset + 2];
					final Expression e = (Expression) _symbol_e.value;
					final Symbol _symbol_s1 = _symbols[offset + 4];
					final ImmutableList s1 = (ImmutableList) _symbol_s1.value;
					final Symbol _symbol_s2 = _symbols[offset + 6];
					final ImmutableList s2 = (ImmutableList) _symbol_s2.value;
					final Symbol end = _symbols[offset + 7];
					 return register(start, end, new StmtIf(e, 
                                                                                                                                     new StmtBlock(null, null, s1),
                                                                                                                                     new StmtBlock(null, null, s2)));
			}
			case 248: // statement = WHILE.start expression.e decl_block_opt.d DO statement_list_opt.s end_while.end
			{
					final Symbol start = _symbols[offset + 1];
					final Symbol _symbol_e = _symbols[offset + 2];
					final Expression e = (Expression) _symbol_e.value;
					final Symbol _symbol_d = _symbols[offset + 3];
					final ImmutableList d = (ImmutableList) _symbol_d.value;
					final Symbol _symbol_s = _symbols[offset + 5];
					final ImmutableList s = (ImmutableList) _symbol_s.value;
					final Symbol end = _symbols[offset + 6];
					 return register(start, end, new StmtWhile(e, new StmtBlock(null, d, s)));
			}
			case 249: // statement = choose_generator_list.l decl_block_opt.do_v DO.c statement_list_opt.do_s end_choose.end
			{
					final Symbol _symbol_l = _symbols[offset + 1];
					final ImmutableList.Builder l = (ImmutableList.Builder) _symbol_l.value;
					final Symbol _symbol_do_v = _symbols[offset + 2];
					final ImmutableList do_v = (ImmutableList) _symbol_do_v.value;
					final Symbol c = _symbols[offset + 3];
					final Symbol _symbol_do_s = _symbols[offset + 4];
					final ImmutableList do_s = (ImmutableList) _symbol_do_s.value;
					final Symbol end = _symbols[offset + 5];
					 Statement stmt = new StmtBlock(null, null, ImmutableList.<Statement>empty());
       Symbol result = register((GeneratorFilter)l.build().get(0), end, stmt);
       em.error("choose statement is not supported", stmt);
       return result;
			}
			case 250: // statement = choose_generator_list.l decl_block_opt.do_v DO.c statement_list_opt.do_s ELSE statement_list_opt.else_s end_choose.end
			{
					final Symbol _symbol_l = _symbols[offset + 1];
					final ImmutableList.Builder l = (ImmutableList.Builder) _symbol_l.value;
					final Symbol _symbol_do_v = _symbols[offset + 2];
					final ImmutableList do_v = (ImmutableList) _symbol_do_v.value;
					final Symbol c = _symbols[offset + 3];
					final Symbol _symbol_do_s = _symbols[offset + 4];
					final ImmutableList do_s = (ImmutableList) _symbol_do_s.value;
					final Symbol _symbol_else_s = _symbols[offset + 6];
					final ImmutableList else_s = (ImmutableList) _symbol_else_s.value;
					final Symbol end = _symbols[offset + 7];
					 Statement stmt = new StmtBlock(null, null, ImmutableList.<Statement>empty());
       Symbol result = register((GeneratorFilter)l.build().get(0), end, stmt);
       em.error("choose statement is not supported", stmt);
       return result;
			}
			case 251: // statement = choose_generator_list.l decl_block_opt.do_v DO.c statement_list_opt.do_s ELSE decl_block_opt.else_v DO statement_list_opt.else_s end_choose.end
			{
					final Symbol _symbol_l = _symbols[offset + 1];
					final ImmutableList.Builder l = (ImmutableList.Builder) _symbol_l.value;
					final Symbol _symbol_do_v = _symbols[offset + 2];
					final ImmutableList do_v = (ImmutableList) _symbol_do_v.value;
					final Symbol c = _symbols[offset + 3];
					final Symbol _symbol_do_s = _symbols[offset + 4];
					final ImmutableList do_s = (ImmutableList) _symbol_do_s.value;
					final Symbol _symbol_else_v = _symbols[offset + 6];
					final ImmutableList else_v = (ImmutableList) _symbol_else_v.value;
					final Symbol _symbol_else_s = _symbols[offset + 8];
					final ImmutableList else_s = (ImmutableList) _symbol_else_s.value;
					final Symbol end = _symbols[offset + 9];
					 Statement stmt = new StmtBlock(null, null, ImmutableList.<Statement>empty());
       Symbol result = register((GeneratorFilter)l.build().get(0), end, stmt);
       em.error("choose statement is not supported", stmt);
       return result;
			}
			case 252: // statement = for_generator_list.g DO.doSymbol statement_list_opt.s end_foreach.end
			{
					final Symbol _symbol_g = _symbols[offset + 1];
					final ImmutableList.Builder g = (ImmutableList.Builder) _symbol_g.value;
					final Symbol doSymbol = _symbols[offset + 2];
					final Symbol _symbol_s = _symbols[offset + 3];
					final ImmutableList s = (ImmutableList) _symbol_s.value;
					final Symbol end = _symbols[offset + 4];
					 return register(doSymbol, end, new StmtForeach(g.build(), new StmtBlock(null, null, s)));
			}
			case 253: // statement = for_generator_list.g decl_block.d DO.doSymbol statement_list_opt.s end_foreach.end
			{
					final Symbol _symbol_g = _symbols[offset + 1];
					final ImmutableList.Builder g = (ImmutableList.Builder) _symbol_g.value;
					final Symbol _symbol_d = _symbols[offset + 2];
					final ImmutableList d = (ImmutableList) _symbol_d.value;
					final Symbol doSymbol = _symbols[offset + 3];
					final Symbol _symbol_s = _symbols[offset + 4];
					final ImmutableList s = (ImmutableList) _symbol_s.value;
					final Symbol end = _symbols[offset + 5];
					 return register(doSymbol, end, new StmtForeach(g.build(), new StmtBlock(null, d, s)));
			}
			case 254: // choose_generator_list = CHOOSE.start generator_variable_list.vars IN expression.e
			{
					final Symbol start = _symbols[offset + 1];
					final Symbol _symbol_vars = _symbols[offset + 2];
					final ImmutableList.Builder vars = (ImmutableList.Builder) _symbol_vars.value;
					final Symbol _symbol_e = _symbols[offset + 4];
					final Expression e = (Expression) _symbol_e.value;
					 return makeGeneratorFilter(start, null, vars.build(), e, null, null);
			}
			case 255: // choose_generator_list = CHOOSE.start type.t generator_variable_list.vars IN expression.e
			{
					final Symbol start = _symbols[offset + 1];
					final Symbol _symbol_t = _symbols[offset + 2];
					final TypeExpr t = (TypeExpr) _symbol_t.value;
					final Symbol _symbol_vars = _symbols[offset + 3];
					final ImmutableList.Builder vars = (ImmutableList.Builder) _symbol_vars.value;
					final Symbol _symbol_e = _symbols[offset + 5];
					final Expression e = (Expression) _symbol_e.value;
					 return makeGeneratorFilter(start, t, vars.build(), e, null, null);
			}
			case 256: // choose_generator_list = CHOOSE.start generator_variable_list.vars IN expression.e COMMA expression_list.filters
			{
					final Symbol start = _symbols[offset + 1];
					final Symbol _symbol_vars = _symbols[offset + 2];
					final ImmutableList.Builder vars = (ImmutableList.Builder) _symbol_vars.value;
					final Symbol _symbol_e = _symbols[offset + 4];
					final Expression e = (Expression) _symbol_e.value;
					final Symbol _symbol_filters = _symbols[offset + 6];
					final ImmutableList.Builder filters = (ImmutableList.Builder) _symbol_filters.value;
					 return makeGeneratorFilter(start, null, vars.build(), e, filters.build(), null);
			}
			case 257: // choose_generator_list = CHOOSE.start type.t generator_variable_list.vars IN expression.e COMMA expression_list.filters
			{
					final Symbol start = _symbols[offset + 1];
					final Symbol _symbol_t = _symbols[offset + 2];
					final TypeExpr t = (TypeExpr) _symbol_t.value;
					final Symbol _symbol_vars = _symbols[offset + 3];
					final ImmutableList.Builder vars = (ImmutableList.Builder) _symbol_vars.value;
					final Symbol _symbol_e = _symbols[offset + 5];
					final Expression e = (Expression) _symbol_e.value;
					final Symbol _symbol_filters = _symbols[offset + 7];
					final ImmutableList.Builder filters = (ImmutableList.Builder) _symbol_filters.value;
					 return makeGeneratorFilter(start, t, vars.build(), e, filters.build(), null);
			}
			case 258: // choose_generator_list = CHOOSE.start generator_variable_list.vars IN expression.e COMMA choose_generator_list.l
			{
					final Symbol start = _symbols[offset + 1];
					final Symbol _symbol_vars = _symbols[offset + 2];
					final ImmutableList.Builder vars = (ImmutableList.Builder) _symbol_vars.value;
					final Symbol _symbol_e = _symbols[offset + 4];
					final Expression e = (Expression) _symbol_e.value;
					final Symbol _symbol_l = _symbols[offset + 6];
					final ImmutableList.Builder l = (ImmutableList.Builder) _symbol_l.value;
					 return makeGeneratorFilter(start, null, vars.build(), e, null, l.build());
			}
			case 259: // choose_generator_list = CHOOSE.start type.t generator_variable_list.vars IN expression.e COMMA choose_generator_list.l
			{
					final Symbol start = _symbols[offset + 1];
					final Symbol _symbol_t = _symbols[offset + 2];
					final TypeExpr t = (TypeExpr) _symbol_t.value;
					final Symbol _symbol_vars = _symbols[offset + 3];
					final ImmutableList.Builder vars = (ImmutableList.Builder) _symbol_vars.value;
					final Symbol _symbol_e = _symbols[offset + 5];
					final Expression e = (Expression) _symbol_e.value;
					final Symbol _symbol_l = _symbols[offset + 7];
					final ImmutableList.Builder l = (ImmutableList.Builder) _symbol_l.value;
					 return makeGeneratorFilter(start, t, vars.build(), e, null, l.build());
			}
			case 260: // choose_generator_list = CHOOSE.start generator_variable_list.vars IN expression.e COMMA expression_list.filters COMMA choose_generator_list.l
			{
					final Symbol start = _symbols[offset + 1];
					final Symbol _symbol_vars = _symbols[offset + 2];
					final ImmutableList.Builder vars = (ImmutableList.Builder) _symbol_vars.value;
					final Symbol _symbol_e = _symbols[offset + 4];
					final Expression e = (Expression) _symbol_e.value;
					final Symbol _symbol_filters = _symbols[offset + 6];
					final ImmutableList.Builder filters = (ImmutableList.Builder) _symbol_filters.value;
					final Symbol _symbol_l = _symbols[offset + 8];
					final ImmutableList.Builder l = (ImmutableList.Builder) _symbol_l.value;
					 return makeGeneratorFilter(start, null, vars.build(), e, filters.build(), l.build());
			}
			case 261: // choose_generator_list = CHOOSE.start type.t generator_variable_list.vars IN expression.e COMMA expression_list.filters COMMA choose_generator_list.l
			{
					final Symbol start = _symbols[offset + 1];
					final Symbol _symbol_t = _symbols[offset + 2];
					final TypeExpr t = (TypeExpr) _symbol_t.value;
					final Symbol _symbol_vars = _symbols[offset + 3];
					final ImmutableList.Builder vars = (ImmutableList.Builder) _symbol_vars.value;
					final Symbol _symbol_e = _symbols[offset + 5];
					final Expression e = (Expression) _symbol_e.value;
					final Symbol _symbol_filters = _symbols[offset + 7];
					final ImmutableList.Builder filters = (ImmutableList.Builder) _symbol_filters.value;
					final Symbol _symbol_l = _symbols[offset + 9];
					final ImmutableList.Builder l = (ImmutableList.Builder) _symbol_l.value;
					 return makeGeneratorFilter(start, t, vars.build(), e, filters.build(), l.build());
			}
			case 262: // for_generator_list = for_foreach.start generator_variable_list.vars IN expression.e
			{
					final Symbol start = _symbols[offset + 1];
					final Symbol _symbol_vars = _symbols[offset + 2];
					final ImmutableList.Builder vars = (ImmutableList.Builder) _symbol_vars.value;
					final Symbol _symbol_e = _symbols[offset + 4];
					final Expression e = (Expression) _symbol_e.value;
					 return makeGeneratorFilter(start, null, vars.build(), e, null, null);
			}
			case 263: // for_generator_list = for_foreach.start type.t generator_variable_list.vars IN expression.e
			{
					final Symbol start = _symbols[offset + 1];
					final Symbol _symbol_t = _symbols[offset + 2];
					final TypeExpr t = (TypeExpr) _symbol_t.value;
					final Symbol _symbol_vars = _symbols[offset + 3];
					final ImmutableList.Builder vars = (ImmutableList.Builder) _symbol_vars.value;
					final Symbol _symbol_e = _symbols[offset + 5];
					final Expression e = (Expression) _symbol_e.value;
					 return makeGeneratorFilter(start, t, vars.build(), e, null, null);
			}
			case 264: // for_generator_list = for_foreach.start generator_variable_list.vars IN expression.e COMMA expression_list.filters
			{
					final Symbol start = _symbols[offset + 1];
					final Symbol _symbol_vars = _symbols[offset + 2];
					final ImmutableList.Builder vars = (ImmutableList.Builder) _symbol_vars.value;
					final Symbol _symbol_e = _symbols[offset + 4];
					final Expression e = (Expression) _symbol_e.value;
					final Symbol _symbol_filters = _symbols[offset + 6];
					final ImmutableList.Builder filters = (ImmutableList.Builder) _symbol_filters.value;
					 return makeGeneratorFilter(start, null, vars.build(), e, filters.build(), null);
			}
			case 265: // for_generator_list = for_foreach.start type.t generator_variable_list.vars IN expression.e COMMA expression_list.filters
			{
					final Symbol start = _symbols[offset + 1];
					final Symbol _symbol_t = _symbols[offset + 2];
					final TypeExpr t = (TypeExpr) _symbol_t.value;
					final Symbol _symbol_vars = _symbols[offset + 3];
					final ImmutableList.Builder vars = (ImmutableList.Builder) _symbol_vars.value;
					final Symbol _symbol_e = _symbols[offset + 5];
					final Expression e = (Expression) _symbol_e.value;
					final Symbol _symbol_filters = _symbols[offset + 7];
					final ImmutableList.Builder filters = (ImmutableList.Builder) _symbol_filters.value;
					 return makeGeneratorFilter(start, t, vars.build(), e, filters.build(), null);
			}
			case 266: // for_generator_list = for_foreach.start generator_variable_list.vars IN expression.e COMMA for_generator_list.l
			{
					final Symbol start = _symbols[offset + 1];
					final Symbol _symbol_vars = _symbols[offset + 2];
					final ImmutableList.Builder vars = (ImmutableList.Builder) _symbol_vars.value;
					final Symbol _symbol_e = _symbols[offset + 4];
					final Expression e = (Expression) _symbol_e.value;
					final Symbol _symbol_l = _symbols[offset + 6];
					final ImmutableList.Builder l = (ImmutableList.Builder) _symbol_l.value;
					 return makeGeneratorFilter(start, null, vars.build(), e, null, l.build());
			}
			case 267: // for_generator_list = for_foreach.start type.t generator_variable_list.vars IN expression.e COMMA for_generator_list.l
			{
					final Symbol start = _symbols[offset + 1];
					final Symbol _symbol_t = _symbols[offset + 2];
					final TypeExpr t = (TypeExpr) _symbol_t.value;
					final Symbol _symbol_vars = _symbols[offset + 3];
					final ImmutableList.Builder vars = (ImmutableList.Builder) _symbol_vars.value;
					final Symbol _symbol_e = _symbols[offset + 5];
					final Expression e = (Expression) _symbol_e.value;
					final Symbol _symbol_l = _symbols[offset + 7];
					final ImmutableList.Builder l = (ImmutableList.Builder) _symbol_l.value;
					 return makeGeneratorFilter(start, t, vars.build(), e, null, l.build());
			}
			case 268: // for_generator_list = for_foreach.start generator_variable_list.vars IN expression.e COMMA expression_list.filters COMMA for_generator_list.l
			{
					final Symbol start = _symbols[offset + 1];
					final Symbol _symbol_vars = _symbols[offset + 2];
					final ImmutableList.Builder vars = (ImmutableList.Builder) _symbol_vars.value;
					final Symbol _symbol_e = _symbols[offset + 4];
					final Expression e = (Expression) _symbol_e.value;
					final Symbol _symbol_filters = _symbols[offset + 6];
					final ImmutableList.Builder filters = (ImmutableList.Builder) _symbol_filters.value;
					final Symbol _symbol_l = _symbols[offset + 8];
					final ImmutableList.Builder l = (ImmutableList.Builder) _symbol_l.value;
					 return makeGeneratorFilter(start, null, vars.build(), e, filters.build(), l.build());
			}
			case 269: // for_generator_list = for_foreach.start type.t generator_variable_list.vars IN expression.e COMMA expression_list.filters COMMA for_generator_list.l
			{
					final Symbol start = _symbols[offset + 1];
					final Symbol _symbol_t = _symbols[offset + 2];
					final TypeExpr t = (TypeExpr) _symbol_t.value;
					final Symbol _symbol_vars = _symbols[offset + 3];
					final ImmutableList.Builder vars = (ImmutableList.Builder) _symbol_vars.value;
					final Symbol _symbol_e = _symbols[offset + 5];
					final Expression e = (Expression) _symbol_e.value;
					final Symbol _symbol_filters = _symbols[offset + 7];
					final ImmutableList.Builder filters = (ImmutableList.Builder) _symbol_filters.value;
					final Symbol _symbol_l = _symbols[offset + 9];
					final ImmutableList.Builder l = (ImmutableList.Builder) _symbol_l.value;
					 return makeGeneratorFilter(start, t, vars.build(), e, filters.build(), l.build());
			}
			case 270: // generator_variable_list = IDENTIFIER.id
			{
					final Symbol id = _symbols[offset + 1];
					 return new Symbol(ImmutableList.builder().add(id));
			}
			case 271: // generator_variable_list = generator_variable_list.l COMMA IDENTIFIER.id
			{
					final Symbol _symbol_l = _symbols[offset + 1];
					final ImmutableList.Builder l = (ImmutableList.Builder) _symbol_l.value;
					final Symbol id = _symbols[offset + 3];
					 l.add(id); return _symbol_l;
			}
			case 290: // statement_list_opt = 
			{
					 return new Symbol(ImmutableList.empty());
			}
			case 291: // statement_list_opt = statement_list.l
			{
					final Symbol _symbol_l = _symbols[offset + 1];
					final ImmutableList.Builder l = (ImmutableList.Builder) _symbol_l.value;
					 return new Symbol(l.build());
			}
			case 292: // statement_list = statement.n
			{
					final Symbol _symbol_n = _symbols[offset + 1];
					final Statement n = (Statement) _symbol_n.value;
					 return new Symbol(ImmutableList.builder().add(n));
			}
			case 293: // statement_list = statement_list.l statement.n
			{
					final Symbol _symbol_l = _symbols[offset + 1];
					final ImmutableList.Builder l = (ImmutableList.Builder) _symbol_l.value;
					final Symbol _symbol_n = _symbols[offset + 2];
					final Statement n = (Statement) _symbol_n.value;
					 l.add(n); return _symbol_l;
			}
			case 0: // opt$SEMICOLON = 
			case 10: // opt$action_tag = 
			case 12: // opt$action_output_expression_list = 
			case 16: // opt$lst$action_head = 
			case 29: // opt$port_name_colon = 
			case 31: // opt$token_name_list = 
			case 33: // opt$repeat = 
			case 35: // opt$channel_selector = 
			case 42: // opt$ATSTAR = 
			case 49: // opt$expression_list = 
			case 53: // opt$import_list = 
			case 55: // opt$type_parameter_block = 
			case 57: // opt$actor_parameter_list = 
			case 59: // opt$time = 
			case 63: // opt$lst$actor_body = 
			case 78: // opt$FSM = 
			case 82: // opt$lst$fsm_state_transitions = 
			case 88: // opt$lst$fsm_state_target = 
			case 115: // opt$actor_parameter_init_expression = 
			case 154: // opt$type_parameter_list = 
			case 162: // opt$type_attribute_list = 
			case 165: // opt$type_list = 
			case 174: // opt$formal_parameter_list = 
			case 176: // opt$decl_block = 
			case 212: // opt$map_list = 
			{
				return new Symbol(null);
			}
			case 1: // opt$SEMICOLON = SEMICOLON
			case 11: // opt$action_tag = action_tag
			case 13: // opt$action_output_expression_list = action_output_expression_list
			case 17: // opt$lst$action_head = lst$action_head
			case 30: // opt$port_name_colon = port_name_colon
			case 32: // opt$token_name_list = token_name_list
			case 34: // opt$repeat = repeat
			case 36: // opt$channel_selector = channel_selector
			case 43: // opt$ATSTAR = ATSTAR
			case 50: // opt$expression_list = expression_list
			case 54: // opt$import_list = import_list
			case 56: // opt$type_parameter_block = type_parameter_block
			case 58: // opt$actor_parameter_list = actor_parameter_list
			case 60: // opt$time = time
			case 64: // opt$lst$actor_body = lst$actor_body
			case 79: // opt$FSM = FSM
			case 83: // opt$lst$fsm_state_transitions = lst$fsm_state_transitions
			case 89: // opt$lst$fsm_state_target = lst$fsm_state_target
			case 105: // end_action = END
			case 106: // end_action = ENDACTION
			case 107: // end_actor = END
			case 108: // end_actor = ENDACTOR
			case 109: // end_invariant = END
			case 110: // end_invariant = ENDINVARIANT
			case 111: // end_schedule = END
			case 112: // end_schedule = ENDSCHEDULE
			case 116: // opt$actor_parameter_init_expression = actor_parameter_init_expression
			case 155: // opt$type_parameter_list = type_parameter_list
			case 163: // opt$type_attribute_list = type_attribute_list
			case 166: // opt$type_list = type_list
			case 175: // opt$formal_parameter_list = formal_parameter_list
			case 177: // opt$decl_block = decl_block
			case 213: // opt$map_list = map_list
			case 272: // for_foreach = FOREACH.FOREACH
			case 273: // for_foreach = FOR.FOR
			case 274: // do_begin = BEGIN.BEGIN
			case 275: // do_begin = DO.DO
			case 276: // end_choose = END.END
			case 277: // end_choose = ENDCHOOSE.ENDCHOOSE
			case 278: // end_foreach = END.END
			case 279: // end_foreach = ENDFOREACH.ENDFOREACH
			case 280: // end_if = END.END
			case 281: // end_if = ENDIF.ENDIF
			case 282: // end_lambda = END.END
			case 283: // end_lambda = ENDLAMBDA.ENDLAMBDA
			case 284: // end_let = END.END
			case 285: // end_let = ENDLET.ENDLET
			case 286: // end_proc = END.END
			case 287: // end_proc = ENDPROC.ENDPROC
			case 288: // end_while = END.END
			case 289: // end_while = ENDWHILE.ENDWHILE
			{
				return _symbols[offset + 1];
			}
			default:
				throw new IllegalArgumentException("unknown production #" + rule_num);
		}
	}
}
