/* 
 *  @author Per Andersson<Per.Andersson@cs.lth.se>, Lund University
 *  To parse a NL file use one of the methods:
 *  - public se.lth.cs.tycho.ir.entity.cal.NetworkDefinition parse(String path, String fileName)
 *  - public se.lth.cs.tycho.ir.entity.cal.NetworkDefinition parse(File file)
 *
 *  After parsing check for errors in the attribute parseProblems.
 *
 *  The parser is created using jflex and beaver.
 */
 
package se.lth.cs.tycho.parser.lth;

import se.lth.cs.tycho.instance.net.ToolAttribute;
import se.lth.cs.tycho.instance.net.ToolTypeAttribute;
import se.lth.cs.tycho.instance.net.ToolValueAttribute;
import se.lth.cs.tycho.ir.entity.nl.StructureForeachStmt;
import se.lth.cs.tycho.ir.decl.*;
import se.lth.cs.tycho.ir.util.ImmutableList;
import se.lth.cs.tycho.ir.expr.*;
import se.lth.cs.tycho.ir.stmt.lvalue.*;

import java.util.TreeSet;
import java.util.ArrayList;

import se.lth.cs.tycho.ir.*;
import se.lth.cs.tycho.ir.entity.nl.NlNetwork;
import se.lth.cs.tycho.ir.IRNode;
import se.lth.cs.tycho.ir.entity.nl.EntityExpr;
import se.lth.cs.tycho.ir.entity.nl.EntityIfExpr;
import se.lth.cs.tycho.ir.stmt.*;

import java.util.Map;

import se.lth.cs.tycho.ir.entity.nl.PortReference;
import se.lth.cs.tycho.ir.entity.nl.StructureConnectionStmt;
import se.lth.cs.tycho.parser.SourceCodeOracle;
import beaver.*;
import se.lth.cs.tycho.ir.decl.GlobalDecl.Availability;
import se.lth.cs.tycho.errorhandling.BasicErrorModule;

import java.io.PrintStream;

import se.lth.cs.tycho.ir.entity.nl.StructureIfStmt;
import se.lth.cs.tycho.errorhandling.ErrorModule;

import java.io.File;

import se.lth.cs.tycho.ir.entity.nl.StructureStatement;

import java.util.AbstractMap;

import se.lth.cs.tycho.ir.entity.nl.EntityInstanceExpr;
import se.lth.cs.tycho.ir.IRNode.Identifier;
import se.lth.cs.tycho.parser.SourceCodeOracle.SourceCodePosition;
import se.lth.cs.tycho.ir.entity.nl.EntityListExpr;
import se.lth.cs.tycho.ir.entity.*;
import se.lth.cs.tycho.ir.util.ImmutableEntry;

/**
 * This class is a LALR parser generated by
 * <a href="http://beaver.sourceforge.net">Beaver</a> v0.9.6.1
 * from the grammar specification "NlParser.beaver".
 */
public class NlParser extends Parser {
	static public class Terminals {
		static public final short EOF = 0;
		static public final short NETWORK = 1;
		static public final short IDENTIFIER = 2;
		static public final short LPAREN = 3;
		static public final short RPAREN = 4;
		static public final short PORTCONN = 5;
		static public final short COLON = 6;
		static public final short IF = 7;
		static public final short THEN = 8;
		static public final short ELSE = 9;
		static public final short END = 10;
		static public final short IMPORT = 11;
		static public final short EQ = 12;
		static public final short SEMICOLON = 13;
		static public final short MAP = 14;
		static public final short LBRACE = 15;
		static public final short RBRACE = 16;
		static public final short BEGIN = 17;
		static public final short VAR = 18;
		static public final short DO = 19;
		static public final short CHOOSE = 20;
		static public final short IN = 21;
		static public final short COMMA = 22;
		static public final short LBRACK = 23;
		static public final short RBRACK = 24;
		static public final short DOT = 25;
		static public final short ALL = 26;
		static public final short EDGE = 27;
		static public final short DOUBLECOLON = 28;
		static public final short MUTABLE = 29;
		static public final short COLONEQ = 30;
		static public final short FUNCTION = 31;
		static public final short PROCEDURE = 32;
		static public final short MULTI = 33;
		static public final short LET = 34;
		static public final short CONST = 35;
		static public final short LAMBDA = 36;
		static public final short WHILE = 37;
		static public final short ENTITIES = 38;
		static public final short STRUCTURE = 39;
		static public final short ENTITY = 40;
		static public final short ENDNETWORK = 41;
		static public final short LT = 42;
		static public final short ARROW = 43;
		static public final short INTEGER_LITERAL = 44;
		static public final short LONG_LITERAL = 45;
		static public final short FLOATING_POINT_LITERAL = 46;
		static public final short DOUBLE_LITERAL = 47;
		static public final short TRUE_LITERAL = 48;
		static public final short FALSE_LITERAL = 49;
		static public final short CHARACTER_LITERAL = 50;
		static public final short STRING_LITERAL = 51;
		static public final short NULL_LITERAL = 52;
		static public final short OLD = 53;
		static public final short PROC = 54;
		static public final short OPERATOR = 55;
		static public final short GT = 56;
		static public final short MULT = 57;
		static public final short BAR = 58;
		static public final short FOREACH = 59;
		static public final short FOR = 60;
		static public final short ENDCHOOSE = 61;
		static public final short ENDFOREACH = 62;
		static public final short ENDIF = 63;
		static public final short ENDLAMBDA = 64;
		static public final short ENDLET = 65;
		static public final short ENDPROC = 66;
		static public final short ENDWHILE = 67;

		static public final String[] NAMES = {
			"EOF",
			"NETWORK",
			"IDENTIFIER",
			"LPAREN",
			"RPAREN",
			"PORTCONN",
			"COLON",
			"IF",
			"THEN",
			"ELSE",
			"END",
			"IMPORT",
			"EQ",
			"SEMICOLON",
			"MAP",
			"LBRACE",
			"RBRACE",
			"BEGIN",
			"VAR",
			"DO",
			"CHOOSE",
			"IN",
			"COMMA",
			"LBRACK",
			"RBRACK",
			"DOT",
			"ALL",
			"EDGE",
			"DOUBLECOLON",
			"MUTABLE",
			"COLONEQ",
			"FUNCTION",
			"PROCEDURE",
			"MULTI",
			"LET",
			"CONST",
			"LAMBDA",
			"WHILE",
			"ENTITIES",
			"STRUCTURE",
			"ENTITY",
			"ENDNETWORK",
			"LT",
			"ARROW",
			"INTEGER_LITERAL",
			"LONG_LITERAL",
			"FLOATING_POINT_LITERAL",
			"DOUBLE_LITERAL",
			"TRUE_LITERAL",
			"FALSE_LITERAL",
			"CHARACTER_LITERAL",
			"STRING_LITERAL",
			"NULL_LITERAL",
			"OLD",
			"PROC",
			"OPERATOR",
			"GT",
			"MULT",
			"BAR",
			"FOREACH",
			"FOR",
			"ENDCHOOSE",
			"ENDFOREACH",
			"ENDIF",
			"ENDLAMBDA",
			"ENDLET",
			"ENDPROC",
			"ENDWHILE"
		};
	}

	static final ParsingTables PARSING_TABLES = new ParsingTables(
		"U9pjN0TuLDNodtFlfh8X8984L4H5eg0YY0KLGOY828GQwHsa8qMa5wLA4n44GMeGK0WYLbH" +
		"KL2pOdktPdhrYLopFfyp$T#PEDdStksHvp$3v#S$opPqvCtFcTsREkUUUQtObgk3InRIQJg" +
		"PiCuXUf0haC9cPLFVWxzIBBZDBQIyzmo$HprJFN4ATwJowY4wXKsa5tKeDwNowW2waOJI3h" +
		"g6tJ3kgQFhIPAfFjMWNFKWFqSEqcnwXH#ansaEDQ3QTIMVHsNGENK6TBAh90Uh5G7MjnbIZ" +
		"kkPuYqe1sckEvGs2UhMYDeY1EixiuBVeEgfldeWJzLPQGFVHYoRFtCT4nr1TIXRKDu1QrRI" +
		"ngBIOEfl1DCPiev4qYaRpBwQvcKHN5QBIQ$I66Sbl8zVqk55ppGs2UYUzQL7v1gdmDA3UH4" +
		"cIwsIWJZ6FqjsqNRmB1FND4EezPfhPQQPIVPuK7ohbUwYKGFdcSLC55LvKX6gw2kgD5fKAA" +
		"D5SRsRnP4WxgO3l3w6UP7QOIYO35Ru$pbohQAuFei9$M5HABK9b5jJb7ghPPix3UYkGlWLO" +
		"RqMeJtger2PEr3QAMiCCvZ62kjLNuVi5TQLKUAIijuv0pQLMG3sv29KUrrmxn8bQmsJp65H" +
		"u0a#dZOAwML1xuivfQNOBQZUWdW2qsqnTkfm#e$sK4evg#cYk8#BDrMHJ6b2lnoej9$FQMT" +
		"RmFkHQ3b7i6lxIefgHPgQv0XLkIupgXbKOBI$NYN6YBZ8JA1iLRaFbgPkW3fPSMm3rUZDNK" +
		"FDnlrf$IrszIWFdCX$gEvfhGRovyay65JPtObxNIuL7IAvtq5wUPgfAXKTHP$uPQ3KmezqB" +
		"LnFryrLufwBsZVFEoQN#T3Kgl8Yd0dbcw7x5ZcYgUpkYpTNKeVdqFcsH$QewCdq9irk8kjz" +
		"KeE$DpiF8zMcwWKTH4nujcdpaUa1GonbZAfYzfWPGir7X3#XBSw8vdKwZAPZdkeZ$Yw8MqA" +
		"$4y2e0we4IK6sUzOqB$oRqawpV0SZp0q7i6lAgXnftjbQQAjSnV9#tAtg8vYZw2Mlv31eEn" +
		"EmugvlDeqnrvFaUTjmySn9MqgaofsDGCI#se9gZpFbOjm$HipG6iSDHtp0FczDCHQ3cnrdT" +
		"ir2LVEHwCL3lvlTHjyQA#c0XggqkOdkhzZZJ3wCem0wShTKTWzRnT0ATYBhT4UzACcFDxTJ" +
		"4RA9gfgFPWGfxpzPRp0gf#QDwrsIRwymwirPgd6qUCFdKMdDz1lMQRRPJn$XN4lStkymUeE" +
		"uppvldg0ToxIsv3gG1vc7aawqhQJoDeuaq4tmwpw5PD9VcQAxpC1SBnRFaUPKvfVMq0TNTY" +
		"3jp4zqEn6s2U2VjeBleNhbZBEAJz3GzBt5VfN$Il#Wz#aWHFwPFwGlwchv5TODn8Fw86ByZ" +
		"HpAfne5SroH9PTDCEeqmHmlYUCndPPDficYkESRKD6UOMgXkgbQs0UIcvYBJ9BuSJKlykno" +
		"8hKnhaslQ0h6z8EQPBeZKI$QYJa3iRGQO$kPAcwKPPeQR4KRF3cQqkSQCnvvyBNAS7WVY33" +
		"FVp07YRF3vPXwgcYs8YyqIn5ubYAk1kCQiDnlC9hEHffZRCAvDPhCYRZ45vYvutGF4U#FP4" +
		"H3tCI3kveFcAPw5MFi4yLdVZl0Y45yWegbK#AahLsyUlKyzMeLOA#D2j9ycOR7iog4YHCYT" +
		"AVpZGvJTbyJBnYeDn2anSYmDHAcggNy44ScSJSrYpcFfL3Md#3oMCgBzD3$YYB5oR7$44UF" +
		"FSSX$XRZy25Nr7tzAZdzMLNyxqeWcuOWZNbYwYAP7iQgMpYutD7QEfODugAfQHBFmJy$nvh" +
		"zQZcM8POXbY6M8fO98nH0fRaIAYLZuAKCiGun4j7#DE3Vihn5Fq5BqogNlw4DwWJwd9Q5eq" +
		"Ns$2ldU2D#IuZqLXyzpCNnUzlcy4aUSr#FmUJSEdq$YyFac3fyVIlOnvKlqkIcA$KBgQUtc" +
		"ND$STuZgDpYgTj8XOZRsmfdge8QXwDDYzY1pZcyKfqTTD#fPz36dmBEsJt4bzOcnvYwaEjG" +
		"2jSYB9wwCu51#1qD#$m5rEPIlIGcDDZ76k6oz6Xr6tUjGbWJy8sQyIa1BZcgjIKTJPSgWJA" +
		"f2LINAe1XHeccRHjLU4bLxQLHjkwZQeL6rOwDghusglJcgzfQesZLHjGz4rRuKLVjsLEs$e" +
		"sbD8AgsTbJjcL6rzQ9gBuYgRHPLspsgTc1KxP2esWLHjSkYQX$1#boB5LZLTp$LfJ6uUdyt" +
		"8BELcidpg6x8lavvlMBhSncUHq5pgS#Nw2YoJwbweUTHuMUPN2ErrlUuOdSuHVWUImwv5AG" +
		"SF0kJA9KCo46xWCfJEZGLWPegewk6qULWrJV36c#EPsmBkfnQKYjaTXBLe9En5cqz1b8jn3" +
		"iDEyaPk9lEnFZh0Qk#e9sBkZNGLMDHRRmgm714Kn6ebGJrUa6j9AY99Q1cO7VB4jIDSQAMe" +
		"nlG9mauGv7PKK2zIb1JWPeB3ukw3gX9s3KdKoUS7hgWJZKfctg4K5FWdGdSMfGMDseRQYke" +
		"3iuK5ZLHKBi2jJi51BKtOlR565RZNhNUcOBQo9ThLwoaxa0z9avKHr6jD57cTR0FrV6XPj8" +
		"y6aVZ4TdcbKaLGgZ7OKJ7KtMWhZfCL0SL3WZgLJvKDmnrijGyK$hQcXUXPYfgpyD6JL9KVu" +
		"M3OQYsJpzmhygvFjIfYZewRjJXG4kYaTeAOW#mg8b0JLJK832cWxP1Kq7MJa84wWH5pJWCr" +
		"0M2ceIO5dMbe5O2geCe5hMXeZgq1MHtbwGO5HuR9#fWwePxqLPueQ8c2UeoeDgrOr4Bvz9I" +
		"LcXUD$bG#ojgPjov4YtNUQqag1c2wW0rW2fQrCs8Hg0ydL4FDT67UeAYLeWJrSO9oeverv9" +
		"5JGZjYBrqHxIvLiFfAnKZiljL6jfJq2f4JHNj2OUHwwrubqcKzUjfWeZXvPgBM5jb7dCGhI" +
		"bcDmFtQW3sXhA#UYfgfinqPV1Qi1qQrIBMqfLnKMZz1XInqAioi3F5sbYkUQYXjojwY3tGD" +
		"nSn#Y1MJfnvvY3BNa1DGyzqhEKWgcXHyv2b5zj3xI6ZcuJOUUWJZffASx3lMrGdJjGbaaUI" +
		"LDD1da4yLpnK9uIQ8wZU#kaZJvTCxC0vYfg7bkTP2oEDVoMT8gXNOy$93LKuHPwqBZJUIih" +
		"1dXD4HRpwPE0SKBW7Pw2TXRqqup1MKW3x$IH1lPtkGEyW42rg1gBEGRmSpTMb4V2j0Pu8hn" +
		"7WSnKrW0mNYsV9y#gDELTsGbTgEnM8kO9uZ3oXlVlK8gOXxrI9EmZ$Ak5DkByYLg81#6Ulj" +
		"R0wIaOS9NLAalkp9#J2dQ4IB1dwTBEdZ16GvyguxCmdmjDHn9uYPr1#d3dQ26E16CHEc2Rd" +
		"9cykqx63vsYE5IH71#Ufe6JP3JFT3PbwY5durmtMhd4ynIrYcgxPAk2Ps85jJ2z7MqDl7xe" +
		"5bY7migX3e4k3buCU7k8GgOMzdqg#KxmT8KSGWv2p94T74AT4x0YrcAanwuU2SXL4rLIMzP" +
		"eL3wBu9$bZMKHSGuYGCpdiuqUq#wn51DbHbG8YfKRFiJGGlQeUIKJmYoabrZoM4c9ox9Npz" +
		"vZ7w6kr4D7U7KSMCVuSgVP$WqXfV#ULyzUPnxyVul$FbMCH$$pdurylnpB4CiGon3B4qa1K" +
		"Nn#YjED2LDyeY25D6M8POYHYjBz6j4Ol#zzvsb5xwa0TGz6Y#b9$lsyyySfy$aUVGzXzStz" +
		"5ZFaw3Aq$9lMoCKFHhupL0xPf$b74MZSHAtSHnZlCrrvF6mwnveP9BUA86xiEQcqNDj9XyV" +
		"eUSeuEf#xzlCWnuus9RQLhwJgQGJDf5itswlw$ptYPjamRlZufW9MLwxkVWfI7g$pTmAvFI" +
		"f7dKJ1aFrPvvMBhinhU4EVJrKM#qDdVKTk$skZpAAIl9jS8hVWkZRp3rHBofTk8p3#cUTyD" +
		"I0Grajy54NqBRhzfj9l8MGJv7iZtWhy5RlUUty5lXAqjg9$jhp4s5ygn29yVFMxEyBYpFDn" +
		"kiX7$PwA4055A5V26sgycaViP$D$oscuQR6FXqwvap8JjiMtkDJw$pr66#g0J8Fy7l0jec6" +
		"TBN8AnRT8n9gFVmof$2deNzkT0gAU3VkuZe7F2SP8IOAkiVGx0hdcap8Fy2UmNmNwbrgGET" +
		"9$h#3w0xHeTmtkGxqIV9n1Z40YooI#UapCTVb$0xm$q$rqn1q16sza3UYsY1WU9aaya2hoh" +
		"RUGJK5iWeFrlXMppjjy1EminPeR7eEtAztiyVIzYTiKuihnsyaseQMPud#JduRTHntmouf#" +
		"ec90Tr3vGKstp8MVhEAv4UwLYVGLzPV3lmQlwneBwE$kAsYbOswbXyt4eGgpQbcCTeYw1Ee" +
		"gBsfjN88o1xanVRDmpIRWF3CQSZlcWnUhV2vS9uN5Jng46RT3$DDXNOemtXzkTnR3LW#rrK" +
		"64z6q2$Ec9yk4UTYg0DscyLg2NeoOXuBu4mvfGT6EFrw5STT1ceiozMJ#KOh$CbVFV3zt6q" +
		"SNy7x5ZtXSTq7UZou3iRz97YL8MkeyOP31ggybMWaTeFumsCLl#EeAOHOyLwSLvLtwFXEyQ" +
		"7YNm3ep279w5#SrMduqxj1Xe1MWhR7dzCNuwekti#V5v0RjYxt97G3G7VwlEP4jwdN1ByDw" +
		"lj9kLBbI$4$FG1NwJjMn0B#rK0SnfOKXJ3Vbyoi5p7c#9nin6n6sFjdwtwg#5pgozNZ3MmH" +
		"UEkW#zuZEC37TDTw3SSCTw0RJFgbGd$Teer4xerAcEEtLoqrsfjMuVdPXef$qPnreFkHv#w" +
		"u7jKzm1e5#X5aEvrWTqw3goJv4s#sZsD2#eLUBb85wm1d$U1yHtYxjHnt02VmZd6UdIHZxj" +
		"BOtm8UaFbZq7lg8pr6$Z2FtxLluruchlx4DhVgOnwkLXBWGE#ckBvvKxJdDVxnjWTkM3j9c" +
		"1VI$0$BrBX$pLYsETG4FA3uEcA#uClxgF#CM6$wAxy4SzEuvLNLAwrJS$1E30$PdxnlD8EH" +
		"EgA#wHtK$p6qUrE1O#NpuQCSmFxvYLjPBXl#GiGfqB9c9GMs#OsyCLhXdPJSEo9RclmRaMr" +
		"JvjLvESz$pNszzeNUxix2tvwDaZBZwZDNRuSCujaTw7Qc$Zi5qJqFQY#ECUKnrxYtcUVXOf" +
		"$RlIyoa#67#u3jt1FhwUnMXNESOJ$7EX$yuthPkLJjR#U9Pm6yCFpsPqStZyuMEDNqtxx41" +
		"Fd3lSvZRyQyWiHc5kWUr$zNm#tcUJmjd#$S$LPJxMr$M7nVDoFVJXte$r3f4z9X9mc5ScEt" +
		"gF1XH4vsFFIBz2l1VyLf7j4qEuF4MULyi$Qvx3Qdu2z86BCkcy4No#gIx23FKT56HlEUwu#" +
		"mrpiQS7VB0$tSMOexclsZ86vsQljbEBn0W6rlUyzQzDqBEMpejScpUujlohE7n6n75zE#ul" +
		"tTMj7Z#cy4aDVE1RawVoi6AUexcVlJ95kO2ks3jJtU8#dOym1x1bfdJI7xtnZUZUyJpgUJu" +
		"76dcpcQPmJVJ4R#VrnJonGtwmY7zFSvt#gBxOzh$PIVLwKyPxjyptTdajKFizxzWSw5FO5j" +
		"L2iNU4nt5w#UDt3RTHF#KIVJw$2vx7Q5lZok4Dzz6oKthJmNE7pNnFUJiV#6LW1uIrVdCe#" +
		"l4ljsIOoTxLDYcZFZExd3epITsCCNptB5Rq$O8oTuV#atrvaSquDRmUMgLypdyvtJZU5l$E" +
		"F#F2$Gz9Elej$vT$u0F$8F$3t$1tluSVuQ$wIl#9lOD$FNp3kQiPEoNXZuGkvaVJho$rm7S" +
		"0NyFdSWC$ZS$aSFfiRGdSHD#DBk2ddCKwbt84tXo6tv$wujXEvhUgE1M4du0m#YYkAlOteS" +
		"ndFByQSSKjfNywjS1qaya3jkv7NyLfUmpWfCawD7FhD6W$ZP4vIMNwrpir1bueqYd72vQiu" +
		"m2uJ3p$81$zGppFbseGRi$pQZJl9zGgUBdoANCV9DVIRDvx84uHVozVXEfRxS6$knJsv1tV" +
		"dRjoLk$1urAEE#9mHwdNwGVaT47kjqopdsfpA#eiVQTTYXqseTQfSJ#7odAQQREKrESZbj5" +
		"yD4EvbhiRLSQsaMfpq6M$XV1mVpqVpqTeFxrYSpxU9X$pwWPVoSbpb5$1SWTDvf4Xr6M$nV" +
		"1RN2uqUTppZfCqhfDM24pc11tEMMey1LG5LPknOdCER#6BmLVmjVy8VySVygVfzgFmz$XU$" +
		"An9E4$o0Qk#HwzsyI$ZhSds5$qc#3xyZrpUrXNCylyglyMVy4h$0Bt9e$VFp$1G$2VuKFy5" +
		"x#MdHFSxFgFKvVbautkzudqZFyiF27vNh8tBTpRVZkeKVuWVvFxm8yWB6MpZZHC5uk#F5l5" +
		"3yxkJjl8qB8Dq1sivRUKVOc6VmF9xBEA$pVCPRXd49CiZGFF1vu3S9EOJtT90X6tSXU06bu" +
		"NtP5AEbGexzxqyWGzV9jsGj6Q5bGWvjWdqJv1do$Si0sNc#6UtHuAF1k#7OtWrl7lQUtInj" +
		"LtGh8A#0l1nyEVWreBwG#o9ER$ZsXZmJSdVusbzXU3o9na4$3dgyGu0CTPLlR2RGOFI$5cr" +
		"Bi#0$Yn9fDlIuWq56QAMG$TOzWGprGvy9yBMq06rBguHScWIVIP3jRpCceZr7li5fG2vT0f" +
		"uFwYFaKY$OiCU07Ee1NI5racyl1vHisnNAWso$sTmPSXVGKBI7agFa4jx9GOOc2xbqE$IOT" +
		"v2XAP2tGjuAUQDyBzs0N5eDlbg#isne6#pRmEstVjT0NYDoWhJNGbuBlwbAYn3Ftf4ZeSVU" +
		"238q5xN3Uo38eH7eDm9r7q79j1wszUWpJVxle0RaqZ2olzSrr0gnBmClYLe8kQ04kXooHmu" +
		"e2UI24aBS$l#ZDeWz04fKcwDsXow5pIDNU4lmvj0t1s#6TZF8hS5RotUWJKmQBkJGTF3fy6" +
		"qFlFPejnSv4PG0IegGKzGlWTg1jnEU24hoyMHG2hM5lItiRQ6tluCfuicW5Ee9t9xoVNGZj" +
		"4vfWD8efK5A0vMMA2rMkb49PscGeOv23ct$Frvfpce=");

/*******************************************************
 *  Code for error handling in the parser class.
 *******************************************************/
  // all errors encountered during parsing is stored in the array parseProblems. This includes lexical, syntactical and semantic error (multiple initialization actors et.c.)
  BasicErrorModule em;

  private void warning(String msg, Symbol startS, Symbol endS){
    int start = startS.getStart();
    int end = endS.getEnd();
    em.warning(msg + " between " + Symbol.getLine(start) + ":" + Symbol.getColumn(start) + " and " + Symbol.getLine(end) + ":" + Symbol.getColumn(end) + " in " + file.getName(), null);
  }

  public ErrorModule getErrorModule(){ return em; }

  private void warnPortIndex(Expression[] index){
    if(index != null && index.length != 0){
      em.warning("port index is ignored", index[0]);
    }
  }

  // parser plug-in methods that are called when the parser encounters a syntactical problem
  class Events extends Parser.Events {
    public void scannerError(Scanner.Exception e) {
      em.error(e.getMessage(), null);
    }
    public void syntaxError(Symbol token) {
      // This method is always called when a problem is encountered, even if it is repaired.
      // beaver.Parser$Exception is thrown if recovery fails.
      String value = token.value != null ? token.value.toString() : Terminals.NAMES[token.getId()];
      em.error("unexpected token \"" + value + "\" at " + Symbol.getLine(token.getStart()) + ", " + Symbol.getColumn(token.getStart()), null);
    }
    public void unexpectedTokenRemoved(Symbol token) {
      String value = token.value != null ? token.value.toString() : Terminals.NAMES[token.getId()];
      em.warning("parser recovered after removing token \"" + value + "\" at " + Symbol.getLine(token.getStart()) + ", " + Symbol.getColumn(token.getStart()), null);
    }
    public void missingTokenInserted(Symbol token) {
      String value = token.value != null ? token.value.toString() : Terminals.NAMES[token.getId()];
      em.warning("parser recovered after inserting token \"" + value + "\" at " + Symbol.getLine(token.getStart()) + ", " + Symbol.getColumn(token.getStart()), null);
    }
    public void misspelledTokenReplaced(Symbol token) {
      String value = token.value != null ? token.value.toString() : Terminals.NAMES[token.getId()];
      em.warning("parser recovered after replacing token \"" + value + "\" at " + Symbol.getLine(token.getStart()) + ", " + Symbol.getColumn(token.getStart()), null);
    }
    public void errorPhraseRemoved(Symbol token) {
      String value = token.value != null ? token.value.toString() : Terminals.NAMES[token.getId()];
      em.warning("parser recovered after removing token \"" + value + "\" at " + Symbol.getLine(token.getStart()) + ", " + Symbol.getColumn(token.getStart()), null);
    }
  }

  {
    // initialization, before the constructor
    report = new Events(); // Use error handler in parser
  }

/********************************************************
 * Store the source code position of the symbols.
 * The following IR-nodes have source file information:
 * Registered by NLParser.beaver:
 * - EntityIfExpr
 * - EntityInstanceExpr
 * - EntityListExpr
 * - NlNetwork
 * - PortReference
 * - StructureConnectionStmt
 * - StructureForeachStmt
 * - StructureIfStmt
 * - ToolValueAttribute
 * - ToolTypeAttribute
 *
 * Registered by CommonParser.beaver
 * - ExprLiteral
 * - Field
 * - Variable
 * - ExprVariable
 * - LocalVarDecl
 * - ExprApplication
 * - ExprLiteral
 * - ExprIf
 *
 * The following IRNodes do not have source code info:
 * - GeneratorFilter
 * - Import
 * - LValue
 ********************************************************/

  private File file;
  private Map<Identifier, SourceCodePosition> srcLocations;
  public Symbol register(Symbol start, Symbol end, IRNode node){
    if(srcLocations != null){
      srcLocations.put(node.getIdentifier(), SourceCodePosition.newIncluding(start, end, file));
    }
    return new Symbol(node);
  }
  public Symbol register(IRNode start, Symbol end, IRNode node){
    if(srcLocations != null){
      srcLocations.put(node.getIdentifier(), SourceCodePosition.newIncluding(srcLocations.get(start.getIdentifier()), end));
    }
    return new Symbol(node);
  }
  public Symbol register(Symbol start, IRNode end, IRNode node){
    if(srcLocations != null){
      srcLocations.put(node.getIdentifier(), SourceCodePosition.newIncluding(start, srcLocations.get(end.getIdentifier())));
    }
    return new Symbol(node);
  }
  public Symbol register(IRNode start, IRNode end, IRNode node){
    if(srcLocations != null){
      srcLocations.put(node.getIdentifier(), SourceCodePosition.newIncluding(srcLocations.get(start.getIdentifier()), srcLocations.get(end.getIdentifier())));
    }
    return new Symbol(node);
  }

/*******************************************************
 *  Help routine that parses a file, given its name.
 *  If a Parser.exception is thrown a CompilationUnit with an empty network is returned.
 *******************************************************/

  public GlobalEntityDecl parse(String fileName, Map<Identifier, SourceCodePosition> srcLocations, SourceCodeOracle scOracle){
    return parse(new File(fileName), srcLocations, scOracle);
  }
  public GlobalEntityDecl parse(String path, String fileName, Map<Identifier, SourceCodePosition> srcLocations, SourceCodeOracle scOracle){
    return parse(new java.io.File(path + File.separatorChar + fileName), srcLocations, scOracle);
  }
  public GlobalEntityDecl parse(File file, Map<Identifier, SourceCodePosition> srcLocations, SourceCodeOracle scOracle){
    this.file = file;
    this.srcLocations = srcLocations;
    em = new BasicErrorModule(scOracle);
    GlobalEntityDecl network;
    java.io.FileReader fr = null;
    try {
      try {
        fr = new java.io.FileReader(file);
        NlScanner scanner = new NlScanner(new java.io.BufferedReader(fr));
        network = (GlobalEntityDecl)parse(scanner);
        fr.close();
      } catch(CalParser.Exception e) {
        // build empty compilation unit for failed error recovery
        // The problem is added to parseProblems[] by the syntaxError() method added to the parser above.
        network = new GlobalEntityDecl(file.getName(), null, null);
      } finally {
        if(fr != null){ fr.close(); }
      }
    } catch (java.io.FileNotFoundException e){
      em.error("file not found: " + e.getMessage(), null);
      network = new GlobalEntityDecl(file.getName(), null, null);
    } catch (java.io.IOException e){
      em.error("error reading file: " + e.getMessage(), null);
      network = new GlobalEntityDecl(file.getName(), null, null);
    }
    return network;
   }

  private enum NetworkBodyPartKind{ IMPORT, VAR_DECL, ENTITIES, STRUCTURE, TOOL_ATTRIBUTE; }

/******************************************************************************
 * Needed by CommonParser.beaver
 * Repeated in both NlParser.beaver and CalParser.beaver
 *****************************************************************************/
  private Symbol makeGeneratorFilter(Symbol start, TypeExpr t, ImmutableList<Symbol>varList, Expression e, ImmutableList<Expression> filterList, ImmutableList l){
    GeneratorFilter gen = makeGeneratorFilter2(t, varList, e, filterList);
    Expression end = e;
    if(filterList != null && !filterList.isEmpty()){
   	 end = filterList.get(filterList.size()-1);
    }
    register(start, end, gen);
    ImmutableList.Builder newList = ImmutableList.builder().add(gen);
    if(l != null){
   	 newList.addAll(l);
    }
    return new Symbol(newList);
  }
  private GeneratorFilter makeGeneratorFilter2(TypeExpr type, ImmutableList<Symbol> varList, Expression e, ImmutableList<Expression> filterList){
    ImmutableList.Builder<LocalVarDecl> vars = ImmutableList.builder();
    for(Symbol var : varList){
      LocalVarDecl decl = new LocalVarDecl(type, (String)var.value);
      register(var, var, decl);
      vars.add(decl);
    }
    return new GeneratorFilter(vars.build(), e, filterList);
  }
  class ParenthesSymbol extends Symbol{ // used by the parser to wrap subexpressions that are enclosed by parentheses, i.e. do not add them to a ExprBinaryOp sequence.
     ParenthesSymbol(Symbol s){
       super(s.getId(), s.getStart(), s.getEnd(), s.value);
     }
  }
   
  private LValue expressionToLValue(Expression expression) {
    if (expression instanceof ExprVariable) {
      Variable var = ((ExprVariable) expression).getVariable();
      return new LValueVariable(var, var);             // use the same Variable as the Variable node
    } else if (expression instanceof ExprIndexer) {
      ExprIndexer exprIndexer = (ExprIndexer) expression;
      LValue structure = expressionToLValue(exprIndexer.getStructure());
      if (structure == null) return null;
      LValue result = new LValueIndexer(structure, exprIndexer.getIndex());
      register(structure, exprIndexer, result);
      return result;
    } else if (expression instanceof ExprField) {
      ExprField exprField = (ExprField) expression;
      LValue structure = expressionToLValue(exprField.getStructure());
      if (structure == null) return null;
      LValue result = new LValueField(structure, exprField.getField());
      register(structure, exprField, result);
      return result;
    } else {
      return null;
    }
  }

	public NlParser() {
		super(PARSING_TABLES);
	}

	protected Symbol invokeReduceAction(int rule_num, int offset) {
		switch(rule_num) {
			case 4: // lst$network_body_part = network_body_part
			{
					ArrayList lst = new ArrayList(); lst.add(_symbols[offset + 1].value); return new Symbol(lst);
			}
			case 5: // lst$network_body_part = lst$network_body_part network_body_part
			{
					((ArrayList) _symbols[offset + 1].value).add(_symbols[offset + 2].value); return _symbols[offset + 1];
			}
			case 10: // network = NETWORK.startSymbol IDENTIFIER.name opt$type_parameter_block.typePars LPAREN opt$actor_parameter_list.valuePars RPAREN port_decl_list_opt.inputPorts PORTCONN port_decl_list_opt.outputPorts COLON opt$lst$network_body_part.body end_network.endSymbol opt$SEMICOLON
			{
					final Symbol startSymbol = _symbols[offset + 1];
					final Symbol name = _symbols[offset + 2];
					final Symbol _symbol_typePars = _symbols[offset + 3];
					final ImmutableList typePars = (ImmutableList) _symbol_typePars.value;
					final Symbol _symbol_valuePars = _symbols[offset + 5];
					final ImmutableList.Builder valuePars = (ImmutableList.Builder) _symbol_valuePars.value;
					final Symbol _symbol_inputPorts = _symbols[offset + 7];
					final ImmutableList inputPorts = (ImmutableList) _symbol_inputPorts.value;
					final Symbol _symbol_outputPorts = _symbols[offset + 9];
					final ImmutableList outputPorts = (ImmutableList) _symbol_outputPorts.value;
					final Symbol _symbol_body = _symbols[offset + 11];
					final ArrayList _list_body = (ArrayList) _symbol_body.value;
					final Map.Entry[] body = _list_body == null ? new Map.Entry[0] : (Map.Entry[]) _list_body.toArray(new Map.Entry[_list_body.size()]);
					final Symbol endSymbol = _symbols[offset + 12];
					
        NamespaceDecl ns = null;
        ImmutableList.Builder varDecls = ImmutableList.builder();
        ImmutableList.Builder structure = ImmutableList.builder();
        ImmutableList.Builder<java.util.Map.Entry<String,EntityExpr>> entities = ImmutableList.builder();
        ImmutableList.Builder<ToolAttribute> toolAttributes = ImmutableList.builder();
        for(Map.Entry part : body){
            ImmutableList all;
            if(part.getValue() != null){  // entities and structure may be empty. Then the parser return null.
                switch((NetworkBodyPartKind)part.getKey()){
                case IMPORT:
                     System.out.println("UNSUPPORTED, import is ignored.");
                     //TODO
                     break;
                case VAR_DECL:
                    varDecls.addAll((ArrayList)part.getValue());
                    break;
                case ENTITIES:
                    entities.addAll((ArrayList)part.getValue());
                    break;
                case STRUCTURE:
                    structure.addAll((ArrayList)part.getValue());
                    break;
                case TOOL_ATTRIBUTE:
                    toolAttributes.addAll((ImmutableList)part.getValue());
                    break;
                }
            }
        }
        
        return register(startSymbol, endSymbol, new GlobalEntityDecl((String) name.value,
        		new NlNetwork( 
                          typePars,     // typePars,
                          valuePars == null ? null : valuePars.build(), // valuePars,
                          null,      // typeDecls, NOTE, can not be expressed in NL
                          varDecls.build(),             // varDecls
                          inputPorts,
                          outputPorts,
                          entities.build(), // entities
                          structure.build(), // structure
                          toolAttributes.build()
                          ), Availability.PUBLIC));
			}
			case 11: // network_body_part = import_part.part
			{
					final Symbol _symbol_part = _symbols[offset + 1];
					final ArrayList part = (ArrayList) _symbol_part.value;
					 return new Symbol(new AbstractMap.SimpleEntry(NetworkBodyPartKind.IMPORT, part));
			}
			case 12: // network_body_part = network_decl_block.part
			{
					final Symbol _symbol_part = _symbols[offset + 1];
					final ArrayList part = (ArrayList) _symbol_part.value;
					 return new Symbol(new AbstractMap.SimpleEntry(NetworkBodyPartKind.VAR_DECL, part));
			}
			case 13: // network_body_part = entities.part
			{
					final Symbol _symbol_part = _symbols[offset + 1];
					final ArrayList part = (ArrayList) _symbol_part.value;
					 return new Symbol(new AbstractMap.SimpleEntry(NetworkBodyPartKind.ENTITIES, part));
			}
			case 14: // network_body_part = structure.part
			{
					final Symbol _symbol_part = _symbols[offset + 1];
					final ArrayList part = (ArrayList) _symbol_part.value;
					 return new Symbol(new AbstractMap.SimpleEntry(NetworkBodyPartKind.STRUCTURE, part));
			}
			case 15: // network_body_part = tool_attribute_block.part
			{
					final Symbol _symbol_part = _symbols[offset + 1];
					final ImmutableList part = (ImmutableList) _symbol_part.value;
					 return new Symbol(new AbstractMap.SimpleEntry(NetworkBodyPartKind.TOOL_ATTRIBUTE, part));
			}
			case 16: // lst$network_decl = network_decl
			{
					ArrayList lst = new ArrayList(); lst.add(_symbols[offset + 1].value); return new Symbol(lst);
			}
			case 17: // lst$network_decl = lst$network_decl network_decl
			{
					((ArrayList) _symbols[offset + 1].value).add(_symbols[offset + 2].value); return _symbols[offset + 1];
			}
			case 20: // network_decl_block = VAR opt$lst$network_decl.d
			{
					final Symbol _symbol_d = _symbols[offset + 2];
					final ArrayList _list_d = (ArrayList) _symbol_d.value;
					final LocalVarDecl[] d = _list_d == null ? new LocalVarDecl[0] : (LocalVarDecl[]) _list_d.toArray(new LocalVarDecl[_list_d.size()]);
					 return _symbol_d;
			}
			case 21: // network_decl = var_decl.d SEMICOLON
			{
					final Symbol _symbol_d = _symbols[offset + 1];
					final LocalVarDecl d = (LocalVarDecl) _symbol_d.value;
					 return _symbol_d;
			}
			case 22: // network_decl = fun_decl.d
			{
					final Symbol _symbol_d = _symbols[offset + 1];
					final LocalVarDecl d = (LocalVarDecl) _symbol_d.value;
					 return _symbol_d;
			}
			case 23: // network_decl = proc_decl.d
			{
					final Symbol _symbol_d = _symbols[offset + 1];
					final LocalVarDecl d = (LocalVarDecl) _symbol_d.value;
					 return _symbol_d;
			}
			case 24: // lst$entity = entity
			{
					ArrayList lst = new ArrayList(); lst.add(_symbols[offset + 1].value); return new Symbol(lst);
			}
			case 25: // lst$entity = lst$entity entity
			{
					((ArrayList) _symbols[offset + 1].value).add(_symbols[offset + 2].value); return _symbols[offset + 1];
			}
			case 28: // entities = ENTITIES opt$lst$entity.l
			{
					final Symbol _symbol_l = _symbols[offset + 2];
					final ArrayList _list_l = (ArrayList) _symbol_l.value;
					final java.util.Map.Entry[] l = _list_l == null ? new java.util.Map.Entry[0] : (java.util.Map.Entry[]) _list_l.toArray(new java.util.Map.Entry[_list_l.size()]);
					 return _symbol_l;
			}
			case 29: // entity = IDENTIFIER.ID EQ entity_expr.e SEMICOLON
			{
					final Symbol ID = _symbols[offset + 1];
					final Symbol _symbol_e = _symbols[offset + 3];
					final EntityExpr e = (EntityExpr) _symbol_e.value;
					 return new Symbol(new java.util.AbstractMap.SimpleEntry((String)ID.value, e));
			}
			case 34: // entity_expr = IDENTIFIER.id LPAREN opt$param_assign_list.l RPAREN.end opt$tool_attribute_block.a
			{
					final Symbol id = _symbols[offset + 1];
					final Symbol _symbol_l = _symbols[offset + 3];
					final ImmutableList.Builder l = (ImmutableList.Builder) _symbol_l.value;
					final Symbol end = _symbols[offset + 4];
					final Symbol _symbol_a = _symbols[offset + 5];
					final ImmutableList a = (ImmutableList) _symbol_a.value;
					 return register(id, end, new EntityInstanceExpr((String)id.value, l == null ? null : l.build(), a));
			}
			case 35: // entity_expr = IF.start expression.e THEN entity_expr.t ELSE entity_expr.f end_if.end
			{
					final Symbol start = _symbols[offset + 1];
					final Symbol _symbol_e = _symbols[offset + 2];
					final Expression e = (Expression) _symbol_e.value;
					final Symbol _symbol_t = _symbols[offset + 4];
					final EntityExpr t = (EntityExpr) _symbol_t.value;
					final Symbol _symbol_f = _symbols[offset + 6];
					final EntityExpr f = (EntityExpr) _symbol_f.value;
					final Symbol end = _symbols[offset + 7];
					 return register(start, end, new EntityIfExpr(e, t, f));
			}
			case 38: // entity_expr = LBRACK.start opt$entity_expr_list.e RBRACK.end
			{
					final Symbol start = _symbols[offset + 1];
					final Symbol _symbol_e = _symbols[offset + 2];
					final ImmutableList.Builder e = (ImmutableList.Builder) _symbol_e.value;
					final Symbol end = _symbols[offset + 3];
					 return register(start, end, new EntityListExpr(e==null ? null : e.build(), null));
			}
			case 39: // entity_expr = LBRACK.start entity_expr_list.e COLON for_generator_list.g RBRACK.end
			{
					final Symbol start = _symbols[offset + 1];
					final Symbol _symbol_e = _symbols[offset + 2];
					final ImmutableList.Builder e = (ImmutableList.Builder) _symbol_e.value;
					final Symbol _symbol_g = _symbols[offset + 4];
					final ImmutableList.Builder g = (ImmutableList.Builder) _symbol_g.value;
					final Symbol end = _symbols[offset + 5];
					 return register(start, end, new EntityListExpr(e.build(), g.build()));
			}
			case 40: // param_assign_list = param_assign.p
			{
					final Symbol _symbol_p = _symbols[offset + 1];
					final Map.Entry p = (Map.Entry) _symbol_p.value;
					 return new Symbol(ImmutableList.builder().add(p));
			}
			case 41: // param_assign_list = param_assign_list.l COMMA param_assign.p
			{
					final Symbol _symbol_l = _symbols[offset + 1];
					final ImmutableList.Builder l = (ImmutableList.Builder) _symbol_l.value;
					final Symbol _symbol_p = _symbols[offset + 3];
					final Map.Entry p = (Map.Entry) _symbol_p.value;
					 l.add(p); return _symbol_l;
			}
			case 42: // entity_expr_list = entity_expr.e
			{
					final Symbol _symbol_e = _symbols[offset + 1];
					final EntityExpr e = (EntityExpr) _symbol_e.value;
					 return new Symbol(ImmutableList.builder().add(e));
			}
			case 43: // entity_expr_list = entity_expr_list.l COMMA entity_expr.e
			{
					final Symbol _symbol_l = _symbols[offset + 1];
					final ImmutableList.Builder l = (ImmutableList.Builder) _symbol_l.value;
					final Symbol _symbol_e = _symbols[offset + 3];
					final EntityExpr e = (EntityExpr) _symbol_e.value;
					 l.add(e); return _symbol_l;
			}
			case 44: // param_assign = IDENTIFIER.ID EQ expression.expression
			{
					final Symbol ID = _symbols[offset + 1];
					final Symbol _symbol_expression = _symbols[offset + 3];
					final Expression expression = (Expression) _symbol_expression.value;
					 return new Symbol(new java.util.AbstractMap.SimpleEntry((String)ID.value, expression));
			}
			case 45: // lst$entity_statement = entity_statement
			{
					ArrayList lst = new ArrayList(); lst.add(_symbols[offset + 1].value); return new Symbol(lst);
			}
			case 46: // lst$entity_statement = lst$entity_statement entity_statement
			{
					((ArrayList) _symbols[offset + 1].value).add(_symbols[offset + 2].value); return _symbols[offset + 1];
			}
			case 49: // structure = STRUCTURE opt$lst$entity_statement.l
			{
					final Symbol _symbol_l = _symbols[offset + 2];
					final ArrayList _list_l = (ArrayList) _symbol_l.value;
					final StructureStatement[] l = _list_l == null ? new StructureStatement[0] : (StructureStatement[]) _list_l.toArray(new StructureStatement[_list_l.size()]);
					 return _symbol_l;
			}
			case 50: // entity_statement = entity_port.src EDGE entity_port.dst opt$tool_attribute_block.a SEMICOLON.end
			{
					final Symbol _symbol_src = _symbols[offset + 1];
					final PortReference src = (PortReference) _symbol_src.value;
					final Symbol _symbol_dst = _symbols[offset + 3];
					final PortReference dst = (PortReference) _symbol_dst.value;
					final Symbol _symbol_a = _symbols[offset + 4];
					final ImmutableList a = (ImmutableList) _symbol_a.value;
					final Symbol end = _symbols[offset + 5];
					 return register(src, end, new StructureConnectionStmt(src, dst, a==null ? null : a));
			}
			case 51: // entity_statement = for_generator_list.g DO.doSymbol opt$lst$entity_statement.s END.end
			{
					final Symbol _symbol_g = _symbols[offset + 1];
					final ImmutableList.Builder g = (ImmutableList.Builder) _symbol_g.value;
					final Symbol doSymbol = _symbols[offset + 2];
					final Symbol _symbol_s = _symbols[offset + 3];
					final ArrayList _list_s = (ArrayList) _symbol_s.value;
					final StructureStatement[] s = _list_s == null ? new StructureStatement[0] : (StructureStatement[]) _list_s.toArray(new StructureStatement[_list_s.size()]);
					final Symbol end = _symbols[offset + 4];
					 ImmutableList<GeneratorFilter> genList = g.build();
                                                                                                 if(genList.isEmpty()){
                                                                                                   return register(doSymbol, end, new StructureForeachStmt(genList, ImmutableList.copyOf(s)));
                                                                                                 } else {
                                                                                                   return register(genList.get(0), end, new StructureForeachStmt(genList, ImmutableList.copyOf(s)));
                                                                                                 }
			}
			case 52: // entity_statement = IF.start expression.e THEN opt$lst$entity_statement.t_stmt END.end
			{
					final Symbol start = _symbols[offset + 1];
					final Symbol _symbol_e = _symbols[offset + 2];
					final Expression e = (Expression) _symbol_e.value;
					final Symbol _symbol_t_stmt = _symbols[offset + 4];
					final ArrayList _list_t_stmt = (ArrayList) _symbol_t_stmt.value;
					final StructureStatement[] t_stmt = _list_t_stmt == null ? new StructureStatement[0] : (StructureStatement[]) _list_t_stmt.toArray(new StructureStatement[_list_t_stmt.size()]);
					final Symbol end = _symbols[offset + 5];
					 return register(start, end, new StructureIfStmt(e, ImmutableList.copyOf(t_stmt), null));
			}
			case 53: // entity_statement = IF.start expression.e THEN opt$lst$entity_statement.t_stmt ELSE opt$lst$entity_statement.f_stmt END.end
			{
					final Symbol start = _symbols[offset + 1];
					final Symbol _symbol_e = _symbols[offset + 2];
					final Expression e = (Expression) _symbol_e.value;
					final Symbol _symbol_t_stmt = _symbols[offset + 4];
					final ArrayList _list_t_stmt = (ArrayList) _symbol_t_stmt.value;
					final StructureStatement[] t_stmt = _list_t_stmt == null ? new StructureStatement[0] : (StructureStatement[]) _list_t_stmt.toArray(new StructureStatement[_list_t_stmt.size()]);
					final Symbol _symbol_f_stmt = _symbols[offset + 6];
					final ArrayList _list_f_stmt = (ArrayList) _symbol_f_stmt.value;
					final StructureStatement[] f_stmt = _list_f_stmt == null ? new StructureStatement[0] : (StructureStatement[]) _list_f_stmt.toArray(new StructureStatement[_list_f_stmt.size()]);
					final Symbol end = _symbols[offset + 7];
					 return register(start, end, new StructureIfStmt(e, ImmutableList.copyOf(t_stmt), ImmutableList.copyOf(f_stmt)));
			}
			case 54: // lst$entity_indexing = entity_indexing
			{
					ArrayList lst = new ArrayList(); lst.add(_symbols[offset + 1].value); return new Symbol(lst);
			}
			case 55: // lst$entity_indexing = lst$entity_indexing entity_indexing
			{
					((ArrayList) _symbols[offset + 1].value).add(_symbols[offset + 2].value); return _symbols[offset + 1];
			}
			case 58: // entity_port = IDENTIFIER.id_port opt$lst$entity_indexing.index_port
			{
					final Symbol id_port = _symbols[offset + 1];
					final Symbol _symbol_index_port = _symbols[offset + 2];
					final ArrayList _list_index_port = (ArrayList) _symbol_index_port.value;
					final Expression[] index_port = _list_index_port == null ? new Expression[0] : (Expression[]) _list_index_port.toArray(new Expression[_list_index_port.size()]);
					 warnPortIndex(index_port); return register(id_port, id_port, new PortReference(null, null, (String)id_port.value));
			}
			case 59: // entity_port = IDENTIFIER.id_entity opt$lst$entity_indexing.index_entity DOT IDENTIFIER.id_port opt$lst$entity_indexing.index_port
			{
					final Symbol id_entity = _symbols[offset + 1];
					final Symbol _symbol_index_entity = _symbols[offset + 2];
					final ArrayList _list_index_entity = (ArrayList) _symbol_index_entity.value;
					final Expression[] index_entity = _list_index_entity == null ? new Expression[0] : (Expression[]) _list_index_entity.toArray(new Expression[_list_index_entity.size()]);
					final Symbol id_port = _symbols[offset + 4];
					final Symbol _symbol_index_port = _symbols[offset + 5];
					final ArrayList _list_index_port = (ArrayList) _symbol_index_port.value;
					final Expression[] index_port = _list_index_port == null ? new Expression[0] : (Expression[]) _list_index_port.toArray(new Expression[_list_index_port.size()]);
					 warnPortIndex(index_port); return register(id_entity, id_port, new PortReference((String)id_entity.value, ImmutableList.copyOf(index_entity) , (String)id_port.value));
			}
			case 60: // entity_indexing = LBRACK.LBRACK expression.e RBRACK.RBRACK
			{
					final Symbol LBRACK = _symbols[offset + 1];
					final Symbol _symbol_e = _symbols[offset + 2];
					final Expression e = (Expression) _symbol_e.value;
					final Symbol RBRACK = _symbols[offset + 3];
					 return _symbol_e;
			}
			case 61: // import_part = import_single.i
			{
					final Symbol _symbol_i = _symbols[offset + 1];
					final ArrayList i = (ArrayList) _symbol_i.value;
					 return _symbol_i;
			}
			case 62: // import_part = import_group.i
			{
					final Symbol _symbol_i = _symbols[offset + 1];
					final ArrayList i = (ArrayList) _symbol_i.value;
					 return _symbol_i;
			}
			case 63: // import_single = IMPORT import_kind.k qual_id.qual_id SEMICOLON
			{
					final Symbol k = _symbols[offset + 2];
					final Symbol _symbol_qual_id = _symbols[offset + 3];
					final ArrayList qual_id = (ArrayList) _symbol_qual_id.value;
					 return new Symbol(qual_id);
			}
			case 64: // import_single = IMPORT import_kind.k qual_id.qual_id EQ IDENTIFIER.alias SEMICOLON
			{
					final Symbol k = _symbols[offset + 2];
					final Symbol _symbol_qual_id = _symbols[offset + 3];
					final ArrayList qual_id = (ArrayList) _symbol_qual_id.value;
					final Symbol alias = _symbols[offset + 5];
					 return new Symbol(qual_id);
			}
			case 65: // import_group = IMPORT import_kind.k ALL qual_id.qual_id SEMICOLON
			{
					final Symbol k = _symbols[offset + 2];
					final Symbol _symbol_qual_id = _symbols[offset + 4];
					final ArrayList qual_id = (ArrayList) _symbol_qual_id.value;
					 return new Symbol(qual_id);
			}
			case 66: // import_kind = 
			{
					 return new Symbol("");
			}
			case 67: // import_kind = ENTITY.kind
			{
					final Symbol kind = _symbols[offset + 1];
					 return kind;
			}
			case 68: // import_kind = VAR.kind
			{
					final Symbol kind = _symbols[offset + 1];
					 return kind;
			}
			case 69: // lst$tool_attribute = tool_attribute
			{
					ArrayList lst = new ArrayList(); lst.add(_symbols[offset + 1].value); return new Symbol(lst);
			}
			case 70: // lst$tool_attribute = lst$tool_attribute tool_attribute
			{
					((ArrayList) _symbols[offset + 1].value).add(_symbols[offset + 2].value); return _symbols[offset + 1];
			}
			case 73: // tool_attribute_block = LBRACE opt$lst$tool_attribute.a RBRACE
			{
					final Symbol _symbol_a = _symbols[offset + 2];
					final ArrayList _list_a = (ArrayList) _symbol_a.value;
					final ToolAttribute[] a = _list_a == null ? new ToolAttribute[0] : (ToolAttribute[]) _list_a.toArray(new ToolAttribute[_list_a.size()]);
					 return new Symbol(ImmutableList.builder().addAll(a).build());
			}
			case 74: // tool_attribute = IDENTIFIER.ID EQ expression.expression SEMICOLON.end
			{
					final Symbol ID = _symbols[offset + 1];
					final Symbol _symbol_expression = _symbols[offset + 3];
					final Expression expression = (Expression) _symbol_expression.value;
					final Symbol end = _symbols[offset + 4];
					 return register(ID, end, new ToolValueAttribute((String)ID.value, expression));
			}
			case 75: // tool_attribute = IDENTIFIER.ID COLON type.type SEMICOLON.end
			{
					final Symbol ID = _symbols[offset + 1];
					final Symbol _symbol_type = _symbols[offset + 3];
					final TypeExpr type = (TypeExpr) _symbol_type.value;
					final Symbol end = _symbols[offset + 4];
					 return register(ID, end, new ToolTypeAttribute((String)ID.value, type));
			}
			case 78: // actor_parameter_list = actor_parameter.p
			{
					final Symbol _symbol_p = _symbols[offset + 1];
					final ParDeclValue p = (ParDeclValue) _symbol_p.value;
					 return new Symbol(ImmutableList.builder().add(p));
			}
			case 79: // actor_parameter_list = actor_parameter_list.l COMMA actor_parameter.p
			{
					final Symbol _symbol_l = _symbols[offset + 1];
					final ImmutableList.Builder l = (ImmutableList.Builder) _symbol_l.value;
					final Symbol _symbol_p = _symbols[offset + 3];
					final ParDeclValue p = (ParDeclValue) _symbol_p.value;
					 l.add(p); return _symbol_l;
			}
			case 82: // actor_parameter = IDENTIFIER.id opt$actor_parameter_init_expression.e
			{
					final Symbol id = _symbols[offset + 1];
					final Symbol _symbol_e = _symbols[offset + 2];
					final Expression e = (Expression) _symbol_e.value;
					 ParDeclValue decl = new ParDeclValue((String)id.value, null);
                                                               Symbol result = register(id, id, decl);
                                                               if(e != null){ register(id, e, decl); em.warning("default value for parameter " + (String)id.value + " is ignored.", decl);}; 
                                                               return result;
			}
			case 83: // actor_parameter = type.t IDENTIFIER.id opt$actor_parameter_init_expression.e
			{
					final Symbol _symbol_t = _symbols[offset + 1];
					final TypeExpr t = (TypeExpr) _symbol_t.value;
					final Symbol id = _symbols[offset + 2];
					final Symbol _symbol_e = _symbols[offset + 3];
					final Expression e = (Expression) _symbol_e.value;
					 ParDecl decl = new ParDeclValue((String)id.value, t);
                                                               Symbol result = register(t, id, decl);
                                                               if(e != null){ register(t, e, decl); em.warning("default value for parameter " + (String)id.value + " is ignored.", decl);}; 
                                                               return result;
			}
			case 84: // actor_parameter_init_expression = EQ expression.e
			{
					final Symbol _symbol_e = _symbols[offset + 2];
					final Expression e = (Expression) _symbol_e.value;
					 return _symbol_e;
			}
			case 85: // qual_id = IDENTIFIER.id
			{
					final Symbol id = _symbols[offset + 1];
					 ArrayList l = new ArrayList(); l.add(id.value); return new Symbol(id.getId(), id.getStart(), id.getEnd(), l);
			}
			case 86: // qual_id = IDENTIFIER.id DOT qual_id.l
			{
					final Symbol id = _symbols[offset + 1];
					final Symbol _symbol_l = _symbols[offset + 3];
					final ArrayList l = (ArrayList) _symbol_l.value;
					 l.add(0, id.value); return new Symbol(id.getId(), id.getStart(), _symbol_l.getEnd(), l);
			}
			case 87: // variable = IDENTIFIER.id
			{
					final Symbol id = _symbols[offset + 1];
					 return register(id, id, Variable.variable((String) id.value));
			}
			case 88: // field = IDENTIFIER.id
			{
					final Symbol id = _symbols[offset + 1];
					 return register(id, id, new Field((String) id.value));
			}
			case 89: // decl_list = decl.d
			{
					final Symbol _symbol_d = _symbols[offset + 1];
					final LocalVarDecl d = (LocalVarDecl) _symbol_d.value;
					 return new Symbol(ImmutableList.builder().add(d));
			}
			case 90: // decl_list = decl_list.l COMMA decl.d
			{
					final Symbol _symbol_l = _symbols[offset + 1];
					final ImmutableList.Builder l = (ImmutableList.Builder) _symbol_l.value;
					final Symbol _symbol_d = _symbols[offset + 3];
					final LocalVarDecl d = (LocalVarDecl) _symbol_d.value;
					 l.add(d); return _symbol_l;
			}
			case 91: // decl_block = VAR decl_list.d
			{
					final Symbol _symbol_d = _symbols[offset + 2];
					final ImmutableList.Builder d = (ImmutableList.Builder) _symbol_d.value;
					 return new Symbol(d.build());
			}
			case 92: // decl_block_opt = 
			{
					 return new Symbol(ImmutableList.empty());
			}
			case 93: // decl_block_opt = VAR decl_list.d
			{
					final Symbol _symbol_d = _symbols[offset + 2];
					final ImmutableList.Builder d = (ImmutableList.Builder) _symbol_d.value;
					 return new Symbol(d.build());
			}
			case 94: // decl = var_decl.d
			{
					final Symbol _symbol_d = _symbols[offset + 1];
					final LocalVarDecl d = (LocalVarDecl) _symbol_d.value;
					 return _symbol_d;
			}
			case 95: // decl = fun_decl.d
			{
					final Symbol _symbol_d = _symbols[offset + 1];
					final LocalVarDecl d = (LocalVarDecl) _symbol_d.value;
					 return _symbol_d;
			}
			case 96: // decl = proc_decl.d
			{
					final Symbol _symbol_d = _symbols[offset + 1];
					final LocalVarDecl d = (LocalVarDecl) _symbol_d.value;
					 return _symbol_d;
			}
			case 97: // var_decl = MUTABLE.m var_name_type.v
			{
					final Symbol m = _symbols[offset + 1];
					final Symbol _symbol_v = _symbols[offset + 2];
					final LocalVarDecl v = (LocalVarDecl) _symbol_v.value;
					 em.warning("mutable is ignored for " + v.getName(), v); 
                                                         register(m, v, v);
                                                         return _symbol_v;
			}
			case 98: // var_decl = MUTABLE.m var_name_type.v EQ expression.init
			{
					final Symbol m = _symbols[offset + 1];
					final Symbol _symbol_v = _symbols[offset + 2];
					final LocalVarDecl v = (LocalVarDecl) _symbol_v.value;
					final Symbol _symbol_init = _symbols[offset + 4];
					final Expression init = (Expression) _symbol_init.value;
					 em.warning("mutable is ignored for " + v.getName(), v);
                                                         return register(m, init, v.copy(v.getType(), v.getName(), init, false));
			}
			case 99: // var_decl = MUTABLE.m var_name_type.v COLONEQ expression.init
			{
					final Symbol m = _symbols[offset + 1];
					final Symbol _symbol_v = _symbols[offset + 2];
					final LocalVarDecl v = (LocalVarDecl) _symbol_v.value;
					final Symbol _symbol_init = _symbols[offset + 4];
					final Expression init = (Expression) _symbol_init.value;
					 em.warning("mutable is ignored for " + v.getName(), v);
                                                         return register(m, init, v.copy(v.getType(), v.getName(), init, true));
			}
			case 100: // var_decl = var_name_type.v
			{
					final Symbol _symbol_v = _symbols[offset + 1];
					final LocalVarDecl v = (LocalVarDecl) _symbol_v.value;
					 return _symbol_v;
			}
			case 101: // var_decl = var_name_type.v EQ expression.init
			{
					final Symbol _symbol_v = _symbols[offset + 1];
					final LocalVarDecl v = (LocalVarDecl) _symbol_v.value;
					final Symbol _symbol_init = _symbols[offset + 3];
					final Expression init = (Expression) _symbol_init.value;
					 return register(v, init, v.copy(v.getType(), v.getName(), init, false));
			}
			case 102: // var_decl = var_name_type.v COLONEQ expression.init
			{
					final Symbol _symbol_v = _symbols[offset + 1];
					final LocalVarDecl v = (LocalVarDecl) _symbol_v.value;
					final Symbol _symbol_init = _symbols[offset + 3];
					final Expression init = (Expression) _symbol_init.value;
					 return register(v, init, v.copy(v.getType(), v.getName(), init, true));
			}
			case 103: // var_name_type = IDENTIFIER.id
			{
					final Symbol id = _symbols[offset + 1];
					 return register(id, id, new LocalVarDecl(null, (String)id.value, null, true));
			}
			case 104: // var_name_type = type.type IDENTIFIER.id
			{
					final Symbol _symbol_type = _symbols[offset + 1];
					final TypeExpr type = (TypeExpr) _symbol_type.value;
					final Symbol id = _symbols[offset + 2];
					 return register(id, id, new LocalVarDecl(type, (String)id.value, null, true));
			}
			case 105: // fun_decl = FUNCTION.start IDENTIFIER.id lambda_expr_body.lambda
			{
					final Symbol start = _symbols[offset + 1];
					final Symbol id = _symbols[offset + 2];
					final Symbol _symbol_lambda = _symbols[offset + 3];
					final ExprLambda lambda = (ExprLambda) _symbol_lambda.value;
					 register(start, lambda, lambda); return register(start, lambda, new LocalVarDecl(null, (String)id.value, lambda, false));
			}
			case 106: // proc_decl = PROCEDURE.start IDENTIFIER.id procedure_expr_body.body
			{
					final Symbol start = _symbols[offset + 1];
					final Symbol id = _symbols[offset + 2];
					final Symbol _symbol_body = _symbols[offset + 3];
					final ExprProc body = (ExprProc) _symbol_body.value;
					 register(start, body, body); return register(start, body, new LocalVarDecl(null, (String)id.value, body, false));
			}
			case 107: // port_decl = IDENTIFIER.id
			{
					final Symbol id = _symbols[offset + 1];
					 return register(id, id, new PortDecl((String)id.value, null));
			}
			case 108: // port_decl = type.type IDENTIFIER.id
			{
					final Symbol _symbol_type = _symbols[offset + 1];
					final TypeExpr type = (TypeExpr) _symbol_type.value;
					final Symbol id = _symbols[offset + 2];
					 return register(type, id, new PortDecl((String)id.value, type));
			}
			case 109: // port_decl = MULTI.m IDENTIFIER.id
			{
					final Symbol m = _symbols[offset + 1];
					final Symbol id = _symbols[offset + 2];
					 em.warning("multi is ignored for " + (String)id.value, null);
                                       return register(m, id, new PortDecl((String)id.value, null));
			}
			case 110: // port_decl = MULTI.m type.type IDENTIFIER.id
			{
					final Symbol m = _symbols[offset + 1];
					final Symbol _symbol_type = _symbols[offset + 2];
					final TypeExpr type = (TypeExpr) _symbol_type.value;
					final Symbol id = _symbols[offset + 3];
					 em.warning("multi is ignored for " + (String)id.value, null);
                                       return register(m, id, new PortDecl((String)id.value, type));
			}
			case 111: // port_decl_list_opt = 
			{
					 return new Symbol(null);
			}
			case 112: // port_decl_list_opt = port_decl_list.l
			{
					final Symbol _symbol_l = _symbols[offset + 1];
					final ImmutableList.Builder l = (ImmutableList.Builder) _symbol_l.value;
					 return new Symbol(l.build());
			}
			case 113: // port_decl_list = port_decl.port_decl
			{
					final Symbol _symbol_port_decl = _symbols[offset + 1];
					final PortDecl port_decl = (PortDecl) _symbol_port_decl.value;
					 return new Symbol(ImmutableList.builder().add(port_decl));
			}
			case 114: // port_decl_list = port_decl_list.l COMMA port_decl.d
			{
					final Symbol _symbol_l = _symbols[offset + 1];
					final ImmutableList.Builder l = (ImmutableList.Builder) _symbol_l.value;
					final Symbol _symbol_d = _symbols[offset + 3];
					final PortDecl d = (PortDecl) _symbol_d.value;
					 l.add(d); return _symbol_l;
			}
			case 115: // type_bound = LT type.type
			{
					final Symbol _symbol_type = _symbols[offset + 2];
					final TypeExpr type = (TypeExpr) _symbol_type.value;
					 return _symbol_type;
			}
			case 116: // type_bound_opt = 
			{
					 return new Symbol(null);
			}
			case 117: // type_bound_opt = type_bound.n
			{
					final Symbol _symbol_n = _symbols[offset + 1];
					final TypeExpr n = (TypeExpr) _symbol_n.value;
					 return _symbol_n;
			}
			case 118: // type_parameter = IDENTIFIER.id type_bound_opt.type_bound
			{
					final Symbol id = _symbols[offset + 1];
					final Symbol _symbol_type_bound = _symbols[offset + 2];
					final TypeExpr type_bound = (TypeExpr) _symbol_type_bound.value;
					 ParDeclType decl = new ParDeclType((String)id.value);
                                               Symbol result;
                                               if(type_bound == null){
                                                 result = register(id, id, decl);
                                               } else {
                                                 em.warning("type bound is ignored", type_bound);
                                                 result = register(id, type_bound, decl);
                                               }
                                               return result;
			}
			case 121: // type_parameter_block = LBRACK opt$type_parameter_list.l RBRACK
			{
					final Symbol _symbol_l = _symbols[offset + 2];
					final ImmutableList.Builder l = (ImmutableList.Builder) _symbol_l.value;
					 return new Symbol(l == null ? null : l.build());
			}
			case 122: // type_parameter_list = type_parameter.tp
			{
					final Symbol _symbol_tp = _symbols[offset + 1];
					final ParDeclType tp = (ParDeclType) _symbol_tp.value;
					 return new Symbol(ImmutableList.builder().add(tp));
			}
			case 123: // type_parameter_list = type_parameter_list.l COMMA type_parameter.tp
			{
					final Symbol _symbol_l = _symbols[offset + 1];
					final ImmutableList.Builder l = (ImmutableList.Builder) _symbol_l.value;
					final Symbol _symbol_tp = _symbols[offset + 3];
					final ParDeclType tp = (ParDeclType) _symbol_tp.value;
					 l.add(tp); return _symbol_l;
			}
			case 124: // type_list = type.t
			{
					final Symbol _symbol_t = _symbols[offset + 1];
					final TypeExpr t = (TypeExpr) _symbol_t.value;
					 return new Symbol(ImmutableList.builder().add(t));
			}
			case 125: // type_list = type_list.l COMMA type.t
			{
					final Symbol _symbol_l = _symbols[offset + 1];
					final ImmutableList.Builder l = (ImmutableList.Builder) _symbol_l.value;
					final Symbol _symbol_t = _symbols[offset + 3];
					final TypeExpr t = (TypeExpr) _symbol_t.value;
					 l.add(t); return _symbol_l;
			}
			case 126: // type = IDENTIFIER.id
			{
					final Symbol id = _symbols[offset + 1];
					 return register(id, id, new TypeExpr((String)id.value));
			}
			case 129: // type = IDENTIFIER.id LPAREN opt$type_attribute_list.attributes RPAREN.end
			{
					final Symbol id = _symbols[offset + 1];
					final Symbol _symbol_attributes = _symbols[offset + 3];
					final ArrayList attributes = (ArrayList) _symbol_attributes.value;
					final Symbol end = _symbols[offset + 4];
					 ImmutableList.Builder valueParameters = ImmutableList.builder();
                             ImmutableList.Builder typeParameters = ImmutableList.builder();
                             for(Map.Entry map : (ArrayList<Map.Entry>)attributes){
                               if(map.getValue() instanceof Expression){
                                 valueParameters.add(ImmutableEntry.of(map.getKey(), map.getValue()));
                               } else {
                                 typeParameters.add(ImmutableEntry.of(map.getKey(), map.getValue()));
                               }
                             }
                             return register(id, end, new TypeExpr((String)id.value, typeParameters.build(), valueParameters.build()));
			}
			case 132: // type = LBRACK.l opt$type_list.param EDGE type.result_type RBRACK.e
			{
					final Symbol l = _symbols[offset + 1];
					final Symbol _symbol_param = _symbols[offset + 2];
					final ImmutableList.Builder param = (ImmutableList.Builder) _symbol_param.value;
					final Symbol _symbol_result_type = _symbols[offset + 4];
					final TypeExpr result_type = (TypeExpr) _symbol_result_type.value;
					final Symbol e = _symbols[offset + 5];
					 warning("types involving -> is not supported", l, e); return new Symbol(null);
			}
			case 133: // type = LBRACK.l opt$type_list.param EDGE RBRACK.e
			{
					final Symbol l = _symbols[offset + 1];
					final Symbol _symbol_param = _symbols[offset + 2];
					final ImmutableList.Builder param = (ImmutableList.Builder) _symbol_param.value;
					final Symbol e = _symbols[offset + 4];
					 warning("types involving -> is not supported", l, e); return new Symbol(null);
			}
			case 134: // type_attribute_list = type_attribute.t
			{
					final Symbol _symbol_t = _symbols[offset + 1];
					final Map.Entry t = (Map.Entry) _symbol_t.value;
					 ArrayList l = new ArrayList(); l.add(t); return new Symbol(l);
			}
			case 135: // type_attribute_list = type_attribute_list.l COMMA type_attribute.t
			{
					final Symbol _symbol_l = _symbols[offset + 1];
					final ArrayList l = (ArrayList) _symbol_l.value;
					final Symbol _symbol_t = _symbols[offset + 3];
					final Map.Entry t = (Map.Entry) _symbol_t.value;
					 l.add(t); return _symbol_l;
			}
			case 136: // type_attribute = IDENTIFIER.id COLON type.type
			{
					final Symbol id = _symbols[offset + 1];
					final Symbol _symbol_type = _symbols[offset + 3];
					final TypeExpr type = (TypeExpr) _symbol_type.value;
					 return new Symbol(new AbstractMap.SimpleEntry((String)id.value, type));
			}
			case 137: // type_attribute = IDENTIFIER.id EQ expression.e
			{
					final Symbol id = _symbols[offset + 1];
					final Symbol _symbol_e = _symbols[offset + 3];
					final Expression e = (Expression) _symbol_e.value;
					 return new Symbol(new AbstractMap.SimpleEntry((String)id.value, e));
			}
			case 138: // edge_type = EDGE type.t
			{
					final Symbol _symbol_t = _symbols[offset + 2];
					final TypeExpr t = (TypeExpr) _symbol_t.value;
					 return _symbol_t;
			}
			case 143: // procedure_expr_body = LPAREN.start opt$formal_parameter_list.param RPAREN opt$decl_block.decl stmt_block_opt.body end_proc.end
			{
					final Symbol start = _symbols[offset + 1];
					final Symbol _symbol_param = _symbols[offset + 2];
					final ImmutableList.Builder param = (ImmutableList.Builder) _symbol_param.value;
					final Symbol _symbol_decl = _symbols[offset + 4];
					final ImmutableList decl = (ImmutableList) _symbol_decl.value;
					final Symbol _symbol_body = _symbols[offset + 5];
					final ImmutableList body = (ImmutableList) _symbol_body.value;
					final Symbol end = _symbols[offset + 6];
					  return register(start, end,
            new ExprProc(
              ImmutableList.<ParDeclType>empty(), 
              param==null ? ImmutableList.empty() : param.build(),
              new StmtBlock(null, decl, body)
            )
          );
			}
			case 144: // stmt_block_opt = 
			{
					 return new Symbol(ImmutableList.empty());
			}
			case 145: // stmt_block_opt = do_begin statement_list_opt.s
			{
					final Symbol _symbol_s = _symbols[offset + 2];
					final ImmutableList s = (ImmutableList) _symbol_s.value;
					 return _symbol_s;
			}
			case 146: // lambda_expr_body = LPAREN.s opt$formal_parameter_list.param RPAREN expression.body end_lambda.e
			{
					final Symbol s = _symbols[offset + 1];
					final Symbol _symbol_param = _symbols[offset + 2];
					final ImmutableList.Builder param = (ImmutableList.Builder) _symbol_param.value;
					final Symbol _symbol_body = _symbols[offset + 4];
					final Expression body = (Expression) _symbol_body.value;
					final Symbol e = _symbols[offset + 5];
					 return register(s, e, new ExprLambda(ImmutableList.<ParDeclType>empty(),
                                             param==null ? null : param.build(),
                                             body,
                                             null));
			}
			case 147: // lambda_expr_body = LPAREN.s opt$formal_parameter_list.param RPAREN opt$decl_block.decl COLON expression.body end_lambda.e
			{
					final Symbol s = _symbols[offset + 1];
					final Symbol _symbol_param = _symbols[offset + 2];
					final ImmutableList.Builder param = (ImmutableList.Builder) _symbol_param.value;
					final Symbol _symbol_decl = _symbols[offset + 4];
					final ImmutableList decl = (ImmutableList) _symbol_decl.value;
					final Symbol _symbol_body = _symbols[offset + 6];
					final Expression body = (Expression) _symbol_body.value;
					final Symbol e = _symbols[offset + 7];
					 return register(s, e, new ExprLambda(ImmutableList.<ParDeclType>empty(),
                                             param==null ? null : param.build(),
                                             new ExprLet(null, decl, body),
                                             null));
			}
			case 148: // lambda_expr_body = LPAREN.s opt$formal_parameter_list.param RPAREN edge_type.t opt$decl_block.decl COLON expression.body end_lambda.e
			{
					final Symbol s = _symbols[offset + 1];
					final Symbol _symbol_param = _symbols[offset + 2];
					final ImmutableList.Builder param = (ImmutableList.Builder) _symbol_param.value;
					final Symbol _symbol_t = _symbols[offset + 4];
					final TypeExpr t = (TypeExpr) _symbol_t.value;
					final Symbol _symbol_decl = _symbols[offset + 5];
					final ImmutableList decl = (ImmutableList) _symbol_decl.value;
					final Symbol _symbol_body = _symbols[offset + 7];
					final Expression body = (Expression) _symbol_body.value;
					final Symbol e = _symbols[offset + 8];
					 return register(s, e, new ExprLambda(ImmutableList.<ParDeclType>empty(),
                                             param==null ? null : param.build(),
                                             new ExprLet(null, decl, body),
                                             t));
			}
			case 149: // map_list = map_entry.m
			{
					final Symbol _symbol_m = _symbols[offset + 1];
					final Map.Entry m = (Map.Entry) _symbol_m.value;
					 return new Symbol(ImmutableList.builder().add(m));
			}
			case 150: // map_list = map_list.l COMMA map_entry.m
			{
					final Symbol _symbol_l = _symbols[offset + 1];
					final ImmutableList.Builder l = (ImmutableList.Builder) _symbol_l.value;
					final Symbol _symbol_m = _symbols[offset + 3];
					final Map.Entry m = (Map.Entry) _symbol_m.value;
					 l.add(m); return _symbol_l;
			}
			case 151: // map_entry = expression.e1 ARROW expression.e2
			{
					final Symbol _symbol_e1 = _symbols[offset + 1];
					final Expression e1 = (Expression) _symbol_e1.value;
					final Symbol _symbol_e2 = _symbols[offset + 3];
					final Expression e2 = (Expression) _symbol_e2.value;
					 return new Symbol(new ImmutableEntry(e1, e2));
			}
			case 152: // expression_list = expression.e
			{
					final Symbol _symbol_e = _symbols[offset + 1];
					final Expression e = (Expression) _symbol_e.value;
					 return new Symbol(ImmutableList.builder().add(e));
			}
			case 153: // expression_list = expression_list.l COMMA expression.e
			{
					final Symbol _symbol_l = _symbols[offset + 1];
					final ImmutableList.Builder l = (ImmutableList.Builder) _symbol_l.value;
					final Symbol _symbol_e = _symbols[offset + 3];
					final Expression e = (Expression) _symbol_e.value;
					 l.add(e); return _symbol_l;
			}
			case 154: // expression_list_opt = 
			{
					 return new Symbol(ImmutableList.empty());
			}
			case 155: // expression_list_opt = expression_list.n
			{
					final Symbol _symbol_n = _symbols[offset + 1];
					final ImmutableList.Builder n = (ImmutableList.Builder) _symbol_n.value;
					 return new Symbol(n.build());
			}
			case 156: // method_invocation = indexing_expression.function LPAREN expression_list_opt.args RPAREN.end
			{
					final Symbol _symbol_function = _symbols[offset + 1];
					final Expression function = (Expression) _symbol_function.value;
					final Symbol _symbol_args = _symbols[offset + 3];
					final ImmutableList args = (ImmutableList) _symbol_args.value;
					final Symbol end = _symbols[offset + 4];
					 return register(function, end, new ExprApplication(function, args));
			}
			case 157: // literal = INTEGER_LITERAL.txt
			{
					final Symbol txt = _symbols[offset + 1];
					 return register(txt, txt, new ExprLiteral(ExprLiteral.Kind.Integer, ((String)txt.value)));
			}
			case 158: // literal = LONG_LITERAL.txt
			{
					final Symbol txt = _symbols[offset + 1];
					 return register(txt, txt, new ExprLiteral(ExprLiteral.Kind.Integer, ((String)txt.value)));
			}
			case 159: // literal = FLOATING_POINT_LITERAL.txt
			{
					final Symbol txt = _symbols[offset + 1];
					 return register(txt, txt, new ExprLiteral(ExprLiteral.Kind.Real, ((String)txt.value)));
			}
			case 160: // literal = DOUBLE_LITERAL.txt
			{
					final Symbol txt = _symbols[offset + 1];
					 return register(txt, txt, new ExprLiteral(ExprLiteral.Kind.Real, ((String)txt.value)));
			}
			case 161: // literal = TRUE_LITERAL.txt
			{
					final Symbol txt = _symbols[offset + 1];
					 return register(txt, txt, new ExprLiteral(ExprLiteral.Kind.True, ((String)txt.value)));
			}
			case 162: // literal = FALSE_LITERAL.txt
			{
					final Symbol txt = _symbols[offset + 1];
					 return register(txt, txt, new ExprLiteral(ExprLiteral.Kind.False, ((String)txt.value)));
			}
			case 163: // literal = CHARACTER_LITERAL.txt
			{
					final Symbol txt = _symbols[offset + 1];
					 return register(txt, txt, new ExprLiteral(ExprLiteral.Kind.Char, ((String)txt.value)));
			}
			case 164: // literal = STRING_LITERAL.txt
			{
					final Symbol txt = _symbols[offset + 1];
					 return register(txt, txt, new ExprLiteral(ExprLiteral.Kind.String, ((String)txt.value)));
			}
			case 165: // literal = NULL_LITERAL.txt
			{
					final Symbol txt = _symbols[offset + 1];
					 return register(txt, txt, new ExprLiteral(ExprLiteral.Kind.Null, ((String)txt.value)));
			}
			case 166: // primary = literal.l
			{
					final Symbol _symbol_l = _symbols[offset + 1];
					final ExprLiteral l = (ExprLiteral) _symbol_l.value;
					 return _symbol_l;
			}
			case 167: // primary = LPAREN expression.e RPAREN
			{
					final Symbol _symbol_e = _symbols[offset + 2];
					final Expression e = (Expression) _symbol_e.value;
					 return new ParenthesSymbol(_symbol_e);
			}
			case 168: // primary = LPAREN.start expression.e DOUBLECOLON type.t RPAREN.end
			{
					final Symbol start = _symbols[offset + 1];
					final Symbol _symbol_e = _symbols[offset + 2];
					final Expression e = (Expression) _symbol_e.value;
					final Symbol _symbol_t = _symbols[offset + 4];
					final TypeExpr t = (TypeExpr) _symbol_t.value;
					final Symbol end = _symbols[offset + 5];
					 em.warning("Type assertion is not supported. Assertion is ignored at " + Symbol.getLine(start.getStart()) + ", " + Symbol.getColumn(start.getStart()), null); 
                                                               return register(start, end, new ExprLiteral(ExprLiteral.Kind.String, "type assertion"));
			}
			case 169: // simple_expression = primary.p
			{
					final Symbol _symbol_p = _symbols[offset + 1];
					final Expression p = (Expression) _symbol_p.value;
					 return _symbol_p;
			}
			case 170: // simple_expression = variable.v
			{
					final Symbol _symbol_v = _symbols[offset + 1];
					final Variable v = (Variable) _symbol_v.value;
					 return register(v, v, new ExprVariable(v));
			}
			case 171: // simple_expression = OLD.old variable.v
			{
					final Symbol old = _symbols[offset + 1];
					final Symbol _symbol_v = _symbols[offset + 2];
					final Variable v = (Variable) _symbol_v.value;
					 em.warning("old is not supported for " + v.getName() + ", at " + Symbol.getLine(old.getStart()) + ", " + Symbol.getColumn(old.getStart()), null); 
                                                                             return register(v, v, new ExprVariable(v));
			}
			case 172: // simple_expression = IF.s expression.c THEN expression.e1 ELSE expression.e2 END.end
			{
					final Symbol s = _symbols[offset + 1];
					final Symbol _symbol_c = _symbols[offset + 2];
					final Expression c = (Expression) _symbol_c.value;
					final Symbol _symbol_e1 = _symbols[offset + 4];
					final Expression e1 = (Expression) _symbol_e1.value;
					final Symbol _symbol_e2 = _symbols[offset + 6];
					final Expression e2 = (Expression) _symbol_e2.value;
					final Symbol end = _symbols[offset + 7];
					 return register(s, end, new ExprIf(c, e1, e2));
			}
			case 173: // simple_expression = LBRACE.s expression_list_opt.e RBRACE.end
			{
					final Symbol s = _symbols[offset + 1];
					final Symbol _symbol_e = _symbols[offset + 2];
					final ImmutableList e = (ImmutableList) _symbol_e.value;
					final Symbol end = _symbols[offset + 3];
					 return register(s, end, new ExprSet(e));
			}
			case 174: // simple_expression = LBRACE.s expression_list_opt.e COLON for_generator_list.l RBRACE.end
			{
					final Symbol s = _symbols[offset + 1];
					final Symbol _symbol_e = _symbols[offset + 2];
					final ImmutableList e = (ImmutableList) _symbol_e.value;
					final Symbol _symbol_l = _symbols[offset + 4];
					final ImmutableList.Builder l = (ImmutableList.Builder) _symbol_l.value;
					final Symbol end = _symbols[offset + 5];
					 return register(s, end, new ExprSet(e, l.build()));
			}
			case 175: // simple_expression = LBRACK.s expression_list_opt.e RBRACK.end
			{
					final Symbol s = _symbols[offset + 1];
					final Symbol _symbol_e = _symbols[offset + 2];
					final ImmutableList e = (ImmutableList) _symbol_e.value;
					final Symbol end = _symbols[offset + 3];
					 return register(s, end, new ExprList(e));
			}
			case 176: // simple_expression = LBRACK.s expression_list_opt.e COLON for_generator_list.l RBRACK.end
			{
					final Symbol s = _symbols[offset + 1];
					final Symbol _symbol_e = _symbols[offset + 2];
					final ImmutableList e = (ImmutableList) _symbol_e.value;
					final Symbol _symbol_l = _symbols[offset + 4];
					final ImmutableList.Builder l = (ImmutableList.Builder) _symbol_l.value;
					final Symbol end = _symbols[offset + 5];
					 return register(s, end, new ExprList(e, l.build()));
			}
			case 179: // simple_expression = MAP.s LBRACE opt$map_list.m RBRACE.end
			{
					final Symbol s = _symbols[offset + 1];
					final Symbol _symbol_m = _symbols[offset + 3];
					final ImmutableList.Builder m = (ImmutableList.Builder) _symbol_m.value;
					final Symbol end = _symbols[offset + 4];
					 return register(s, end, new ExprMap(m==null? null : m.build()));
			}
			case 180: // simple_expression = MAP.s LBRACE opt$map_list.m COLON for_generator_list.generators RBRACE.end
			{
					final Symbol s = _symbols[offset + 1];
					final Symbol _symbol_m = _symbols[offset + 3];
					final ImmutableList.Builder m = (ImmutableList.Builder) _symbol_m.value;
					final Symbol _symbol_generators = _symbols[offset + 5];
					final ImmutableList.Builder generators = (ImmutableList.Builder) _symbol_generators.value;
					final Symbol end = _symbols[offset + 6];
					 return register(s, end, new ExprMap(m==null? null : m.build(), generators.build()));
			}
			case 181: // simple_expression = LET.s decl_list.l COLON expression.e end_let.end
			{
					final Symbol s = _symbols[offset + 1];
					final Symbol _symbol_l = _symbols[offset + 2];
					final ImmutableList.Builder l = (ImmutableList.Builder) _symbol_l.value;
					final Symbol _symbol_e = _symbols[offset + 4];
					final Expression e = (Expression) _symbol_e.value;
					final Symbol end = _symbols[offset + 5];
					 return register(s, end, new ExprLet(null, l.build(), e));
			}
			case 182: // simple_expression = LAMBDA.start lambda_expr_body.lambda
			{
					final Symbol start = _symbols[offset + 1];
					final Symbol _symbol_lambda = _symbols[offset + 2];
					final ExprLambda lambda = (ExprLambda) _symbol_lambda.value;
					 return register(start, lambda, lambda);
			}
			case 183: // simple_expression = CONST.start LAMBDA lambda_expr_body.lambda
			{
					final Symbol start = _symbols[offset + 1];
					final Symbol _symbol_lambda = _symbols[offset + 3];
					final ExprLambda lambda = (ExprLambda) _symbol_lambda.value;
					 register(start, lambda, lambda); 
                                                                             em.warning("const is ignored in lambda expression", lambda); 
                                                                             return _symbol_lambda;
			}
			case 184: // simple_expression = PROC.start procedure_expr_body.p
			{
					final Symbol start = _symbols[offset + 1];
					final Symbol _symbol_p = _symbols[offset + 2];
					final ExprProc p = (ExprProc) _symbol_p.value;
					 return register(start, p, p);
			}
			case 185: // indexing_expression = simple_expression.e
			{
					final Symbol _symbol_e = _symbols[offset + 1];
					final Expression e = (Expression) _symbol_e.value;
					 return _symbol_e;
			}
			case 186: // indexing_expression = indexer.i
			{
					final Symbol i = _symbols[offset + 1];
					 return i;
			}
			case 187: // indexing_expression = indexing_expression.p DOT field.f
			{
					final Symbol _symbol_p = _symbols[offset + 1];
					final Expression p = (Expression) _symbol_p.value;
					final Symbol _symbol_f = _symbols[offset + 3];
					final Field f = (Field) _symbol_f.value;
					 return register(p, f, new ExprField(p, f));
			}
			case 188: // indexing_expression = method_invocation.m
			{
					final Symbol _symbol_m = _symbols[offset + 1];
					final ExprApplication m = (ExprApplication) _symbol_m.value;
					 return _symbol_m;
			}
			case 189: // indexer = indexer_start.s expression.i RBRACK.e
			{
					final Symbol _symbol_s = _symbols[offset + 1];
					final Expression s = (Expression) _symbol_s.value;
					final Symbol _symbol_i = _symbols[offset + 2];
					final Expression i = (Expression) _symbol_i.value;
					final Symbol e = _symbols[offset + 3];
					 return register(s,e, new ExprIndexer(s, i));
			}
			case 190: // indexer_start = indexing_expression.e LBRACK
			{
					final Symbol _symbol_e = _symbols[offset + 1];
					final Expression e = (Expression) _symbol_e.value;
					 return _symbol_e;
			}
			case 191: // indexer_start = indexer_start.s expression.i COMMA.e
			{
					final Symbol _symbol_s = _symbols[offset + 1];
					final Expression s = (Expression) _symbol_s.value;
					final Symbol _symbol_i = _symbols[offset + 2];
					final Expression i = (Expression) _symbol_i.value;
					final Symbol e = _symbols[offset + 3];
					 return register(s, e, new ExprIndexer(s, i));
			}
			case 192: // unary_expression = indexing_expression.e
			{
					final Symbol _symbol_e = _symbols[offset + 1];
					final Expression e = (Expression) _symbol_e.value;
					 return _symbol_e;
			}
			case 193: // unary_expression = operator.operator unary_expression.expr
			{
					final Symbol _symbol_operator = _symbols[offset + 1];
					final String operator = (String) _symbol_operator.value;
					final Symbol _symbol_expr = _symbols[offset + 2];
					final Expression expr = (Expression) _symbol_expr.value;
					 return register(_symbol_operator, expr, new ExprUnaryOp(operator, expr));
			}
			case 194: // expression = unary_expression.e
			{
					final Symbol _symbol_e = _symbols[offset + 1];
					final Expression e = (Expression) _symbol_e.value;
					 return _symbol_e;
			}
			case 195: // expression = expression.arg1 operator.operator unary_expression.arg2
			{
					final Symbol _symbol_arg1 = _symbols[offset + 1];
					final Expression arg1 = (Expression) _symbol_arg1.value;
					final Symbol _symbol_operator = _symbols[offset + 2];
					final String operator = (String) _symbol_operator.value;
					final Symbol _symbol_arg2 = _symbols[offset + 3];
					final Expression arg2 = (Expression) _symbol_arg2.value;
					 ImmutableList<String> operators;
                                                               ImmutableList<Expression> operands;
                                                               boolean arg1IsPar = _symbol_arg1 instanceof ParenthesSymbol;
                                                               ExprBinaryOp expr = null;
                                                               if((arg1 instanceof ExprBinaryOp) && !(arg1IsPar)){
                                                                 expr = (ExprBinaryOp)arg1;
                                                                 operators = ImmutableList.<String>builder().addAll(expr.getOperations()).add(operator).build();
                                                                 operands = ImmutableList.<Expression>builder().addAll(expr.getOperands()).add(arg2).build();
                                                               } else {
                                                                 operators = ImmutableList.of(operator);
                                                                 operands = ImmutableList.of(arg1, arg2);
                                                               }
                                                               return register(operands.get(0), arg2, new ExprBinaryOp(expr, operators, operands));  // reuse the Identifier from the previous expr.
			}
			case 196: // operator = OPERATOR.op
			{
					final Symbol op = _symbols[offset + 1];
					 return op;
			}
			case 197: // operator = EQ.op
			{
					final Symbol op = _symbols[offset + 1];
					 return op;
			}
			case 198: // operator = IN.op
			{
					final Symbol op = _symbols[offset + 1];
					 return op;
			}
			case 199: // operator = GT.op
			{
					final Symbol op = _symbols[offset + 1];
					 return op;
			}
			case 200: // operator = LT.op
			{
					final Symbol op = _symbols[offset + 1];
					 return op;
			}
			case 201: // operator = MULT.op
			{
					final Symbol op = _symbols[offset + 1];
					 return op;
			}
			case 202: // operator = BAR.op
			{
					final Symbol op = _symbols[offset + 1];
					 return op;
			}
			case 203: // formal_parameter = IDENTIFIER.id
			{
					final Symbol id = _symbols[offset + 1];
					 return register(id, id, new ParDeclValue((String)id.value, null));
			}
			case 204: // formal_parameter = type.t IDENTIFIER.id
			{
					final Symbol _symbol_t = _symbols[offset + 1];
					final TypeExpr t = (TypeExpr) _symbol_t.value;
					final Symbol id = _symbols[offset + 2];
					 return register(t, id, new ParDeclValue((String)id.value, t));
			}
			case 205: // formal_parameter_list = formal_parameter.p
			{
					final Symbol _symbol_p = _symbols[offset + 1];
					final ParDeclValue p = (ParDeclValue) _symbol_p.value;
					 return new Symbol(ImmutableList.builder().add(p));
			}
			case 206: // formal_parameter_list = formal_parameter_list.l COMMA formal_parameter.p
			{
					final Symbol _symbol_l = _symbols[offset + 1];
					final ImmutableList.Builder l = (ImmutableList.Builder) _symbol_l.value;
					final Symbol _symbol_p = _symbols[offset + 3];
					final ParDeclValue p = (ParDeclValue) _symbol_p.value;
					 l.add(p);  return _symbol_l;
			}
			case 207: // statement = expression.lhs COLONEQ expression.value SEMICOLON.end
			{
					final Symbol _symbol_lhs = _symbols[offset + 1];
					final Expression lhs = (Expression) _symbol_lhs.value;
					final Symbol _symbol_value = _symbols[offset + 3];
					final Expression value = (Expression) _symbol_value.value;
					final Symbol end = _symbols[offset + 4];
					 LValue lvalue = expressionToLValue(lhs);
                                                             if (lvalue != null) return register(lhs, end, new StmtAssignment(lvalue, value));
                                                             em.error("Illegal left hand sign of assignment.", lhs);
                                                             return register(lhs, end, new StmtAssignment(new LValueVariable(Variable.variable("$illegal")), value));
			}
			case 208: // statement = method_invocation.m SEMICOLON.end
			{
					final Symbol _symbol_m = _symbols[offset + 1];
					final ExprApplication m = (ExprApplication) _symbol_m.value;
					final Symbol end = _symbols[offset + 2];
					 return register(m, end, new StmtCall(m.getFunction(), m.getArgs()));
			}
			case 209: // statement = BEGIN.start statement_list_opt.s END.end
			{
					final Symbol start = _symbols[offset + 1];
					final Symbol _symbol_s = _symbols[offset + 2];
					final ImmutableList s = (ImmutableList) _symbol_s.value;
					final Symbol end = _symbols[offset + 3];
					 return register(start, end, new StmtBlock(null, null, s));
			}
			case 210: // statement = BEGIN.start VAR decl_list.d DO statement_list_opt.s END.end
			{
					final Symbol start = _symbols[offset + 1];
					final Symbol _symbol_d = _symbols[offset + 3];
					final ImmutableList.Builder d = (ImmutableList.Builder) _symbol_d.value;
					final Symbol _symbol_s = _symbols[offset + 5];
					final ImmutableList s = (ImmutableList) _symbol_s.value;
					final Symbol end = _symbols[offset + 6];
					 return register(start, end, new StmtBlock(null, d.build(), s));
			}
			case 211: // statement = IF.start expression.e THEN statement_list_opt.s end_if.end
			{
					final Symbol start = _symbols[offset + 1];
					final Symbol _symbol_e = _symbols[offset + 2];
					final Expression e = (Expression) _symbol_e.value;
					final Symbol _symbol_s = _symbols[offset + 4];
					final ImmutableList s = (ImmutableList) _symbol_s.value;
					final Symbol end = _symbols[offset + 5];
					 return register(start, end, new StmtIf(e, new StmtBlock(null, null, s), null));
			}
			case 212: // statement = IF.start expression.e THEN statement_list_opt.s1 ELSE statement_list_opt.s2 end_if.end
			{
					final Symbol start = _symbols[offset + 1];
					final Symbol _symbol_e = _symbols[offset + 2];
					final Expression e = (Expression) _symbol_e.value;
					final Symbol _symbol_s1 = _symbols[offset + 4];
					final ImmutableList s1 = (ImmutableList) _symbol_s1.value;
					final Symbol _symbol_s2 = _symbols[offset + 6];
					final ImmutableList s2 = (ImmutableList) _symbol_s2.value;
					final Symbol end = _symbols[offset + 7];
					 return register(start, end, new StmtIf(e, 
                                                                                                                                     new StmtBlock(null, null, s1),
                                                                                                                                     new StmtBlock(null, null, s2)));
			}
			case 213: // statement = WHILE.start expression.e decl_block_opt.d DO statement_list_opt.s end_while.end
			{
					final Symbol start = _symbols[offset + 1];
					final Symbol _symbol_e = _symbols[offset + 2];
					final Expression e = (Expression) _symbol_e.value;
					final Symbol _symbol_d = _symbols[offset + 3];
					final ImmutableList d = (ImmutableList) _symbol_d.value;
					final Symbol _symbol_s = _symbols[offset + 5];
					final ImmutableList s = (ImmutableList) _symbol_s.value;
					final Symbol end = _symbols[offset + 6];
					 return register(start, end, new StmtWhile(e, new StmtBlock(null, d, s)));
			}
			case 214: // statement = choose_generator_list.l decl_block_opt.do_v DO.c statement_list_opt.do_s end_choose.end
			{
					final Symbol _symbol_l = _symbols[offset + 1];
					final ImmutableList.Builder l = (ImmutableList.Builder) _symbol_l.value;
					final Symbol _symbol_do_v = _symbols[offset + 2];
					final ImmutableList do_v = (ImmutableList) _symbol_do_v.value;
					final Symbol c = _symbols[offset + 3];
					final Symbol _symbol_do_s = _symbols[offset + 4];
					final ImmutableList do_s = (ImmutableList) _symbol_do_s.value;
					final Symbol end = _symbols[offset + 5];
					 Statement stmt = new StmtBlock(null, null, ImmutableList.<Statement>empty());
       Symbol result = register((GeneratorFilter)l.build().get(0), end, stmt);
       em.error("choose statement is not supported", stmt);
       return result;
			}
			case 215: // statement = choose_generator_list.l decl_block_opt.do_v DO.c statement_list_opt.do_s ELSE statement_list_opt.else_s end_choose.end
			{
					final Symbol _symbol_l = _symbols[offset + 1];
					final ImmutableList.Builder l = (ImmutableList.Builder) _symbol_l.value;
					final Symbol _symbol_do_v = _symbols[offset + 2];
					final ImmutableList do_v = (ImmutableList) _symbol_do_v.value;
					final Symbol c = _symbols[offset + 3];
					final Symbol _symbol_do_s = _symbols[offset + 4];
					final ImmutableList do_s = (ImmutableList) _symbol_do_s.value;
					final Symbol _symbol_else_s = _symbols[offset + 6];
					final ImmutableList else_s = (ImmutableList) _symbol_else_s.value;
					final Symbol end = _symbols[offset + 7];
					 Statement stmt = new StmtBlock(null, null, ImmutableList.<Statement>empty());
       Symbol result = register((GeneratorFilter)l.build().get(0), end, stmt);
       em.error("choose statement is not supported", stmt);
       return result;
			}
			case 216: // statement = choose_generator_list.l decl_block_opt.do_v DO.c statement_list_opt.do_s ELSE decl_block_opt.else_v DO statement_list_opt.else_s end_choose.end
			{
					final Symbol _symbol_l = _symbols[offset + 1];
					final ImmutableList.Builder l = (ImmutableList.Builder) _symbol_l.value;
					final Symbol _symbol_do_v = _symbols[offset + 2];
					final ImmutableList do_v = (ImmutableList) _symbol_do_v.value;
					final Symbol c = _symbols[offset + 3];
					final Symbol _symbol_do_s = _symbols[offset + 4];
					final ImmutableList do_s = (ImmutableList) _symbol_do_s.value;
					final Symbol _symbol_else_v = _symbols[offset + 6];
					final ImmutableList else_v = (ImmutableList) _symbol_else_v.value;
					final Symbol _symbol_else_s = _symbols[offset + 8];
					final ImmutableList else_s = (ImmutableList) _symbol_else_s.value;
					final Symbol end = _symbols[offset + 9];
					 Statement stmt = new StmtBlock(null, null, ImmutableList.<Statement>empty());
       Symbol result = register((GeneratorFilter)l.build().get(0), end, stmt);
       em.error("choose statement is not supported", stmt);
       return result;
			}
			case 217: // statement = for_generator_list.g DO.doSymbol statement_list_opt.s end_foreach.end
			{
					final Symbol _symbol_g = _symbols[offset + 1];
					final ImmutableList.Builder g = (ImmutableList.Builder) _symbol_g.value;
					final Symbol doSymbol = _symbols[offset + 2];
					final Symbol _symbol_s = _symbols[offset + 3];
					final ImmutableList s = (ImmutableList) _symbol_s.value;
					final Symbol end = _symbols[offset + 4];
					 return register(doSymbol, end, new StmtForeach(g.build(), new StmtBlock(null, null, s)));
			}
			case 218: // statement = for_generator_list.g decl_block.d DO.doSymbol statement_list_opt.s end_foreach.end
			{
					final Symbol _symbol_g = _symbols[offset + 1];
					final ImmutableList.Builder g = (ImmutableList.Builder) _symbol_g.value;
					final Symbol _symbol_d = _symbols[offset + 2];
					final ImmutableList d = (ImmutableList) _symbol_d.value;
					final Symbol doSymbol = _symbols[offset + 3];
					final Symbol _symbol_s = _symbols[offset + 4];
					final ImmutableList s = (ImmutableList) _symbol_s.value;
					final Symbol end = _symbols[offset + 5];
					 return register(doSymbol, end, new StmtForeach(g.build(), new StmtBlock(null, d, s)));
			}
			case 219: // choose_generator_list = CHOOSE.start generator_variable_list.vars IN expression.e
			{
					final Symbol start = _symbols[offset + 1];
					final Symbol _symbol_vars = _symbols[offset + 2];
					final ImmutableList.Builder vars = (ImmutableList.Builder) _symbol_vars.value;
					final Symbol _symbol_e = _symbols[offset + 4];
					final Expression e = (Expression) _symbol_e.value;
					 return makeGeneratorFilter(start, null, vars.build(), e, null, null);
			}
			case 220: // choose_generator_list = CHOOSE.start type.t generator_variable_list.vars IN expression.e
			{
					final Symbol start = _symbols[offset + 1];
					final Symbol _symbol_t = _symbols[offset + 2];
					final TypeExpr t = (TypeExpr) _symbol_t.value;
					final Symbol _symbol_vars = _symbols[offset + 3];
					final ImmutableList.Builder vars = (ImmutableList.Builder) _symbol_vars.value;
					final Symbol _symbol_e = _symbols[offset + 5];
					final Expression e = (Expression) _symbol_e.value;
					 return makeGeneratorFilter(start, t, vars.build(), e, null, null);
			}
			case 221: // choose_generator_list = CHOOSE.start generator_variable_list.vars IN expression.e COMMA expression_list.filters
			{
					final Symbol start = _symbols[offset + 1];
					final Symbol _symbol_vars = _symbols[offset + 2];
					final ImmutableList.Builder vars = (ImmutableList.Builder) _symbol_vars.value;
					final Symbol _symbol_e = _symbols[offset + 4];
					final Expression e = (Expression) _symbol_e.value;
					final Symbol _symbol_filters = _symbols[offset + 6];
					final ImmutableList.Builder filters = (ImmutableList.Builder) _symbol_filters.value;
					 return makeGeneratorFilter(start, null, vars.build(), e, filters.build(), null);
			}
			case 222: // choose_generator_list = CHOOSE.start type.t generator_variable_list.vars IN expression.e COMMA expression_list.filters
			{
					final Symbol start = _symbols[offset + 1];
					final Symbol _symbol_t = _symbols[offset + 2];
					final TypeExpr t = (TypeExpr) _symbol_t.value;
					final Symbol _symbol_vars = _symbols[offset + 3];
					final ImmutableList.Builder vars = (ImmutableList.Builder) _symbol_vars.value;
					final Symbol _symbol_e = _symbols[offset + 5];
					final Expression e = (Expression) _symbol_e.value;
					final Symbol _symbol_filters = _symbols[offset + 7];
					final ImmutableList.Builder filters = (ImmutableList.Builder) _symbol_filters.value;
					 return makeGeneratorFilter(start, t, vars.build(), e, filters.build(), null);
			}
			case 223: // choose_generator_list = CHOOSE.start generator_variable_list.vars IN expression.e COMMA choose_generator_list.l
			{
					final Symbol start = _symbols[offset + 1];
					final Symbol _symbol_vars = _symbols[offset + 2];
					final ImmutableList.Builder vars = (ImmutableList.Builder) _symbol_vars.value;
					final Symbol _symbol_e = _symbols[offset + 4];
					final Expression e = (Expression) _symbol_e.value;
					final Symbol _symbol_l = _symbols[offset + 6];
					final ImmutableList.Builder l = (ImmutableList.Builder) _symbol_l.value;
					 return makeGeneratorFilter(start, null, vars.build(), e, null, l.build());
			}
			case 224: // choose_generator_list = CHOOSE.start type.t generator_variable_list.vars IN expression.e COMMA choose_generator_list.l
			{
					final Symbol start = _symbols[offset + 1];
					final Symbol _symbol_t = _symbols[offset + 2];
					final TypeExpr t = (TypeExpr) _symbol_t.value;
					final Symbol _symbol_vars = _symbols[offset + 3];
					final ImmutableList.Builder vars = (ImmutableList.Builder) _symbol_vars.value;
					final Symbol _symbol_e = _symbols[offset + 5];
					final Expression e = (Expression) _symbol_e.value;
					final Symbol _symbol_l = _symbols[offset + 7];
					final ImmutableList.Builder l = (ImmutableList.Builder) _symbol_l.value;
					 return makeGeneratorFilter(start, t, vars.build(), e, null, l.build());
			}
			case 225: // choose_generator_list = CHOOSE.start generator_variable_list.vars IN expression.e COMMA expression_list.filters COMMA choose_generator_list.l
			{
					final Symbol start = _symbols[offset + 1];
					final Symbol _symbol_vars = _symbols[offset + 2];
					final ImmutableList.Builder vars = (ImmutableList.Builder) _symbol_vars.value;
					final Symbol _symbol_e = _symbols[offset + 4];
					final Expression e = (Expression) _symbol_e.value;
					final Symbol _symbol_filters = _symbols[offset + 6];
					final ImmutableList.Builder filters = (ImmutableList.Builder) _symbol_filters.value;
					final Symbol _symbol_l = _symbols[offset + 8];
					final ImmutableList.Builder l = (ImmutableList.Builder) _symbol_l.value;
					 return makeGeneratorFilter(start, null, vars.build(), e, filters.build(), l.build());
			}
			case 226: // choose_generator_list = CHOOSE.start type.t generator_variable_list.vars IN expression.e COMMA expression_list.filters COMMA choose_generator_list.l
			{
					final Symbol start = _symbols[offset + 1];
					final Symbol _symbol_t = _symbols[offset + 2];
					final TypeExpr t = (TypeExpr) _symbol_t.value;
					final Symbol _symbol_vars = _symbols[offset + 3];
					final ImmutableList.Builder vars = (ImmutableList.Builder) _symbol_vars.value;
					final Symbol _symbol_e = _symbols[offset + 5];
					final Expression e = (Expression) _symbol_e.value;
					final Symbol _symbol_filters = _symbols[offset + 7];
					final ImmutableList.Builder filters = (ImmutableList.Builder) _symbol_filters.value;
					final Symbol _symbol_l = _symbols[offset + 9];
					final ImmutableList.Builder l = (ImmutableList.Builder) _symbol_l.value;
					 return makeGeneratorFilter(start, t, vars.build(), e, filters.build(), l.build());
			}
			case 227: // for_generator_list = for_foreach.start generator_variable_list.vars IN expression.e
			{
					final Symbol start = _symbols[offset + 1];
					final Symbol _symbol_vars = _symbols[offset + 2];
					final ImmutableList.Builder vars = (ImmutableList.Builder) _symbol_vars.value;
					final Symbol _symbol_e = _symbols[offset + 4];
					final Expression e = (Expression) _symbol_e.value;
					 return makeGeneratorFilter(start, null, vars.build(), e, null, null);
			}
			case 228: // for_generator_list = for_foreach.start type.t generator_variable_list.vars IN expression.e
			{
					final Symbol start = _symbols[offset + 1];
					final Symbol _symbol_t = _symbols[offset + 2];
					final TypeExpr t = (TypeExpr) _symbol_t.value;
					final Symbol _symbol_vars = _symbols[offset + 3];
					final ImmutableList.Builder vars = (ImmutableList.Builder) _symbol_vars.value;
					final Symbol _symbol_e = _symbols[offset + 5];
					final Expression e = (Expression) _symbol_e.value;
					 return makeGeneratorFilter(start, t, vars.build(), e, null, null);
			}
			case 229: // for_generator_list = for_foreach.start generator_variable_list.vars IN expression.e COMMA expression_list.filters
			{
					final Symbol start = _symbols[offset + 1];
					final Symbol _symbol_vars = _symbols[offset + 2];
					final ImmutableList.Builder vars = (ImmutableList.Builder) _symbol_vars.value;
					final Symbol _symbol_e = _symbols[offset + 4];
					final Expression e = (Expression) _symbol_e.value;
					final Symbol _symbol_filters = _symbols[offset + 6];
					final ImmutableList.Builder filters = (ImmutableList.Builder) _symbol_filters.value;
					 return makeGeneratorFilter(start, null, vars.build(), e, filters.build(), null);
			}
			case 230: // for_generator_list = for_foreach.start type.t generator_variable_list.vars IN expression.e COMMA expression_list.filters
			{
					final Symbol start = _symbols[offset + 1];
					final Symbol _symbol_t = _symbols[offset + 2];
					final TypeExpr t = (TypeExpr) _symbol_t.value;
					final Symbol _symbol_vars = _symbols[offset + 3];
					final ImmutableList.Builder vars = (ImmutableList.Builder) _symbol_vars.value;
					final Symbol _symbol_e = _symbols[offset + 5];
					final Expression e = (Expression) _symbol_e.value;
					final Symbol _symbol_filters = _symbols[offset + 7];
					final ImmutableList.Builder filters = (ImmutableList.Builder) _symbol_filters.value;
					 return makeGeneratorFilter(start, t, vars.build(), e, filters.build(), null);
			}
			case 231: // for_generator_list = for_foreach.start generator_variable_list.vars IN expression.e COMMA for_generator_list.l
			{
					final Symbol start = _symbols[offset + 1];
					final Symbol _symbol_vars = _symbols[offset + 2];
					final ImmutableList.Builder vars = (ImmutableList.Builder) _symbol_vars.value;
					final Symbol _symbol_e = _symbols[offset + 4];
					final Expression e = (Expression) _symbol_e.value;
					final Symbol _symbol_l = _symbols[offset + 6];
					final ImmutableList.Builder l = (ImmutableList.Builder) _symbol_l.value;
					 return makeGeneratorFilter(start, null, vars.build(), e, null, l.build());
			}
			case 232: // for_generator_list = for_foreach.start type.t generator_variable_list.vars IN expression.e COMMA for_generator_list.l
			{
					final Symbol start = _symbols[offset + 1];
					final Symbol _symbol_t = _symbols[offset + 2];
					final TypeExpr t = (TypeExpr) _symbol_t.value;
					final Symbol _symbol_vars = _symbols[offset + 3];
					final ImmutableList.Builder vars = (ImmutableList.Builder) _symbol_vars.value;
					final Symbol _symbol_e = _symbols[offset + 5];
					final Expression e = (Expression) _symbol_e.value;
					final Symbol _symbol_l = _symbols[offset + 7];
					final ImmutableList.Builder l = (ImmutableList.Builder) _symbol_l.value;
					 return makeGeneratorFilter(start, t, vars.build(), e, null, l.build());
			}
			case 233: // for_generator_list = for_foreach.start generator_variable_list.vars IN expression.e COMMA expression_list.filters COMMA for_generator_list.l
			{
					final Symbol start = _symbols[offset + 1];
					final Symbol _symbol_vars = _symbols[offset + 2];
					final ImmutableList.Builder vars = (ImmutableList.Builder) _symbol_vars.value;
					final Symbol _symbol_e = _symbols[offset + 4];
					final Expression e = (Expression) _symbol_e.value;
					final Symbol _symbol_filters = _symbols[offset + 6];
					final ImmutableList.Builder filters = (ImmutableList.Builder) _symbol_filters.value;
					final Symbol _symbol_l = _symbols[offset + 8];
					final ImmutableList.Builder l = (ImmutableList.Builder) _symbol_l.value;
					 return makeGeneratorFilter(start, null, vars.build(), e, filters.build(), l.build());
			}
			case 234: // for_generator_list = for_foreach.start type.t generator_variable_list.vars IN expression.e COMMA expression_list.filters COMMA for_generator_list.l
			{
					final Symbol start = _symbols[offset + 1];
					final Symbol _symbol_t = _symbols[offset + 2];
					final TypeExpr t = (TypeExpr) _symbol_t.value;
					final Symbol _symbol_vars = _symbols[offset + 3];
					final ImmutableList.Builder vars = (ImmutableList.Builder) _symbol_vars.value;
					final Symbol _symbol_e = _symbols[offset + 5];
					final Expression e = (Expression) _symbol_e.value;
					final Symbol _symbol_filters = _symbols[offset + 7];
					final ImmutableList.Builder filters = (ImmutableList.Builder) _symbol_filters.value;
					final Symbol _symbol_l = _symbols[offset + 9];
					final ImmutableList.Builder l = (ImmutableList.Builder) _symbol_l.value;
					 return makeGeneratorFilter(start, t, vars.build(), e, filters.build(), l.build());
			}
			case 235: // generator_variable_list = IDENTIFIER.id
			{
					final Symbol id = _symbols[offset + 1];
					 return new Symbol(ImmutableList.builder().add(id));
			}
			case 236: // generator_variable_list = generator_variable_list.l COMMA IDENTIFIER.id
			{
					final Symbol _symbol_l = _symbols[offset + 1];
					final ImmutableList.Builder l = (ImmutableList.Builder) _symbol_l.value;
					final Symbol id = _symbols[offset + 3];
					 l.add(id); return _symbol_l;
			}
			case 255: // statement_list_opt = 
			{
					 return new Symbol(ImmutableList.empty());
			}
			case 256: // statement_list_opt = statement_list.l
			{
					final Symbol _symbol_l = _symbols[offset + 1];
					final ImmutableList.Builder l = (ImmutableList.Builder) _symbol_l.value;
					 return new Symbol(l.build());
			}
			case 257: // statement_list = statement.n
			{
					final Symbol _symbol_n = _symbols[offset + 1];
					final Statement n = (Statement) _symbol_n.value;
					 return new Symbol(ImmutableList.builder().add(n));
			}
			case 258: // statement_list = statement_list.l statement.n
			{
					final Symbol _symbol_l = _symbols[offset + 1];
					final ImmutableList.Builder l = (ImmutableList.Builder) _symbol_l.value;
					final Symbol _symbol_n = _symbols[offset + 2];
					final Statement n = (Statement) _symbol_n.value;
					 l.add(n); return _symbol_l;
			}
			case 0: // opt$type_parameter_block = 
			case 2: // opt$actor_parameter_list = 
			case 6: // opt$lst$network_body_part = 
			case 8: // opt$SEMICOLON = 
			case 18: // opt$lst$network_decl = 
			case 26: // opt$lst$entity = 
			case 30: // opt$param_assign_list = 
			case 32: // opt$tool_attribute_block = 
			case 36: // opt$entity_expr_list = 
			case 47: // opt$lst$entity_statement = 
			case 56: // opt$lst$entity_indexing = 
			case 71: // opt$lst$tool_attribute = 
			case 80: // opt$actor_parameter_init_expression = 
			case 119: // opt$type_parameter_list = 
			case 127: // opt$type_attribute_list = 
			case 130: // opt$type_list = 
			case 139: // opt$formal_parameter_list = 
			case 141: // opt$decl_block = 
			case 177: // opt$map_list = 
			{
				return new Symbol(null);
			}
			case 1: // opt$type_parameter_block = type_parameter_block
			case 3: // opt$actor_parameter_list = actor_parameter_list
			case 7: // opt$lst$network_body_part = lst$network_body_part
			case 9: // opt$SEMICOLON = SEMICOLON
			case 19: // opt$lst$network_decl = lst$network_decl
			case 27: // opt$lst$entity = lst$entity
			case 31: // opt$param_assign_list = param_assign_list
			case 33: // opt$tool_attribute_block = tool_attribute_block
			case 37: // opt$entity_expr_list = entity_expr_list
			case 48: // opt$lst$entity_statement = lst$entity_statement
			case 57: // opt$lst$entity_indexing = lst$entity_indexing
			case 72: // opt$lst$tool_attribute = lst$tool_attribute
			case 76: // end_network = END
			case 77: // end_network = ENDNETWORK
			case 81: // opt$actor_parameter_init_expression = actor_parameter_init_expression
			case 120: // opt$type_parameter_list = type_parameter_list
			case 128: // opt$type_attribute_list = type_attribute_list
			case 131: // opt$type_list = type_list
			case 140: // opt$formal_parameter_list = formal_parameter_list
			case 142: // opt$decl_block = decl_block
			case 178: // opt$map_list = map_list
			case 237: // for_foreach = FOREACH.FOREACH
			case 238: // for_foreach = FOR.FOR
			case 239: // do_begin = BEGIN.BEGIN
			case 240: // do_begin = DO.DO
			case 241: // end_choose = END.END
			case 242: // end_choose = ENDCHOOSE.ENDCHOOSE
			case 243: // end_foreach = END.END
			case 244: // end_foreach = ENDFOREACH.ENDFOREACH
			case 245: // end_if = END.END
			case 246: // end_if = ENDIF.ENDIF
			case 247: // end_lambda = END.END
			case 248: // end_lambda = ENDLAMBDA.ENDLAMBDA
			case 249: // end_let = END.END
			case 250: // end_let = ENDLET.ENDLET
			case 251: // end_proc = END.END
			case 252: // end_proc = ENDPROC.ENDPROC
			case 253: // end_while = END.END
			case 254: // end_while = ENDWHILE.ENDWHILE
			{
				return _symbols[offset + 1];
			}
			default:
				throw new IllegalArgumentException("unknown production #" + rule_num);
		}
	}
}
