
// verticalPhaseCounter.cal
//
// Author: David B. Parlour (dave.parlour@xilinx.com)
//

actor verticalPhaseCounter( int COORDSZ, int PHASESZ )
      int(size=COORDSZ) PARAM ==> int(size=COORDSZ) TARGET,  int(size=PHASESZ) A : 

  int(size=COORDSZ) loopCount;
  int(size=PHASESZ) upsamplingFactor;
  int(size=PHASESZ) integralIncrement;
  int(size=PHASESZ) integralIncrementWrapped;
  int(size=PHASESZ) fractionalIncrement;
  int(size=PHASESZ) startingAddress;
 
  
  int(size=COORDSZ) integralPhase;
  int(size=PHASESZ) fractionalPhase;
  int(size=PHASESZ) fractionalIncrementWrapped;
  int(size=PHASESZ) wrappingPoint;

  bool done;

  inputWidth: action PARAM:[ p ] ==> TARGET:[ p ] end
  
  inputHeight: action PARAM:[ p ] ==>  TARGET:[ p ] end
  
  outputHeight: action PARAM:[ p ] ==> 
  do
    loopCount := p;
    done := false;
  end
  
  upsamplingFactor: action PARAM:[ p ] ==>
  do
    upsamplingFactor := p;
  end

  integralPhase: action PARAM:[ p ] ==>
  do
    integralPhase := p;
  end
    
  fractionalPhase: action PARAM:[ p ] ==>
  do
    fractionalPhase := p;
  end
  
  integralIncrement: action PARAM:[ p ] ==>
  do
    integralIncrement := p;
    
    // pre-compute the value in the event that the fraction phase 'wraps'
    integralIncrementWrapped := p + 1;
  end
  
  fractionalIncrement: action PARAM:[ p ] ==>
  do
    fractionalIncrement := p;
    
    // pre-compute the point at which fractional phase 'wraps',
    // as well as the increment to use in the event of wrap so
    // that we always are mod upsamplingFactor
    fractionalIncrementWrapped := p - upsamplingFactor;
    wrappingPoint := upsamplingFactor - p;
  end
  
  startingAddress: action PARAM:[ p ] ==>
  do
    startingAddress := p;
  end
   
  // Note counter is pipe-lined 
  done: action ==> TARGET:[ -1 ], A:[ 0 ]
  guard done
  end
  
  next: action ==> TARGET:[ ip ], A:[ startingAddress + fp ]
  var
    int(size=COORDSZ) ip = integralPhase,
    int(size=PHASESZ) fp = fractionalPhase,
    bool rollOver = fractionalPhase >= wrappingPoint
  do
    done := loopCount = 1;
    loopCount := loopCount - 1;

    fractionalPhase := fractionalPhase + if rollOver then fractionalIncrementWrapped else fractionalIncrement end;
    integralPhase := integralPhase + if rollOver then integralIncrementWrapped else integralIncrement end;
  end
  
  schedule fsm p0 :
  
    // Load the control parameters
    p0   ( inputWidth          ) --> p1;
    p1   ( inputHeight         ) --> p2;
    p2   ( outputHeight        ) --> p3;
    p3   ( upsamplingFactor    ) --> p4;
    p4   ( integralPhase       ) --> p5;
    p5   ( fractionalPhase     ) --> p6;
    p6   ( integralIncrement   ) --> p7;
    p7   ( fractionalIncrement ) --> p8;
    p8   ( startingAddress     ) --> loop;
    
    // Run the phase counter
    loop ( done                ) --> p0;
    loop ( next                ) --> loop;
  end
  
  priority
    done > next;
  end
  
end