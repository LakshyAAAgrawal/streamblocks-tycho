actor Empty (parA, parB) in1, in2 ==> out1:

	      a := b;
	      b := c;
	      c := f;
	      f := 1;
	      e := 1;
	      d := 1;


	list = [1, 2, 3];	
	actorA = 1;
	
    function bar() : 1 end

//	hepp = let a=3, step=10 : [[a+step, b, c] : for a, b in 1..a, a<2, for c in [a, b]] end;

	action [tokenA], [tokenB] ==> [list]
	var
	  actionA := 3
	do
	  list[0] := let a=3 : tokenA + a end;
	  list[1] := actionA;
	end
	
/*

	action [c] ==> [foo(c)]
	end

	action in2:[d] ==> [d+actorA]
	end

    actorA := 2;
    function foo(x) : x end
    
	a = Math.sin(old x);
	b = not a();
	c = not a.b;
	d = not a.b().c;
	e = a[i1].b()[i2];
	e = 1 -|= a;
  hepp = a[1, 2];
  a = a.field+b-c()*d;
  b = if a then b else c end;
  c = (not foo)();
  d = not (foo());
  e = not foo();
  n = lambda(a, b) var int d := 3 : a+b+c+d end;  
  o = let a=3, b=4 : a + b endlet;
  p = [a, b, c];
  q = [a : for a in 1..3, a<b];
  r = [a : for a in [1, 2, 3], a>0, for b in [4, 5, 6], a>0, b>1, a<b];
  s = map{x->x*x, x->x+2, a->-|b : for x in [1, 2, 3]};
  t = {a : for a in [1, 2, 3], a>0, for b in {4, 5, 6}, a>0, b>1, a<b};
  u = proc(a, b) var a begin
        d := a+b;
        f.c := n();
        g[2-4] := 42;
        begin
        var
         hepp := 32,
         hepp2 := 33
        do
          a := hepp;
          a := hepp2;
        end
        if a<b then
          a := b;
        else
          a := 32;
        end
        if c=d then
          c := d;
        end
        foo();
        bar(foo(), 3, 4);
        while i<32
        var
          step = 1
        do
          i := i+step;
        end
        foreach i in [1, 2, 3], foreach j in [4, 5, 6] do
          a := i+j;
        end
      end;
*/
end
