actor Empty (parA, parB) in1, in2 ==> out1:

//	actorA = 0;
//	list = [1, 3, 6];
//	actorB = [a : for a in 1..3];
	hepp = let a=3, step=10 : [[a+step, b, c] : for a, b in 1..a, a<2, for c in [a, b]] end;
//    foo := lambda(x, y) : x-y end;
//    a := lambda(a) : a + actorA end;
//    foo := lambda(y) var x=0, bar = lambda (barP) : barP + y + x end : x - y end;
	
	action [tokenA], [tokenB] ==> [hepp]
//	var
//	  actionA := let a=2, b=a+1 : lambda(arg) : arg + b end end
//	  actionA := let a=2, b=a+1, c=1 : a * b + c end
//	do
//	  actorA := actorA - actionA;
	end
/*

	action [c] ==> [foo(c)]
	end

	action in2:[d] ==> [d+actorA]
	end

    actorA := 2;
    function foo(x) : x end
    
	a = Math.sin(old x);
	b = not a();
	c = not a.b;
	d = not a.b().c;
	e = a[i1].b()[i2];
	e = 1 -|= a;
  hepp = a[1, 2];
  a = a.field+b-c()*d;
  b = if a then b else c end;
  c = (not foo)();
  d = not (foo());
  e = not foo();
  n = lambda(a, b) var int d := 3 : a+b+c+d end;  
  o = let a=3, b=4 : a + b endlet;
  p = [a, b, c];
  q = [a : for a in 1..3, a<b];
  r = [a : for a in [1, 2, 3], a>0, for b in [4, 5, 6], a>0, b>1, a<b];
  s = map{x->x*x, x->x+2, a->-|b : for x in [1, 2, 3]};
  t = {a : for a in [1, 2, 3], a>0, for b in {4, 5, 6}, a>0, b>1, a<b};
  u = proc(a, b) var a begin
        d := a+b;
        f.c := n();
        g[2-4] := 42;
        begin
        var
         hepp := 32,
         hepp2 := 33
        do
          a := hepp;
          a := hepp2;
        end
        if a<b then
          a := b;
        else
          a := 32;
        end
        if c=d then
          c := d;
        end
        foo();
        bar(foo(), 3, 4);
        while i<32
        var
          step = 1
        do
          i := i+step;
        end
        foreach i in [1, 2, 3], foreach j in [4, 5, 6] do
          a := i+j;
        end
      end;
*/
end
