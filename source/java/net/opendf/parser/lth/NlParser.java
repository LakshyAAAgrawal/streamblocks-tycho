/* 
 *  @author Per Andersson<Per.Andersson@cs.lth.se>, Lund University
 *  To parse a CAL file use one of the methods:
 *  - public net.opendf.ir.cal.Actor parse(String path, String fileName)
 *  - public net.opendf.ir.cal.Actor parse(File file)
 *
 *  After parsing check for errors in the attribute parseProblems.
 *
 *  The parser is created using jflex and beaver.
 */
 
package net.opendf.parser.lth;

import java.util.ArrayList;
import net.opendf.ir.net.ast.PortReference;
import java.util.Map;
import net.opendf.ir.net.ast.NetworkDefinition;
import net.opendf.ir.net.ToolValueAttribute;
import net.opendf.ir.net.ToolTypeAttribute;
import net.opendf.ir.net.ast.EntityIfExpr;
import java.util.AbstractMap;
import java.io.PrintStream;
import net.opendf.ir.net.ToolAttribute;
import net.opendf.ir.net.ast.EntityListExpr;
import net.opendf.ir.net.ast.StructureStatement;
import java.util.TreeSet;
import beaver.*;
import net.opendf.ir.net.ast.StructureForeachStmt;
import java.util.Arrays;
import net.opendf.ir.net.ast.EntityInstanceExpr;
import net.opendf.ir.net.ast.StructureConnectionStmt;
import net.opendf.ir.common.*;
import net.opendf.ir.net.ast.StructureIfStmt;
import net.opendf.ir.net.ast.EntityExpr;

/**
 * This class is a LALR parser generated by
 * <a href="http://beaver.sourceforge.net">Beaver</a> v0.9.6.1
 * from the grammar specification "NlParser.beaver".
 */
public class NlParser extends Parser {
	static public class Terminals {
		static public final short EOF = 0;
		static public final short NETWORK = 1;
		static public final short IDENTIFIER = 2;
		static public final short LPAREN = 3;
		static public final short RPAREN = 4;
		static public final short PORTCONN = 5;
		static public final short COLON = 6;
		static public final short IF = 7;
		static public final short THEN = 8;
		static public final short ELSE = 9;
		static public final short END = 10;
		static public final short IMPORT = 11;
		static public final short EQ = 12;
		static public final short SEMICOLON = 13;
		static public final short MAP = 14;
		static public final short LBRACE = 15;
		static public final short RBRACE = 16;
		static public final short BEGIN = 17;
		static public final short VAR = 18;
		static public final short DO = 19;
		static public final short CHOOSE = 20;
		static public final short IN = 21;
		static public final short COMMA = 22;
		static public final short LBRACK = 23;
		static public final short RBRACK = 24;
		static public final short DOT = 25;
		static public final short ALL = 26;
		static public final short EDGE = 27;
		static public final short DOUBLECOLON = 28;
		static public final short MUTABLE = 29;
		static public final short EQCOLON = 30;
		static public final short FUNCTION = 31;
		static public final short PROCEDURE = 32;
		static public final short MULTI = 33;
		static public final short LET = 34;
		static public final short CONST = 35;
		static public final short LAMBDA = 36;
		static public final short COLONEQ = 37;
		static public final short WHILE = 38;
		static public final short ENTITIES = 39;
		static public final short STRUCTURE = 40;
		static public final short ENTITY = 41;
		static public final short ENDNETWORK = 42;
		static public final short LT = 43;
		static public final short ARROW = 44;
		static public final short BAR = 45;
		static public final short INTEGER_LITERAL = 46;
		static public final short LONG_LITERAL = 47;
		static public final short FLOATING_POINT_LITERAL = 48;
		static public final short DOUBLE_LITERAL = 49;
		static public final short TRUE_LITERAL = 50;
		static public final short FALSE_LITERAL = 51;
		static public final short CHARACTER_LITERAL = 52;
		static public final short STRING_LITERAL = 53;
		static public final short NULL_LITERAL = 54;
		static public final short OLD = 55;
		static public final short PROC = 56;
		static public final short OPERATOR = 57;
		static public final short GT = 58;
		static public final short MULT = 59;
		static public final short FOREACH = 60;
		static public final short FOR = 61;
		static public final short ENDCHOOSE = 62;
		static public final short ENDFOREACH = 63;
		static public final short ENDIF = 64;
		static public final short ENDLAMBDA = 65;
		static public final short ENDLET = 66;
		static public final short ENDPROC = 67;
		static public final short ENDWHILE = 68;

		static public final String[] NAMES = {
			"EOF",
			"NETWORK",
			"IDENTIFIER",
			"LPAREN",
			"RPAREN",
			"PORTCONN",
			"COLON",
			"IF",
			"THEN",
			"ELSE",
			"END",
			"IMPORT",
			"EQ",
			"SEMICOLON",
			"MAP",
			"LBRACE",
			"RBRACE",
			"BEGIN",
			"VAR",
			"DO",
			"CHOOSE",
			"IN",
			"COMMA",
			"LBRACK",
			"RBRACK",
			"DOT",
			"ALL",
			"EDGE",
			"DOUBLECOLON",
			"MUTABLE",
			"EQCOLON",
			"FUNCTION",
			"PROCEDURE",
			"MULTI",
			"LET",
			"CONST",
			"LAMBDA",
			"COLONEQ",
			"WHILE",
			"ENTITIES",
			"STRUCTURE",
			"ENTITY",
			"ENDNETWORK",
			"LT",
			"ARROW",
			"BAR",
			"INTEGER_LITERAL",
			"LONG_LITERAL",
			"FLOATING_POINT_LITERAL",
			"DOUBLE_LITERAL",
			"TRUE_LITERAL",
			"FALSE_LITERAL",
			"CHARACTER_LITERAL",
			"STRING_LITERAL",
			"NULL_LITERAL",
			"OLD",
			"PROC",
			"OPERATOR",
			"GT",
			"MULT",
			"FOREACH",
			"FOR",
			"ENDCHOOSE",
			"ENDFOREACH",
			"ENDIF",
			"ENDLAMBDA",
			"ENDLET",
			"ENDPROC",
			"ENDWHILE"
		};
	}

	static final ParsingTables PARSING_TABLES = new ParsingTables(
		"U9pjN7Tyr5KIdxSbWP0GYYGeYgZ48A2Wei524GaYYaHwxqZlIEz51G51cY0T11GGY0MnejW" +
		"hYgBeMSvwP$T4paFDtFVDRxBxsyqlsOr#xlxQvJE$UM$UlFc#cJUlR7ONeWgpg1dTGrbKmM" +
		"JHCUf1FGj#DuieXshIK6fZrj5XEiA73L53qvfwqPNKXEhH#RIL6jFLL8kkemje8jr1iwaYV" +
		"QwjZRJrMNgEdgSNw4LwYLwcL#XLQaftqgLq6LrkSGGtGE#Opi2TR2Lc3ENmPekB#c6JpLi4" +
		"DujwcKFKd$yma$W3cc5UfQaqZQOxkEOCuFgeBasYywWFxQJyk707KpxF16vRqnp#rWFkMC7" +
		"T3dzlf1oBomn$SwWZTJ1tKKEwWOvJQrXlgBYtqUTcBUqe#DMyPkQP0#QMk72TsZ5pH4ivvY" +
		"d1BGD$isYdnQLVu6yzce4HYPzyctd8PC5F9yvlmzyP6CUPT1QT3H$YyfTdqG4pcevPJdwg3" +
		"h#2WjiIkCyx$j98yNUN#hlBnfz6HFfhkbAo6MhMqAPI#Zkjq5ygAxYFM7$DYu9R3lxEXB$l" +
		"wxm2d$zTwAyv7Vx#HCU1NzVSYZbEZmVNl49xQ3VyxMrgcaTiFlEImdmsMKu#Kn9mPoEM3HG" +
		"t7$z#2U7MWhy7wJNp6CQwapfGkxZypQVzYF0nvBILF8x8ZYcCCwKvSJPD9CwF8i9JKPk4UT" +
		"z33nJ66UFvt1cFcKmppG6QKgeuNnwLLodmjwdERokBQrRf$7Onvo6lQaVDxvrciPbZDbBvK" +
		"ivlvn2k#6lQqc7#HTVH2V5tYuCBVtlmJUR6g7Nqb1d2qymMqxrqk3mrb5VPWji7$cQeltU9" +
		"lpVH4vZ$XgONTJ8fcF$2EAz5dFF5tiVqAMsYDN$5NnuDV#qQixZpnL#xdoqorSmavCu05#v" +
		"dmDqbzkwMrNWyBjnTL1KOpOl4UHKjCDM0C0hsAmEtXk0sD5S2DnkpkHHnSN1$eLEe2cLG9f" +
		"rAfz5aKxz4tC8zOmyrfzlCFUOHMWpCdf9JrSn5T1Cyd1VoTHVLaHW7p2xA3$jgyinS6cpgO" +
		"WrzRTv3b6kN8iRDCV92N#k8huTf0LPY3gronvWk0cu5ypeTf89GZ9z1bFFf6$fIpf1gz5kf" +
		"S7U6Sgf0$Dr92sIcMW0fLN3P#4mArOUlvS5pGhZvnc1LOy$alvlwoCFik737OwnCpNbCoDy" +
		"BnDzwMly0k7Kab$kPyqqBP743MCun0rsu$VaHQBM4$5ECjrbSPq8VzCj1JlKhnELFn5#fcG" +
		"TWfo7lfrxyiHc7cRUzSamFCmphU7eebnkQpMOJxEHZBx#ThegLKyYanqrZOFRatqrDgWQB1" +
		"yAOo5YxFnx2ldolsG6hJukVpw1aCyd1F0SQrSrPPgNP3$axvksOc6#QP$bMOBwCyxMcjUZi" +
		"5UhdSuBv7EARRJPGU#f6VQ5XpuA1M2CHcEZNZmRHC1eR2vD6cukmPfhJ2ih6oHE5INDbdyW" +
		"1vXowXHR2ZxgeBO5iBYtLjVCOQijf6Qr4$gv6xv9poM9cqxrq7p3l3#NlNXVclX3cW$GGFK" +
		"OFqrEeFGdPqw4zuWtKtg9t1UqZ#ZlzCoRcL$GTVG$C7qEOFxim$qF$HkGoWVa7efi4AeVvh" +
		"6BIKAgaVbQ5ncdcJDpuvfeQvcnpJapCvUPSSo7cyn9pcSvd0zTyvfegy29RvhCz$hKoxO3P" +
		"4J7kOBf4vL0dqytqDZrDtzYnDOFCO62ECCDnenWPDP$PvcPO78#ydM0ccYbcXfa5p4N0d6y" +
		"MH64kDmlD4dE7MHupRvURPK1fRbQRknq$pLQNdzlCTbYy3vWxpHwpszoFlJh7x0NcFlDe5E" +
		"R3vWdp94RvKapCvxd0l86zw1Pp17w#1Oj7NPZlaiqXGcp3hnnGlfGYrqhu5IkspgkvVS1Fn" +
		"s8ujlI$nWnPB1ap$78mYxx#B6RubS1CO2Om4vW9p0Hc0ZE1cS1CO2Om4vZ$VqptvpolqnNo" +
		"ESz6zEb09#bRUe$#HUj3ThnrJuHqrq4tbhqtuz0vMepEtrmw7yPXvvCuTFuHXyuFSUZy6eV" +
		"Exx5rpAanTJP4VJOdxQQiRJTNksQzgvSUtUmflRK4czSxvamTqBLgkohTNcmFH$j1SvKKBY" +
		"v6p$qtQglV38zKSx5h$6Ee4Wtt7Eqb4elkefLNyZX2usbMP5LSM59FKqQrUfjWYNgdX10g5" +
		"ZzMSrqfvk8IjPTSOcjbpzPpY#appbEUwocznbDwhQVqUazfPq$f44$f14$fB4$f8a$fPa$f" +
		"Da$f8K$f#vxIBppdtUyfJVUKNkeflS9JsiXJwZaNvWPFwG1FwIXFwLXFwGfFwNfFwGicAs8" +
		"rpG399zL5rbbSBzCcjaxCrnansayd7$afbLAmQzZLrGWb7#gTg3obGr8HEqwAx4pLiJFbKW" +
		"kiXPR8$5Rm#7fgJJV0ktEe9jN6EejilG3ngOyTvIBiTmsmtYwLpuhi#Ng5u5ZSnLGPF1cxd" +
		"fKa0xUou6O8RcN1pGEkZv8e05uLuzf1NR2FTrFSNi0rQEc7NRCgz3BZmZrVR2N3Qfxw6n3S" +
		"070he6Pn$T19fTvq8xMLVJa5FJ9HSd2x0xSdehSFihwmqZykNAUMZB9JIiLkRd570JSFKel" +
		"RMFpjXB4uVbP57kN1JmUt7t0xGSDfgnQdlvOc2QujJm2kNt3B0ZTL$KqIVpFLtqo9VuKeV#" +
		"$6gDR1twnI#fiKyZSek7dYRru8DmC#LLMVB3v5#5iMiUyEhPwOuxIuSATXjvmDt01gFfdVO" +
		"2YVypIVxu357i3DKDnC$6iSWRkHvc3rsdcnOue7rsQLN#9i9Pk1cnoAyrADSuh4UI#UQoNE" +
		"UJBMmZXt0gupdftGilDUcZXdUUHLimZSeQ5yheYygXmrlvDf2cxCVN4J$hFvxFYx1jP9SKb" +
		"mqq9vDG0nkYyArqTJCLTzQMmfSGCXt5p1tG1Sd#8kLzmCIAhGBl4vEOIx1RYPOizcLnReh$" +
		"YR9BX#LvoT7fLqFOLncuPmhvOUyU7Qg2Lvu0wbgu3XH7OyjDAaHpLPKxaocxcAsvXkmOtsD" +
		"ffF2t1FpK1cbOHRk6VOlNambGCV3CnqmQn48p23gJGwv6kch34RtzDG3lkQJRMmqyx36agX" +
		"cQ3jfOfnRiZNFeAx2RxQkHqK4UE0uEw1noaXt5H4EHFl5s#IFSpIdvlR5C7r2QwVokXPb8g" +
		"JtsBwvJJ8GBqGDnEdHQP48Y2xHcvSk7NHfqb4BezGNATkSVi8hWze5d4GBAV2up1kgkpK6P" +
		"2do5p4WslFqy4H$Zfde5Eh97vKa9mgG#dIAnLPc27PLfZBLMJrPD9vy7SiJlzOEMKpQHKmq" +
		"sLdhYGxN1WpLzQFJzTjflYJYhqyKpB9mJm36cTI3MJWSCXtq$qnCJDekfprqoKokQ6zmj5O" +
		"A9WBPRsKWRyPU0UIAcV1pHXR96Okx5ILsqaip0gOGxjsHgDFKX5CPv#mA2CH1xjMvw5MK#u" +
		"S8nNpBAajGdibMe7U9UUInSp5U0F0h1gQpmmNPbu8ivheLPMrD4Tokd2FI9ELbI9eG$1lPK" +
		"pCobXZbO4vC8Gvq8KvKCuNcxjZOD7Efa#okBVK74ohCKOos$hkWyUnCFqoZyxTpPbFjv#z9" +
		"MzpPJvzOdSYD7f8JlcZvZCDSQY0dbFZYcsQh9L9uaFaVER2lbq9zZunH7AaX$XfOzqz2jEk" +
		"9n$kCINVsvmzVoWi9oD2AUfdYWjpFGtJjMBj3PDdgjWTXb8aPeP6gkHzmNaVu9UruiHu9kf" +
		"rt3d4J5L0cHnwKMfXFHBJfH43KxMIvUbJYo5CaVvFCKCMIyHqsHPC3$cVn7HPI60cC1EO2S" +
		"m4PW8pWPd0J60cC1EO2Sp$FwRNvpnjqCV#xQSTjQSEr35anrENRdBhncCleVCNTKfeTyrwv" +
		"sBcgnHIjqtgOsrgUO3yPTApXsgCfxabZiBrDsf73xI4bhd6lvNkecsnnaNZIXv7E1f59FUK" +
		"r9FQAHzNd0UHUiLxglDMggWxblzCQp7IkNyz5nBIX3H2cXUncZg1vDFCekTFF2#QyEVwHTX" +
		"O7QFzNY9pRARpROZUe1EW#Q1VoNwJodwhYCm8q4L4WVl0BoVo9w7ZVr1kHUIh2wfl#pis0d" +
		"KAoyKHT2vNFixXlcEHxMOux6CSmTEWinUyFOJN0RU6jpt$QX36w##c$OUWpsBqtU#jRngX$" +
		"SKe6rz5rfDya2q4lnBwY57IUF2ljGrZecaktQ$nc6ZB6FVBm1slVjq4waMKN1Dzlu2zCcWR" +
		"3Tuy4Ykv9nwjDIRJjMypwFbKDaFrxeByBDGnFyblGL2WkjCXMwEwSuZAfAfFor5k0Hd65#m" +
		"ElS$1Lth4usdeeHZu2VIm8xFVtWayXZwlWzP7wWSUXJx8VuhMDu8EQVbbxVyYog#0deJzRs" +
		"1ZKgGDobV#lVhG0pQFWvyRrYbx0HwprHVaGE1J7Q$zJcn$r0yhvhjelqNj7KBzG#ZS0VvP9" +
		"AQlAMGdjDmLvPDg6zZ#nOev236AcSEkMFngEUQz0EK$75dmC1vO5pZlAL3WycSpS10NKnkL" +
		"Np262UeFyiHVEz9kMVlDrfEmLGxjjb#jo7O$vZEOXhQFG2tLT$lhnGMHUi5gmC4wyZsa$P1" +
		"hlexWNQFiOMtxvn6bP82dOznOxy7guCDSjWQ06cZvKkWX3rEmH$YnDWFR8Ci2$oJIBlq8kT" +
		"qZxeJU74UMb0BP#Me7SnAyIilDGHrqVk1pi9Fgs#y#DuWQxq6GvfeFUHhi76xphKKTFgOiW" +
		"4wUwd$fy9HdqRO17FDbxdVRr35SfzpEoJD4vHg2lm62EDW5$F6mRhanaEdU6HogV9Xov97P" +
		"0JvAwz3rsnXD1ers#N44zP5QrlNiFmhRk#17NwSUiF6wDTmdO51VhdONGVTBnAYoKq#jWVQ" +
		"ow0iUl1iSUuR$GvsBnf0jSSe6S#B7kWakrPYz7Ha7dux9jrDnbe6G8m4$UA5i8sWJQ3zegy" +
		"eqprBj#hhQ5TSdy4W6Vo4iIyN#59Y6STWzBKF7DH8whsWSSCRuKz7MM6rWJGIFQFbZq54jl" +
		"mRwr3r#bN#0$XNKbetXLng$Ir1VWlfFhfZcW5fed8wxneZzBwarT7y6dGpBam9uF08PyZi9" +
		"VWNWRr9PnVtSPNUiUqpO9xvNlbUnlbFULltN$J$j8ChdW2OMzSit8bfML2VzNRKxswiT#0y" +
		"wxUMnpdpLKNzJRIyktcRQfv7ryhiHnq75wSDcr5xW$pYg$m74n$9ddPmj$uRTTxJjVPGRX7" +
		"NJJeJBvgfmcUgfFixNG1FeRT1wbIYiSz5UEL9cp#P0PfGUvZEWUqRQ0oxT9L5wanmUm5sZ$" +
		"6zsdwJm#4PvnGDpaWGztAK2RTIchgCqd96#xHxw5I6$BrmFT5Qk#sMWaTh1cCrxg5yPsJ$r" +
		"0xL$X#fZhqW$7NnnM2Sz6tMDMM15P7$wEh8UsAB#DTNwlKN7RCf5zPdYAclEfzkxvEFHVMC" +
		"H$FdEDJQzEwPof4uwxdO1v5CQOXTu3hH9Ou2r5DWSfTiIEPcixTWJ0XEYndv0swwnTo75ip" +
		"OF5XrR6iw6mFFQ3tcSDZHQ3rYwlwItGzlto9khdNhvkIxC7rrbFLlISMO7S5yeh#TX#MNUy" +
		"KcRPh4rFjz6#NBKLNwqQ5zJArgcO#vMZ7oqZcqmoYkSSZ1DPUESktiwxf3#JLxzLLzZdxx0" +
		"kJkalQJ#3GthfAz0MxQEKSykvywbDgBMEKrHtICktrndJZ3eihqHTRrt1qDdbKktkajtfxr" +
		"JQFbXvpuTp5MzQq6w5irPKN5oOxUE6ciJvVzswI0t$FjSOryOBll6gexU2z9nRm$EZxAvFx" +
		"AU$ghpNiXi3ylCP#5oi57X7SN3$$5HzQdUUluVFFfkBaPNps$$pwunsdl87fMVYDJtFH1P3" +
		"ovIFLUCWi#vV3j6dY$xVbLB3t0#$yed#JZ$pF$Yd$X7VeQVvk$u6$wMiIhvQ$ud$mDyFMWT" +
		"23TTleAtysNSYA$a9c93Vct7$VaIRi0NyqLy8UF#m8svBTy8diSxEEBN2to3F2$dXjmFlBN" +
		"Kz5TKN1M4MpTNulAS9ksuJtChQKDcSKlLmox4kL9gpdXNnuEaF51Rx#5Dl94tCEvyl0OK#d" +
		"KJ3#C0#xKyL9vNWPfAQJJZFEAHJ0LSy3iFB$YjGEF4TRc3yFRoRCUpX4zdh6aE$QAG9$Cad" +
		"YEbAVAS84#yx#6RkIVtuExSZRjo5#xCdRWZJ#GsN4SqQeSid5TmqlA2twLMotBEvYGEEkrI" +
		"FxUWeE2FK2rBdZKvXSkgv1pbPtCPJbQxDK1u$yAdyUcCzosShl8pGMU0JkLgN84hQ4$SG7a" +
		"hRnEDbV9SmRWvyoefft8v7YMbyxa#dlNuWj3uSVupzZjUBRMhsSU61tDVrb#1SIQe2gWYLy" +
		"PpBV$0N$1d$3b$gUsVAl#OF#IFf8JTXG#ez25vFiYF2ZygpoFyBhbU$3TvQjupxW7yDh$3N" +
		"$5XVftVu3T3Ug$n2upJ2yzd#Nb#KMI7#2LjVPNV4exthloAb5xc9uGVbETJydoIyHw0x#N7" +
		"#J7#ZV4UcnSnRl6CTmUCTtYyb1UBtbxUmxlvVfImRwAyY$T5Z7aktyxp6Vi#B#Hvyiisssy" +
		"n6O9DaA6xX7o4Uph84Ao33EsZDBolDaLejP3F$ZqBPEXM#QM79IEqHiX763$8q6qeJwG0OR" +
		"s038q57mlUWuAWPCAuGRRk5zawbDUXl1PyhVoUn4$zKUuFEtsXsnVb#IZtX6vFs7LuCas6V" +
		"3BaTdrCGRaxojtbV#3qqoseMre0$GMKHBT3RdzRknuoInk4V8JtWY130z37$bB0qbBKBMqK" +
		"yjDqw4n7UHhqfw6#KBuNQK1#QW6#7THFo4zzq8Rtjo0VzOAiaBgWteK2IhRk5#g4SYUqTKM" +
		"v6sWuwiDHTyXFTcsCWco6a9zsGuwv1nbiopxQW$8Ub7UWRHFu9l1PuBF0yy3jVZ8Rt7upr$" +
		"vjRQ#Myn0FopUZlXcwSvIMmUPew8s6tEw2Wy0N8Nx8H92FHgBVICH#99MXhMZRYZvpGJUZh" +
		"JFgdL76cWKP#NtrFU3N0UTQy5ZKIiWF2j8rA3laKvuCyeE2oWDQJYAxjsmJdO3K7RbFzNpK" +
		"4cqjmQy7TyXFDu1QGzOQl0raRUIxkAO8ZH3oqJpmUT1f3upsgBUNSX8e24gEAfTLlI2r0sy" +
		"dF0cKxE9bG6MfBThRehqjvFRN765U1bIMUWEtDx1k1BUqHMcWqXYb8Kg3bLOfhL1QgMHFdW" +
		"xW7OLybFzVAbtCqm==");

/*******************************************************
 *  Inject code for custom error handling in the parser class.
 *******************************************************/
  // all errors encountered during parsing is stored in the array parseProblems. This includes lexical, syntactical and semantic error (multiple initialization actors et.c.)
  public java.util.TreeSet<String> parseProblems = new TreeSet<String>();
  public void newError(String msg, Symbol token){
      parseProblems.add(msg + " At row " + Symbol.getLine(token.getStart()) + ", column " + Symbol.getColumn(token.getStart()));
  };
  public void printParseProblems(){ printParseProblems(System.err); }
  public void printParseProblems(PrintStream out){
    out.println("number of problems: " + parseProblems.size());
    for(String msg : parseProblems){
      out.println("ERROR: " + msg);
    }
  }

  // parser plug-in methods that are called when the parser encounters a syntactical problem
  class Events extends Parser.Events {
    public void scannerError(Scanner.Exception e) {
      parseProblems.add(e.getMessage());
    }
    public void syntaxError(Symbol token) {
      // This method is always called when a problem is encountered, even if it is repaired.
      // beaver.Parser$Exception is thrown if recovery fails.
      String value = token.value != null ? token.value.toString() : Terminals.NAMES[token.getId()];
      parseProblems.add("unexpected token \"" + value + "\" at " + Symbol.getLine(token.getStart()) + ", " + Symbol.getColumn(token.getStart()));
    }
    public void unexpectedTokenRemoved(Symbol token) {
      String value = token.value != null ? token.value.toString() : Terminals.NAMES[token.getId()];
      parseProblems.add("parser recovered after removing token \"" + value + "\" at " + Symbol.getLine(token.getStart()) + ", " + Symbol.getColumn(token.getStart()));
    }
    public void missingTokenInserted(Symbol token) {
      String value = token.value != null ? token.value.toString() : Terminals.NAMES[token.getId()];
      parseProblems.add("parser recovered after inserting token \"" + value + "\" at " + Symbol.getLine(token.getStart()) + ", " + Symbol.getColumn(token.getStart()));
    }
    public void misspelledTokenReplaced(Symbol token) {
      String value = token.value != null ? token.value.toString() : Terminals.NAMES[token.getId()];
      parseProblems.add("parser recovered after replacing token \"" + value + "\" at " + Symbol.getLine(token.getStart()) + ", " + Symbol.getColumn(token.getStart()));
    }
    public void errorPhraseRemoved(Symbol token) {
      String value = token.value != null ? token.value.toString() : Terminals.NAMES[token.getId()];
      parseProblems.add("parser recovered after removing token \"" + value + "\" at " + Symbol.getLine(token.getStart()) + ", " + Symbol.getColumn(token.getStart()));
    }
  }

  {
    // initialization, before the constructor
    report = new Events(); // Use error handler in parser
  }

/*******************************************************
 *  Help routine that parses a file, given its name.
 *  A compilation unit is always returned, containing all parseProblems encountered during parsing.
 *  If a Parser.exception is thrown a CompilationUnit with an empty AST is returned.
 *******************************************************/

  public NetworkDefinition parse(String fileName){
    return parse(new java.io.File(fileName));
  }
  public NetworkDefinition parse(String path, String fileName){
    return parse(new java.io.File(path + "/" + fileName));
  }
  public NetworkDefinition parse(java.io.File file){
     NetworkDefinition network;
     parseProblems = new TreeSet<String>();
     java.io.FileReader fr = null;
     try {
       try {
         fr = new java.io.FileReader(file);
	       NlScanner scanner = new NlScanner(new java.io.BufferedReader(fr));
         network = (NetworkDefinition)parse(scanner);
         fr.close();
       } catch(CalParser.Exception e) {
         // build empty compilation unit for failed error recovery
         // The problem is added to parseProblems[] by the syntaxError() method added to the parser above.
         network = new NetworkDefinition(file.getName());
       } finally {
         if(fr != null){ fr.close(); }
       }
     } catch (java.io.FileNotFoundException e){
       parseProblems.add("file not found: " + e.getMessage());
       network = new NetworkDefinition(file.getName());
     } catch (java.io.IOException e){
       parseProblems.add("error reading file: " + e.getMessage());
       network = new NetworkDefinition(file.getName());
     }
//     network.setSourceFile(file);
//     network.parseProblems = parseProblems;
//     for(Problem p : parseProblems) {
//       p.setSourceFile(file);
//     }
     return network;
   }

  private enum NetworkBodyPartKind{ IMPORT, VAR_DECL, ENTITIES, STRUCTURE, TOOL_ATTRIBUTE; }

/******************************************************************************
 * Needed by CommonParser.beaver
 * Repeated in both NlParser.beaver and CalParser.beaver
 *****************************************************************************/
   private GeneratorFilter makeGeneratorFilter(TypeExpr type, ArrayList varList, Expression e, ArrayList filterList){
    DeclVar[] vars = new DeclVar[varList.size()];
    for(int i = 0; i<varList.size(); i++){
      Symbol symbol = (Symbol)varList.get(i);
      vars[i] = new DeclVar(type, (String)symbol.value, null);
    }
    Expression[] filters = filterList == null ? new Expression[0] : (Expression[])filterList.toArray(new Expression[filterList.size()]);
    return new GeneratorFilter(vars, e, filters);
  }
  class ParenthesSymbol extends Symbol{ // used by the parser to wrap subexpressions that are enclosed by parentheses, i.e. do not add them to a ExprBinaryOp sequence.
     ParenthesSymbol(Symbol s){
       super(s.getId(), s.getStart(), s.getEnd(), s.value);
     }
  }
   
  private LValue expressionToLValue(Expression expression) {
    if (expression instanceof ExprVariable) {
      return new LValueVariable(((ExprVariable) expression).getVariable());
    } else if (expression instanceof ExprIndexer) {
      ExprIndexer exprIndexer = (ExprIndexer) expression;
      LValue structure = expressionToLValue(exprIndexer.getStructure());
      if (structure == null) return null;
      return new LValueIndexer(structure, exprIndexer.getIndex());
    } else if (expression instanceof ExprField) {
      ExprField exprField = (ExprField) expression;
      LValue structure = expressionToLValue(exprField.getStructure());
      if (structure == null) return null;
      return new LValueField(structure, exprField.getField());
    } else {
      return null;
    }
  }

	public NlParser() {
		super(PARSING_TABLES);
	}

	protected Symbol invokeReduceAction(int rule_num, int offset) {
		switch(rule_num) {
			case 4: // lst$network_body_part = network_body_part
			{
					ArrayList lst = new ArrayList(); lst.add(_symbols[offset + 1].value); return new Symbol(lst);
			}
			case 5: // lst$network_body_part = lst$network_body_part network_body_part
			{
					((ArrayList) _symbols[offset + 1].value).add(_symbols[offset + 2].value); return _symbols[offset + 1];
			}
			case 10: // network = NETWORK IDENTIFIER.name opt$type_parameter_block.typePars LPAREN opt$actor_parameter_list.valuePars RPAREN port_decl_list_opt.inputPorts PORTCONN port_decl_list_opt.outputPorts COLON opt$lst$network_body_part.body end_network.end_network opt$SEMICOLON
			{
					final Symbol name = _symbols[offset + 2];
					final Symbol _symbol_typePars = _symbols[offset + 3];
					final ArrayList typePars = (ArrayList) _symbol_typePars.value;
					final Symbol _symbol_valuePars = _symbols[offset + 5];
					final ArrayList valuePars = (ArrayList) _symbol_valuePars.value;
					final Symbol _symbol_inputPorts = _symbols[offset + 7];
					final CompositePortDecl inputPorts = (CompositePortDecl) _symbol_inputPorts.value;
					final Symbol _symbol_outputPorts = _symbols[offset + 9];
					final CompositePortDecl outputPorts = (CompositePortDecl) _symbol_outputPorts.value;
					final Symbol _symbol_body = _symbols[offset + 11];
					final ArrayList _list_body = (ArrayList) _symbol_body.value;
					final Map.Entry[] body = _list_body == null ? new Map.Entry[0] : (Map.Entry[]) _list_body.toArray(new Map.Entry[_list_body.size()]);
					final Symbol _symbol_end_network = _symbols[offset + 12];
					final String end_network = (String) _symbol_end_network.value;
					
        NamespaceDecl ns = null;
        ArrayList varDecls = new ArrayList();
        ArrayList structure = new ArrayList();
        ArrayList<java.util.Map.Entry<String,EntityExpr>> entities = new ArrayList();
        ArrayList<ToolAttribute> toolAttributes = new ArrayList();
        for(Map.Entry part : body){
            ArrayList all = (ArrayList)part.getValue();
            if(all != null){  // entities and structure may be empty. Then the parser return null.
                switch((NetworkBodyPartKind)part.getKey()){
                case IMPORT:
                     System.out.println("UNSUPPORTED, import is ignored.");
                     //TODO
                     break;
                case VAR_DECL:
                    varDecls.addAll(all);
                    break;
                case ENTITIES:
                    entities.addAll(all);
                    break;
                case STRUCTURE:
                    structure.addAll(all);
                    break;
                case TOOL_ATTRIBUTE:
                    toolAttributes.addAll(all);
                    break;
                }
            }
        }
        
        return new Symbol(new NetworkDefinition((String)name.value, 
                          ns, 
                          typePars == null ? new ParDeclType[0] : (ParDeclType[])typePars.toArray(new ParDeclType[typePars.size()]),     // typePars,
                          valuePars == null ? new ParDeclValue[0] : (ParDeclValue[])valuePars.toArray(new ParDeclValue[valuePars.size()]), // valuePars,
                          new DeclType[0],      // typeDecls, NOTE, can not be expressed in NL
                          (DeclVar[])varDecls.toArray(new DeclVar[varDecls.size()]),             // varDecls
                          inputPorts, outputPorts,
                          (Map.Entry<String,EntityExpr>[])entities.toArray(new Map.Entry[entities.size()]), // entities
                          (StructureStatement[])structure.toArray(new StructureStatement[structure.size()]), // structure
                          (ToolAttribute[])toolAttributes.toArray(new ToolAttribute[toolAttributes.size()])
                          ));
			}
			case 11: // network_body_part = import_part.part
			{
					final Symbol _symbol_part = _symbols[offset + 1];
					final ArrayList part = (ArrayList) _symbol_part.value;
					 return new Symbol(new AbstractMap.SimpleEntry(NetworkBodyPartKind.IMPORT, part));
			}
			case 12: // network_body_part = network_decl_block.part
			{
					final Symbol _symbol_part = _symbols[offset + 1];
					final ArrayList part = (ArrayList) _symbol_part.value;
					 return new Symbol(new AbstractMap.SimpleEntry(NetworkBodyPartKind.VAR_DECL, part));
			}
			case 13: // network_body_part = entities.part
			{
					final Symbol _symbol_part = _symbols[offset + 1];
					final ArrayList part = (ArrayList) _symbol_part.value;
					 return new Symbol(new AbstractMap.SimpleEntry(NetworkBodyPartKind.ENTITIES, part));
			}
			case 14: // network_body_part = structure.part
			{
					final Symbol _symbol_part = _symbols[offset + 1];
					final ArrayList part = (ArrayList) _symbol_part.value;
					 return new Symbol(new AbstractMap.SimpleEntry(NetworkBodyPartKind.STRUCTURE, part));
			}
			case 15: // network_body_part = tool_attribute_block.part
			{
					final Symbol _symbol_part = _symbols[offset + 1];
					final ArrayList part = (ArrayList) _symbol_part.value;
					 return new Symbol(new AbstractMap.SimpleEntry(NetworkBodyPartKind.TOOL_ATTRIBUTE, part));
			}
			case 16: // lst$network_decl = network_decl
			{
					ArrayList lst = new ArrayList(); lst.add(_symbols[offset + 1].value); return new Symbol(lst);
			}
			case 17: // lst$network_decl = lst$network_decl network_decl
			{
					((ArrayList) _symbols[offset + 1].value).add(_symbols[offset + 2].value); return _symbols[offset + 1];
			}
			case 20: // network_decl_block = VAR opt$lst$network_decl.d
			{
					final Symbol _symbol_d = _symbols[offset + 2];
					final ArrayList _list_d = (ArrayList) _symbol_d.value;
					final DeclVar[] d = _list_d == null ? new DeclVar[0] : (DeclVar[]) _list_d.toArray(new DeclVar[_list_d.size()]);
					 return _symbol_d;
			}
			case 21: // network_decl = var_decl.d SEMICOLON
			{
					final Symbol _symbol_d = _symbols[offset + 1];
					final DeclVar d = (DeclVar) _symbol_d.value;
					 return _symbol_d;
			}
			case 22: // network_decl = fun_decl.d
			{
					final Symbol _symbol_d = _symbols[offset + 1];
					final DeclVar d = (DeclVar) _symbol_d.value;
					 return _symbol_d;
			}
			case 23: // network_decl = proc_decl.d
			{
					final Symbol _symbol_d = _symbols[offset + 1];
					final DeclVar d = (DeclVar) _symbol_d.value;
					 return _symbol_d;
			}
			case 24: // lst$entity = entity
			{
					ArrayList lst = new ArrayList(); lst.add(_symbols[offset + 1].value); return new Symbol(lst);
			}
			case 25: // lst$entity = lst$entity entity
			{
					((ArrayList) _symbols[offset + 1].value).add(_symbols[offset + 2].value); return _symbols[offset + 1];
			}
			case 28: // entities = ENTITIES opt$lst$entity.l
			{
					final Symbol _symbol_l = _symbols[offset + 2];
					final ArrayList _list_l = (ArrayList) _symbol_l.value;
					final java.util.Map.Entry[] l = _list_l == null ? new java.util.Map.Entry[0] : (java.util.Map.Entry[]) _list_l.toArray(new java.util.Map.Entry[_list_l.size()]);
					 return _symbol_l;
			}
			case 29: // entity = IDENTIFIER.ID EQ entity_expr.e SEMICOLON
			{
					final Symbol ID = _symbols[offset + 1];
					final Symbol _symbol_e = _symbols[offset + 3];
					final EntityExpr e = (EntityExpr) _symbol_e.value;
					 return new Symbol(new java.util.AbstractMap.SimpleEntry((String)ID.value, e));
			}
			case 34: // entity_expr = IDENTIFIER.id LPAREN opt$param_assign_list.l RPAREN opt$tool_attribute_block.a
			{
					final Symbol id = _symbols[offset + 1];
					final Symbol _symbol_l = _symbols[offset + 3];
					final ArrayList l = (ArrayList) _symbol_l.value;
					final Symbol _symbol_a = _symbols[offset + 5];
					final ArrayList a = (ArrayList) _symbol_a.value;
					 return new Symbol(new EntityInstanceExpr((String)id.value, l == null ? new Map.Entry[0] : (Map.Entry[])l.toArray(new Map.Entry[l.size()]),
                                                                                                                          (ToolAttribute[]) (a==null ? new ToolAttribute[0] : a.toArray(new ToolAttribute[a.size()]))
                                                                                                                         ));
			}
			case 35: // entity_expr = IF expression.e THEN entity_expr.t ELSE entity_expr.f end_if
			{
					final Symbol _symbol_e = _symbols[offset + 2];
					final Expression e = (Expression) _symbol_e.value;
					final Symbol _symbol_t = _symbols[offset + 4];
					final EntityExpr t = (EntityExpr) _symbol_t.value;
					final Symbol _symbol_f = _symbols[offset + 6];
					final EntityExpr f = (EntityExpr) _symbol_f.value;
					 return new Symbol(new EntityIfExpr(e, t, f));
			}
			case 38: // entity_expr = LBRACK opt$entity_expr_list.e RBRACK
			{
					final Symbol _symbol_e = _symbols[offset + 2];
					final ArrayList e = (ArrayList) _symbol_e.value;
					 return new Symbol(new EntityListExpr((EntityExpr[])(e==null? new EntityExpr[0] : e.toArray(new EntityExpr[e.size()])), null));
			}
			case 39: // entity_expr = LBRACK entity_expr_list.e COLON for_generator_list.g RBRACK
			{
					final Symbol _symbol_e = _symbols[offset + 2];
					final ArrayList e = (ArrayList) _symbol_e.value;
					final Symbol _symbol_g = _symbols[offset + 4];
					final ArrayList g = (ArrayList) _symbol_g.value;
					 return new Symbol(new EntityListExpr((EntityExpr[])(e==null? new EntityExpr[0] : e.toArray(new EntityExpr[e.size()])), (GeneratorFilter[])g.toArray(new GeneratorFilter[g.size()])));
			}
			case 40: // param_assign_list = param_assign.p
			{
					final Symbol _symbol_p = _symbols[offset + 1];
					final Map.Entry p = (Map.Entry) _symbol_p.value;
					 ArrayList l = new ArrayList(); l.add(p); return new Symbol(l);
			}
			case 41: // param_assign_list = param_assign_list.l COMMA param_assign.p
			{
					final Symbol _symbol_l = _symbols[offset + 1];
					final ArrayList l = (ArrayList) _symbol_l.value;
					final Symbol _symbol_p = _symbols[offset + 3];
					final Map.Entry p = (Map.Entry) _symbol_p.value;
					 l.add(p); return _symbol_l;
			}
			case 42: // entity_expr_list = entity_expr.e
			{
					final Symbol _symbol_e = _symbols[offset + 1];
					final EntityExpr e = (EntityExpr) _symbol_e.value;
					 ArrayList l = new ArrayList(); l.add(e); return new Symbol(l);
			}
			case 43: // entity_expr_list = entity_expr_list.l COMMA entity_expr.e
			{
					final Symbol _symbol_l = _symbols[offset + 1];
					final ArrayList l = (ArrayList) _symbol_l.value;
					final Symbol _symbol_e = _symbols[offset + 3];
					final EntityExpr e = (EntityExpr) _symbol_e.value;
					 l.add(e); return _symbol_l;
			}
			case 44: // param_assign = IDENTIFIER.ID EQ expression.expression
			{
					final Symbol ID = _symbols[offset + 1];
					final Symbol _symbol_expression = _symbols[offset + 3];
					final Expression expression = (Expression) _symbol_expression.value;
					 return new Symbol(new java.util.AbstractMap.SimpleEntry((String)ID.value, expression));
			}
			case 45: // lst$entity_statement = entity_statement
			{
					ArrayList lst = new ArrayList(); lst.add(_symbols[offset + 1].value); return new Symbol(lst);
			}
			case 46: // lst$entity_statement = lst$entity_statement entity_statement
			{
					((ArrayList) _symbols[offset + 1].value).add(_symbols[offset + 2].value); return _symbols[offset + 1];
			}
			case 49: // structure = STRUCTURE opt$lst$entity_statement.l
			{
					final Symbol _symbol_l = _symbols[offset + 2];
					final ArrayList _list_l = (ArrayList) _symbol_l.value;
					final StructureStatement[] l = _list_l == null ? new StructureStatement[0] : (StructureStatement[]) _list_l.toArray(new StructureStatement[_list_l.size()]);
					 return _symbol_l;
			}
			case 50: // entity_statement = entity_port.src EDGE entity_port.dst opt$tool_attribute_block.a SEMICOLON
			{
					final Symbol _symbol_src = _symbols[offset + 1];
					final PortReference src = (PortReference) _symbol_src.value;
					final Symbol _symbol_dst = _symbols[offset + 3];
					final PortReference dst = (PortReference) _symbol_dst.value;
					final Symbol _symbol_a = _symbols[offset + 4];
					final ArrayList a = (ArrayList) _symbol_a.value;
					 return new Symbol(new StructureConnectionStmt(src, dst, (ToolAttribute[])(a==null ? null : a.toArray(new ToolAttribute[a.size()]))));
			}
			case 51: // entity_statement = for_generator_list.g DO opt$lst$entity_statement.s END
			{
					final Symbol _symbol_g = _symbols[offset + 1];
					final ArrayList g = (ArrayList) _symbol_g.value;
					final Symbol _symbol_s = _symbols[offset + 3];
					final ArrayList _list_s = (ArrayList) _symbol_s.value;
					final StructureStatement[] s = _list_s == null ? new StructureStatement[0] : (StructureStatement[]) _list_s.toArray(new StructureStatement[_list_s.size()]);
					 return new Symbol(new StructureForeachStmt((GeneratorFilter[])(g.toArray(new GeneratorFilter[g.size()])), s));
			}
			case 52: // entity_statement = IF expression.e THEN opt$lst$entity_statement.t_stmt END
			{
					final Symbol _symbol_e = _symbols[offset + 2];
					final Expression e = (Expression) _symbol_e.value;
					final Symbol _symbol_t_stmt = _symbols[offset + 4];
					final ArrayList _list_t_stmt = (ArrayList) _symbol_t_stmt.value;
					final StructureStatement[] t_stmt = _list_t_stmt == null ? new StructureStatement[0] : (StructureStatement[]) _list_t_stmt.toArray(new StructureStatement[_list_t_stmt.size()]);
					 return new Symbol(new StructureIfStmt(e, t_stmt, null));
			}
			case 53: // entity_statement = IF expression.e THEN opt$lst$entity_statement.t_stmt ELSE opt$lst$entity_statement.f_stmt END
			{
					final Symbol _symbol_e = _symbols[offset + 2];
					final Expression e = (Expression) _symbol_e.value;
					final Symbol _symbol_t_stmt = _symbols[offset + 4];
					final ArrayList _list_t_stmt = (ArrayList) _symbol_t_stmt.value;
					final StructureStatement[] t_stmt = _list_t_stmt == null ? new StructureStatement[0] : (StructureStatement[]) _list_t_stmt.toArray(new StructureStatement[_list_t_stmt.size()]);
					final Symbol _symbol_f_stmt = _symbols[offset + 6];
					final ArrayList _list_f_stmt = (ArrayList) _symbol_f_stmt.value;
					final StructureStatement[] f_stmt = _list_f_stmt == null ? new StructureStatement[0] : (StructureStatement[]) _list_f_stmt.toArray(new StructureStatement[_list_f_stmt.size()]);
					 return new Symbol(new StructureIfStmt(e, t_stmt, f_stmt));
			}
			case 54: // lst$entity_indexing = entity_indexing
			{
					ArrayList lst = new ArrayList(); lst.add(_symbols[offset + 1].value); return new Symbol(lst);
			}
			case 55: // lst$entity_indexing = lst$entity_indexing entity_indexing
			{
					((ArrayList) _symbols[offset + 1].value).add(_symbols[offset + 2].value); return _symbols[offset + 1];
			}
			case 58: // entity_port = IDENTIFIER.id_port opt$lst$entity_indexing.index_port
			{
					final Symbol id_port = _symbols[offset + 1];
					final Symbol _symbol_index_port = _symbols[offset + 2];
					final ArrayList _list_index_port = (ArrayList) _symbol_index_port.value;
					final Expression[] index_port = _list_index_port == null ? new Expression[0] : (Expression[]) _list_index_port.toArray(new Expression[_list_index_port.size()]);
					 return new Symbol(new PortReference(null, null, (String)id_port.value));
			}
			case 59: // entity_port = IDENTIFIER.id_entity opt$lst$entity_indexing.index_entity DOT IDENTIFIER.id_port opt$lst$entity_indexing.index_port
			{
					final Symbol id_entity = _symbols[offset + 1];
					final Symbol _symbol_index_entity = _symbols[offset + 2];
					final ArrayList _list_index_entity = (ArrayList) _symbol_index_entity.value;
					final Expression[] index_entity = _list_index_entity == null ? new Expression[0] : (Expression[]) _list_index_entity.toArray(new Expression[_list_index_entity.size()]);
					final Symbol id_port = _symbols[offset + 4];
					final Symbol _symbol_index_port = _symbols[offset + 5];
					final ArrayList _list_index_port = (ArrayList) _symbol_index_port.value;
					final Expression[] index_port = _list_index_port == null ? new Expression[0] : (Expression[]) _list_index_port.toArray(new Expression[_list_index_port.size()]);
					 return new Symbol(new PortReference((String)id_entity.value, index_entity , (String)id_port.value));
			}
			case 60: // entity_indexing = LBRACK.LBRACK expression.e RBRACK.RBRACK
			{
					final Symbol LBRACK = _symbols[offset + 1];
					final Symbol _symbol_e = _symbols[offset + 2];
					final Expression e = (Expression) _symbol_e.value;
					final Symbol RBRACK = _symbols[offset + 3];
					 return _symbol_e;
			}
			case 61: // import_part = import_single.i
			{
					final Symbol _symbol_i = _symbols[offset + 1];
					final ArrayList i = (ArrayList) _symbol_i.value;
					 return _symbol_i;
			}
			case 62: // import_part = import_group.i
			{
					final Symbol _symbol_i = _symbols[offset + 1];
					final ArrayList i = (ArrayList) _symbol_i.value;
					 return _symbol_i;
			}
			case 63: // import_single = IMPORT import_kind.k qual_id.qual_id SEMICOLON
			{
					final Symbol _symbol_k = _symbols[offset + 2];
					final String k = (String) _symbol_k.value;
					final Symbol _symbol_qual_id = _symbols[offset + 3];
					final ArrayList qual_id = (ArrayList) _symbol_qual_id.value;
					 return new Symbol(qual_id);
			}
			case 64: // import_single = IMPORT import_kind.k qual_id.qual_id EQ IDENTIFIER.alias SEMICOLON
			{
					final Symbol _symbol_k = _symbols[offset + 2];
					final String k = (String) _symbol_k.value;
					final Symbol _symbol_qual_id = _symbols[offset + 3];
					final ArrayList qual_id = (ArrayList) _symbol_qual_id.value;
					final Symbol alias = _symbols[offset + 5];
					 return new Symbol(qual_id);
			}
			case 65: // import_group = IMPORT import_kind.k ALL qual_id.qual_id SEMICOLON
			{
					final Symbol _symbol_k = _symbols[offset + 2];
					final String k = (String) _symbol_k.value;
					final Symbol _symbol_qual_id = _symbols[offset + 4];
					final ArrayList qual_id = (ArrayList) _symbol_qual_id.value;
					 return new Symbol(qual_id);
			}
			case 66: // import_kind = 
			{
					 return new Symbol("");
			}
			case 67: // import_kind = ENTITY.kind
			{
					final Symbol kind = _symbols[offset + 1];
					 return kind;
			}
			case 68: // import_kind = VAR.kind
			{
					final Symbol kind = _symbols[offset + 1];
					 return kind;
			}
			case 69: // lst$tool_attribute = tool_attribute
			{
					ArrayList lst = new ArrayList(); lst.add(_symbols[offset + 1].value); return new Symbol(lst);
			}
			case 70: // lst$tool_attribute = lst$tool_attribute tool_attribute
			{
					((ArrayList) _symbols[offset + 1].value).add(_symbols[offset + 2].value); return _symbols[offset + 1];
			}
			case 73: // tool_attribute_block = LBRACE opt$lst$tool_attribute.a RBRACE
			{
					final Symbol _symbol_a = _symbols[offset + 2];
					final ArrayList _list_a = (ArrayList) _symbol_a.value;
					final ToolAttribute[] a = _list_a == null ? new ToolAttribute[0] : (ToolAttribute[]) _list_a.toArray(new ToolAttribute[_list_a.size()]);
					 return _symbol_a;
			}
			case 74: // tool_attribute = IDENTIFIER.ID EQ expression.expression SEMICOLON
			{
					final Symbol ID = _symbols[offset + 1];
					final Symbol _symbol_expression = _symbols[offset + 3];
					final Expression expression = (Expression) _symbol_expression.value;
					 return new Symbol(new ToolValueAttribute((String)ID.value, expression));
			}
			case 75: // tool_attribute = IDENTIFIER.ID COLON type.type SEMICOLON
			{
					final Symbol ID = _symbols[offset + 1];
					final Symbol _symbol_type = _symbols[offset + 3];
					final TypeExpr type = (TypeExpr) _symbol_type.value;
					 return new Symbol(new ToolTypeAttribute((String)ID.value, type));
			}
			case 78: // actor_parameter_list = actor_parameter.p
			{
					final Symbol _symbol_p = _symbols[offset + 1];
					final ParDeclValue p = (ParDeclValue) _symbol_p.value;
					 ArrayList result = new ArrayList(); result.add(p); return new Symbol(result);
			}
			case 79: // actor_parameter_list = actor_parameter_list.l COMMA actor_parameter.p
			{
					final Symbol _symbol_l = _symbols[offset + 1];
					final ArrayList l = (ArrayList) _symbol_l.value;
					final Symbol _symbol_p = _symbols[offset + 3];
					final ParDeclValue p = (ParDeclValue) _symbol_p.value;
					 l.add(p); return _symbol_l;
			}
			case 82: // actor_parameter = IDENTIFIER.id opt$actor_parameter_init_expression.e
			{
					final Symbol id = _symbols[offset + 1];
					final Symbol _symbol_e = _symbols[offset + 2];
					final Expression e = (Expression) _symbol_e.value;
					 return new Symbol(new ParDeclValue((String)id.value, null));
			}
			case 83: // actor_parameter = type.t IDENTIFIER.id opt$actor_parameter_init_expression.e
			{
					final Symbol _symbol_t = _symbols[offset + 1];
					final TypeExpr t = (TypeExpr) _symbol_t.value;
					final Symbol id = _symbols[offset + 2];
					final Symbol _symbol_e = _symbols[offset + 3];
					final Expression e = (Expression) _symbol_e.value;
					 return new Symbol(new ParDeclValue((String)id.value, t));
			}
			case 84: // actor_parameter_init_expression = EQ expression.e
			{
					final Symbol _symbol_e = _symbols[offset + 2];
					final Expression e = (Expression) _symbol_e.value;
					 return _symbol_e;
			}
			case 85: // qual_id = IDENTIFIER.id
			{
					final Symbol id = _symbols[offset + 1];
					 ArrayList l = new ArrayList(); l.add(id.value); return new Symbol(l);
			}
			case 86: // qual_id = IDENTIFIER.id DOT qual_id.l
			{
					final Symbol id = _symbols[offset + 1];
					final Symbol _symbol_l = _symbols[offset + 3];
					final ArrayList l = (ArrayList) _symbol_l.value;
					 l.add(0, id.value); return _symbol_l;
			}
			case 87: // variable = IDENTIFIER.id
			{
					final Symbol id = _symbols[offset + 1];
					 return new Symbol(new Variable((String) id.value));
			}
			case 88: // field = IDENTIFIER.id
			{
					final Symbol id = _symbols[offset + 1];
					 return new Symbol(new Field((String) id.value));
			}
			case 89: // decl_list = decl.d
			{
					final Symbol _symbol_d = _symbols[offset + 1];
					final DeclVar d = (DeclVar) _symbol_d.value;
					 ArrayList l = new ArrayList(); l.add(d); return new Symbol(l);
			}
			case 90: // decl_list = decl_list.l COMMA decl.d
			{
					final Symbol _symbol_l = _symbols[offset + 1];
					final ArrayList l = (ArrayList) _symbol_l.value;
					final Symbol _symbol_d = _symbols[offset + 3];
					final DeclVar d = (DeclVar) _symbol_d.value;
					 l.add(d); return _symbol_l;
			}
			case 91: // decl_block = VAR decl_list.d
			{
					final Symbol _symbol_d = _symbols[offset + 2];
					final ArrayList d = (ArrayList) _symbol_d.value;
					 return _symbol_d;
			}
			case 92: // decl_block_opt = 
			{
					 return new Symbol(new ArrayList());
			}
			case 93: // decl_block_opt = VAR decl_list.d
			{
					final Symbol _symbol_d = _symbols[offset + 2];
					final ArrayList d = (ArrayList) _symbol_d.value;
					 return _symbol_d;
			}
			case 94: // decl = var_decl.d
			{
					final Symbol _symbol_d = _symbols[offset + 1];
					final DeclVar d = (DeclVar) _symbol_d.value;
					 return _symbol_d;
			}
			case 95: // decl = fun_decl.d
			{
					final Symbol _symbol_d = _symbols[offset + 1];
					final DeclVar d = (DeclVar) _symbol_d.value;
					 return _symbol_d;
			}
			case 96: // decl = proc_decl.d
			{
					final Symbol _symbol_d = _symbols[offset + 1];
					final DeclVar d = (DeclVar) _symbol_d.value;
					 return _symbol_d;
			}
			case 97: // var_decl = MUTABLE var_name_type.v
			{
					final Symbol _symbol_v = _symbols[offset + 2];
					final DeclVar v = (DeclVar) _symbol_v.value;
					 return new Symbol(new DeclVar(v.getType(), v.getName(), null, null, true));
			}
			case 98: // var_decl = MUTABLE var_name_type.v EQ expression.init
			{
					final Symbol _symbol_v = _symbols[offset + 2];
					final DeclVar v = (DeclVar) _symbol_v.value;
					final Symbol _symbol_init = _symbols[offset + 4];
					final Expression init = (Expression) _symbol_init.value;
					 return new Symbol(new DeclVar(v.getType(), v.getName(), null, init, false));
			}
			case 99: // var_decl = MUTABLE var_name_type.v EQCOLON expression.init
			{
					final Symbol _symbol_v = _symbols[offset + 2];
					final DeclVar v = (DeclVar) _symbol_v.value;
					final Symbol _symbol_init = _symbols[offset + 4];
					final Expression init = (Expression) _symbol_init.value;
					 return new Symbol(new DeclVar(v.getType(), v.getName(), null, init, true));
			}
			case 100: // var_decl = var_name_type.v
			{
					final Symbol _symbol_v = _symbols[offset + 1];
					final DeclVar v = (DeclVar) _symbol_v.value;
					 return new Symbol(new DeclVar(v.getType(), v.getName(), null, null, true));
			}
			case 101: // var_decl = var_name_type.v EQ expression.init
			{
					final Symbol _symbol_v = _symbols[offset + 1];
					final DeclVar v = (DeclVar) _symbol_v.value;
					final Symbol _symbol_init = _symbols[offset + 3];
					final Expression init = (Expression) _symbol_init.value;
					 return new Symbol(new DeclVar(v.getType(), v.getName(), null, init, false));
			}
			case 102: // var_decl = var_name_type.v COLONEQ expression.init
			{
					final Symbol _symbol_v = _symbols[offset + 1];
					final DeclVar v = (DeclVar) _symbol_v.value;
					final Symbol _symbol_init = _symbols[offset + 3];
					final Expression init = (Expression) _symbol_init.value;
					 return new Symbol(new DeclVar(v.getType(), v.getName(), null, init, true));
			}
			case 103: // var_name_type = IDENTIFIER.id
			{
					final Symbol id = _symbols[offset + 1];
					 return new Symbol(new DeclVar(null, (String)id.value, null));
			}
			case 104: // var_name_type = type.type IDENTIFIER.id
			{
					final Symbol _symbol_type = _symbols[offset + 1];
					final TypeExpr type = (TypeExpr) _symbol_type.value;
					final Symbol id = _symbols[offset + 2];
					 return new Symbol(new DeclVar(type, (String)id.value, null));
			}
			case 105: // fun_decl = FUNCTION IDENTIFIER.id lambda_expr_body.lambda
			{
					final Symbol id = _symbols[offset + 2];
					final Symbol _symbol_lambda = _symbols[offset + 3];
					final ExprLambda lambda = (ExprLambda) _symbol_lambda.value;
					 return new Symbol(new DeclVar(null, (String)id.value, null, lambda, false));
			}
			case 106: // proc_decl = PROCEDURE IDENTIFIER.id procedure_expr_body.body
			{
					final Symbol id = _symbols[offset + 2];
					final Symbol _symbol_body = _symbols[offset + 3];
					final ExprProc body = (ExprProc) _symbol_body.value;
					 return new Symbol(new DeclVar(null, (String)id.value, null, body, false));
			}
			case 107: // port_decl = IDENTIFIER.id
			{
					final Symbol id = _symbols[offset + 1];
					 return new Symbol(new AtomicPortDecl((String)id.value, null));
			}
			case 108: // port_decl = type.type IDENTIFIER.id
			{
					final Symbol _symbol_type = _symbols[offset + 1];
					final TypeExpr type = (TypeExpr) _symbol_type.value;
					final Symbol id = _symbols[offset + 2];
					 return new Symbol(new AtomicPortDecl((String)id.value, type));
			}
			case 109: // port_decl = MULTI IDENTIFIER.id
			{
					final Symbol id = _symbols[offset + 2];
					 return new Symbol(new AtomicPortDecl((String)id.value, null));
			}
			case 110: // port_decl = MULTI type.type IDENTIFIER.id
			{
					final Symbol _symbol_type = _symbols[offset + 2];
					final TypeExpr type = (TypeExpr) _symbol_type.value;
					final Symbol id = _symbols[offset + 3];
					 return new Symbol(new AtomicPortDecl((String)id.value, type));
			}
			case 111: // port_decl_list_opt = 
			{
					 return new Symbol(new CompositePortDecl());
			}
			case 112: // port_decl_list_opt = port_decl_list.l
			{
					final Symbol _symbol_l = _symbols[offset + 1];
					final CompositePortDecl l = (CompositePortDecl) _symbol_l.value;
					 return _symbol_l;
			}
			case 113: // port_decl_list = port_decl.port_decl
			{
					final Symbol _symbol_port_decl = _symbols[offset + 1];
					final PortDecl port_decl = (PortDecl) _symbol_port_decl.value;
					 CompositePortDecl l = new CompositePortDecl(); l.addChild(port_decl); return new Symbol(l);
			}
			case 114: // port_decl_list = port_decl_list.l COMMA port_decl.d
			{
					final Symbol _symbol_l = _symbols[offset + 1];
					final CompositePortDecl l = (CompositePortDecl) _symbol_l.value;
					final Symbol _symbol_d = _symbols[offset + 3];
					final PortDecl d = (PortDecl) _symbol_d.value;
					 l.addChild(d); return _symbol_l;
			}
			case 115: // type_bound = LT type.type
			{
					final Symbol _symbol_type = _symbols[offset + 2];
					final TypeExpr type = (TypeExpr) _symbol_type.value;
					 return _symbol_type;
			}
			case 116: // type_bound_opt = 
			{
					 return new Symbol(null);
			}
			case 117: // type_bound_opt = type_bound.n
			{
					final Symbol _symbol_n = _symbols[offset + 1];
					final TypeExpr n = (TypeExpr) _symbol_n.value;
					 return _symbol_n;
			}
			case 118: // type_parameter = IDENTIFIER.id type_bound_opt.type_bound
			{
					final Symbol id = _symbols[offset + 1];
					final Symbol _symbol_type_bound = _symbols[offset + 2];
					final TypeExpr type_bound = (TypeExpr) _symbol_type_bound.value;
					 return new Symbol(new ParDeclType((String)id.value));
			}
			case 121: // type_parameter_block = LBRACK opt$type_parameter_list.l RBRACK
			{
					final Symbol _symbol_l = _symbols[offset + 2];
					final ArrayList l = (ArrayList) _symbol_l.value;
					 return _symbol_l;
			}
			case 122: // type_parameter_list = type_parameter.tp
			{
					final Symbol _symbol_tp = _symbols[offset + 1];
					final ParDeclType tp = (ParDeclType) _symbol_tp.value;
					 ArrayList l = new ArrayList(); l.add(tp); return new Symbol(l);
			}
			case 123: // type_parameter_list = type_parameter_list.l COMMA type_parameter.tp
			{
					final Symbol _symbol_l = _symbols[offset + 1];
					final ArrayList l = (ArrayList) _symbol_l.value;
					final Symbol _symbol_tp = _symbols[offset + 3];
					final ParDeclType tp = (ParDeclType) _symbol_tp.value;
					 l.add(tp); return _symbol_l;
			}
			case 124: // type_list = type.t
			{
					final Symbol _symbol_t = _symbols[offset + 1];
					final TypeExpr t = (TypeExpr) _symbol_t.value;
					 ArrayList l = new ArrayList(); l.add(t); return new Symbol(l);
			}
			case 125: // type_list = type_list.l COMMA type.t
			{
					final Symbol _symbol_l = _symbols[offset + 1];
					final ArrayList l = (ArrayList) _symbol_l.value;
					final Symbol _symbol_t = _symbols[offset + 3];
					final TypeExpr t = (TypeExpr) _symbol_t.value;
					 l.add(t); return _symbol_l;
			}
			case 126: // type = IDENTIFIER.id
			{
					final Symbol id = _symbols[offset + 1];
					 return new Symbol(new TypeExpr((String)id.value));
			}
			case 129: // type = IDENTIFIER.id LBRACK opt$type_list.t RBRACK
			{
					final Symbol id = _symbols[offset + 1];
					final Symbol _symbol_t = _symbols[offset + 3];
					final ArrayList t = (ArrayList) _symbol_t.value;
					 return new Symbol(t==null ? new TypeExpr((String)id.value) : new TypeExpr((String)id.value, (TypeExpr[])t.toArray(new TypeExpr[t.size()])));
			}
			case 132: // type = IDENTIFIER.id LPAREN opt$type_attribute_list.attributes RPAREN
			{
					final Symbol id = _symbols[offset + 1];
					final Symbol _symbol_attributes = _symbols[offset + 3];
					final ArrayList attributes = (ArrayList) _symbol_attributes.value;
					 Map<String,Expression> valueParameters = new java.util.HashMap();
                                                                   Map<String,TypeExpr> typeParameters = new java.util.HashMap();
                                                                   for(Map.Entry map : (ArrayList<Map.Entry>)attributes){
                                                                     if(map.getValue() instanceof Expression){
                                                                       valueParameters.put((String)map.getKey(), (Expression)map.getValue());
                                                                     } else {
                                                                       typeParameters.put((String)map.getKey(), (TypeExpr)map.getValue());
                                                                     }
                                                                   }
                                                                   return new Symbol(new TypeExpr((String)id.value, typeParameters, valueParameters));
			}
			case 133: // type = LBRACK opt$type_list.param EDGE type.result_type RBRACK
			{
					final Symbol _symbol_param = _symbols[offset + 2];
					final ArrayList param = (ArrayList) _symbol_param.value;
					final Symbol _symbol_result_type = _symbols[offset + 4];
					final TypeExpr result_type = (TypeExpr) _symbol_result_type.value;
					 return new Symbol(null);
			}
			case 134: // type = LBRACK opt$type_list.param EDGE RBRACK
			{
					final Symbol _symbol_param = _symbols[offset + 2];
					final ArrayList param = (ArrayList) _symbol_param.value;
					 return new Symbol(null);
			}
			case 135: // type_attribute_list = type_attribute.t
			{
					final Symbol _symbol_t = _symbols[offset + 1];
					final Map.Entry t = (Map.Entry) _symbol_t.value;
					 ArrayList l = new ArrayList(); l.add(t); return new Symbol(l);
			}
			case 136: // type_attribute_list = type_attribute_list.l COMMA type_attribute.t
			{
					final Symbol _symbol_l = _symbols[offset + 1];
					final ArrayList l = (ArrayList) _symbol_l.value;
					final Symbol _symbol_t = _symbols[offset + 3];
					final Map.Entry t = (Map.Entry) _symbol_t.value;
					 l.add(t); return _symbol_l;
			}
			case 137: // type_attribute = IDENTIFIER.id COLON type.type
			{
					final Symbol id = _symbols[offset + 1];
					final Symbol _symbol_type = _symbols[offset + 3];
					final TypeExpr type = (TypeExpr) _symbol_type.value;
					 return new Symbol(new AbstractMap.SimpleEntry((String)id.value, type));
			}
			case 138: // type_attribute = IDENTIFIER.id EQ expression.e
			{
					final Symbol id = _symbols[offset + 1];
					final Symbol _symbol_e = _symbols[offset + 3];
					final Expression e = (Expression) _symbol_e.value;
					 return new Symbol(new AbstractMap.SimpleEntry((String)id.value, e));
			}
			case 139: // edge_type = EDGE type.t
			{
					final Symbol _symbol_t = _symbols[offset + 2];
					final TypeExpr t = (TypeExpr) _symbol_t.value;
					 return _symbol_t;
			}
			case 144: // procedure_expr_body = LPAREN opt$formal_parameter_list.param RPAREN opt$decl_block.decl stmt_block_opt.body end_proc
			{
					final Symbol _symbol_param = _symbols[offset + 2];
					final ArrayList param = (ArrayList) _symbol_param.value;
					final Symbol _symbol_decl = _symbols[offset + 4];
					final ArrayList decl = (ArrayList) _symbol_decl.value;
					final Symbol _symbol_body = _symbols[offset + 5];
					final ArrayList body = (ArrayList) _symbol_body.value;
					 return new Symbol(new ExprProc(new ParDeclType[0], 
                                                                                                                    param==null ? new ParDeclValue[0] : (ParDeclValue[])param.toArray(new ParDeclValue[param.size()]),
                                                                                                                    new DeclType[0],
                                                                                                                    decl==null ? new DeclVar[0] : (DeclVar[])decl.toArray(new DeclVar[decl.size()]),
                                                                                                                    (Statement[])body.toArray(new Statement[body.size()])));
			}
			case 145: // stmt_block_opt = 
			{
					 return new Symbol(new ArrayList());
			}
			case 146: // stmt_block_opt = do_begin statement_list_opt.s
			{
					final Symbol _symbol_s = _symbols[offset + 2];
					final ArrayList s = (ArrayList) _symbol_s.value;
					 return _symbol_s;
			}
			case 147: // lambda_expr_body = LPAREN opt$formal_parameter_list.param RPAREN expression.body end_lambda
			{
					final Symbol _symbol_param = _symbols[offset + 2];
					final ArrayList param = (ArrayList) _symbol_param.value;
					final Symbol _symbol_body = _symbols[offset + 4];
					final Expression body = (Expression) _symbol_body.value;
					 return new Symbol(new ExprLambda(new ParDeclType[0],
                                             param==null ? new ParDeclValue[0] : (ParDeclValue[])param.toArray(new ParDeclValue[param.size()]),
                                             new DeclType[0], 
                                             new DeclVar[0],
                                             body,
                                             null));
			}
			case 148: // lambda_expr_body = LPAREN opt$formal_parameter_list.param RPAREN opt$decl_block.decl COLON expression.body end_lambda
			{
					final Symbol _symbol_param = _symbols[offset + 2];
					final ArrayList param = (ArrayList) _symbol_param.value;
					final Symbol _symbol_decl = _symbols[offset + 4];
					final ArrayList decl = (ArrayList) _symbol_decl.value;
					final Symbol _symbol_body = _symbols[offset + 6];
					final Expression body = (Expression) _symbol_body.value;
					 return new Symbol(new ExprLambda(new ParDeclType[0],
                                             param==null ? new ParDeclValue[0] : (ParDeclValue[])param.toArray(new ParDeclValue[param.size()]),
                                             new DeclType[0],
                                             decl==null ? new DeclVar[0] : (DeclVar[])decl.toArray(new DeclVar[decl.size()]),
                                             body,
                                             null));
			}
			case 149: // lambda_expr_body = LPAREN opt$formal_parameter_list.param RPAREN edge_type.t opt$decl_block.decl COLON expression.body end_lambda
			{
					final Symbol _symbol_param = _symbols[offset + 2];
					final ArrayList param = (ArrayList) _symbol_param.value;
					final Symbol _symbol_t = _symbols[offset + 4];
					final TypeExpr t = (TypeExpr) _symbol_t.value;
					final Symbol _symbol_decl = _symbols[offset + 5];
					final ArrayList decl = (ArrayList) _symbol_decl.value;
					final Symbol _symbol_body = _symbols[offset + 7];
					final Expression body = (Expression) _symbol_body.value;
					 return new Symbol(new ExprLambda(new ParDeclType[0],
                                             param==null ? new ParDeclValue[0] : (ParDeclValue[])param.toArray(new ParDeclValue[param.size()]),
                                             new DeclType[0],
                                             decl==null ? new DeclVar[0] : (DeclVar[])decl.toArray(new DeclVar[decl.size()]),
                                             body,
                                             t));
			}
			case 150: // map_list = map_entry.m
			{
					final Symbol _symbol_m = _symbols[offset + 1];
					final Map.Entry m = (Map.Entry) _symbol_m.value;
					 ArrayList l = new ArrayList(); l.add(m); return new Symbol(l);
			}
			case 151: // map_list = map_list.l COMMA map_entry.m
			{
					final Symbol _symbol_l = _symbols[offset + 1];
					final ArrayList l = (ArrayList) _symbol_l.value;
					final Symbol _symbol_m = _symbols[offset + 3];
					final Map.Entry m = (Map.Entry) _symbol_m.value;
					 l.add(m); return _symbol_l;
			}
			case 152: // map_entry = expression.e1 ARROW expression.e2
			{
					final Symbol _symbol_e1 = _symbols[offset + 1];
					final Expression e1 = (Expression) _symbol_e1.value;
					final Symbol _symbol_e2 = _symbols[offset + 3];
					final Expression e2 = (Expression) _symbol_e2.value;
					 return new Symbol(new AbstractMap.SimpleEntry(e1, e2));
			}
			case 153: // tail = BAR expression.e
			{
					final Symbol _symbol_e = _symbols[offset + 2];
					final Expression e = (Expression) _symbol_e.value;
					 return _symbol_e;
			}
			case 154: // expression_list = expression.e
			{
					final Symbol _symbol_e = _symbols[offset + 1];
					final Expression e = (Expression) _symbol_e.value;
					 ArrayList l = new ArrayList(); l.add(e); return new Symbol(l);
			}
			case 155: // expression_list = expression_list.l COMMA expression.e
			{
					final Symbol _symbol_l = _symbols[offset + 1];
					final ArrayList l = (ArrayList) _symbol_l.value;
					final Symbol _symbol_e = _symbols[offset + 3];
					final Expression e = (Expression) _symbol_e.value;
					 l.add(e); return _symbol_l;
			}
			case 156: // expression_list_opt = 
			{
					 return new Symbol(new ArrayList());
			}
			case 157: // expression_list_opt = expression_list.n
			{
					final Symbol _symbol_n = _symbols[offset + 1];
					final ArrayList n = (ArrayList) _symbol_n.value;
					 return _symbol_n;
			}
			case 160: // method_invocation = simple_expression.function LPAREN opt$expression_list.args RPAREN
			{
					final Symbol _symbol_function = _symbols[offset + 1];
					final Expression function = (Expression) _symbol_function.value;
					final Symbol _symbol_args = _symbols[offset + 3];
					final ArrayList args = (ArrayList) _symbol_args.value;
					 return new Symbol(new ExprApplication(function, args==null ? new Expression[0] : (Expression[])args.toArray(new Expression[args.size()])));
			}
			case 161: // literal = INTEGER_LITERAL.txt
			{
					final Symbol txt = _symbols[offset + 1];
					 return new Symbol(new ExprLiteral(ExprLiteral.litInteger, ((String)txt.value)));
			}
			case 162: // literal = LONG_LITERAL.txt
			{
					final Symbol txt = _symbols[offset + 1];
					 return new Symbol(new ExprLiteral(ExprLiteral.litInteger, ((String)txt.value)));
			}
			case 163: // literal = FLOATING_POINT_LITERAL.txt
			{
					final Symbol txt = _symbols[offset + 1];
					 return new Symbol(new ExprLiteral(ExprLiteral.litInteger, ((String)txt.value)));
			}
			case 164: // literal = DOUBLE_LITERAL.txt
			{
					final Symbol txt = _symbols[offset + 1];
					 return new Symbol(new ExprLiteral(ExprLiteral.litReal, ((String)txt.value)));
			}
			case 165: // literal = TRUE_LITERAL.txt
			{
					final Symbol txt = _symbols[offset + 1];
					 return new Symbol(new ExprLiteral(ExprLiteral.litTrue, ((String)txt.value)));
			}
			case 166: // literal = FALSE_LITERAL.txt
			{
					final Symbol txt = _symbols[offset + 1];
					 return new Symbol(new ExprLiteral(ExprLiteral.litFalse, ((String)txt.value)));
			}
			case 167: // literal = CHARACTER_LITERAL.txt
			{
					final Symbol txt = _symbols[offset + 1];
					 return new Symbol(new ExprLiteral(ExprLiteral.litChar, ((String)txt.value)));
			}
			case 168: // literal = STRING_LITERAL.txt
			{
					final Symbol txt = _symbols[offset + 1];
					 return new Symbol(new ExprLiteral(ExprLiteral.litString, ((String)txt.value)));
			}
			case 169: // literal = NULL_LITERAL.txt
			{
					final Symbol txt = _symbols[offset + 1];
					 return new Symbol(new ExprLiteral(ExprLiteral.litNull, ((String)txt.value)));
			}
			case 170: // primary = literal.l
			{
					final Symbol _symbol_l = _symbols[offset + 1];
					final ExprLiteral l = (ExprLiteral) _symbol_l.value;
					 return _symbol_l;
			}
			case 171: // primary = LPAREN expression.e RPAREN
			{
					final Symbol _symbol_e = _symbols[offset + 2];
					final Expression e = (Expression) _symbol_e.value;
					 return new ParenthesSymbol(_symbol_e);
			}
			case 172: // primary = LPAREN.start expression.e DOUBLECOLON type.t RPAREN
			{
					final Symbol start = _symbols[offset + 1];
					final Symbol _symbol_e = _symbols[offset + 2];
					final Expression e = (Expression) _symbol_e.value;
					final Symbol _symbol_t = _symbols[offset + 4];
					final TypeExpr t = (TypeExpr) _symbol_t.value;
					 parseProblems.add("Type assertion is not supported. Assertion is ignored at " + Symbol.getLine(start.getStart()) + ", " + Symbol.getColumn(start.getStart()));
			}
			case 173: // simple_expression = primary.p
			{
					final Symbol _symbol_p = _symbols[offset + 1];
					final Expression p = (Expression) _symbol_p.value;
					 return _symbol_p;
			}
			case 174: // simple_expression = variable.v
			{
					final Symbol _symbol_v = _symbols[offset + 1];
					final Variable v = (Variable) _symbol_v.value;
					 return new Symbol(new ExprVariable(v));
			}
			case 175: // simple_expression = OLD variable.v
			{
					final Symbol _symbol_v = _symbols[offset + 2];
					final Variable v = (Variable) _symbol_v.value;
					 return new Symbol(new ExprVariable(v));
			}
			case 176: // simple_expression = method_invocation.m
			{
					final Symbol _symbol_m = _symbols[offset + 1];
					final ExprApplication m = (ExprApplication) _symbol_m.value;
					 return _symbol_m;
			}
			case 177: // simple_expression = IF expression.c THEN expression.e1 ELSE expression.e2 END
			{
					final Symbol _symbol_c = _symbols[offset + 2];
					final Expression c = (Expression) _symbol_c.value;
					final Symbol _symbol_e1 = _symbols[offset + 4];
					final Expression e1 = (Expression) _symbol_e1.value;
					final Symbol _symbol_e2 = _symbols[offset + 6];
					final Expression e2 = (Expression) _symbol_e2.value;
					 return new Symbol(new ExprIf(c, e1, e2));
			}
			case 178: // simple_expression = LBRACE expression_list_opt.e RBRACE
			{
					final Symbol _symbol_e = _symbols[offset + 2];
					final ArrayList e = (ArrayList) _symbol_e.value;
					 return new Symbol(new ExprSet((Expression[])e.toArray(new Expression[e.size()])));
			}
			case 179: // simple_expression = LBRACE expression_list_opt.e COLON for_generator_list.l RBRACE
			{
					final Symbol _symbol_e = _symbols[offset + 2];
					final ArrayList e = (ArrayList) _symbol_e.value;
					final Symbol _symbol_l = _symbols[offset + 4];
					final ArrayList l = (ArrayList) _symbol_l.value;
					 return new Symbol(new ExprSet((Expression[])e.toArray(new Expression[e.size()]), (GeneratorFilter[])l.toArray(new GeneratorFilter[l.size()])));
			}
			case 180: // simple_expression = LBRACK expression_list_opt.e RBRACK
			{
					final Symbol _symbol_e = _symbols[offset + 2];
					final ArrayList e = (ArrayList) _symbol_e.value;
					 return new Symbol(new ExprList((Expression[])e.toArray(new Expression[e.size()])));
			}
			case 181: // simple_expression = LBRACK expression_list_opt.e tail.tail RBRACK
			{
					final Symbol _symbol_e = _symbols[offset + 2];
					final ArrayList e = (ArrayList) _symbol_e.value;
					final Symbol _symbol_tail = _symbols[offset + 3];
					final Expression tail = (Expression) _symbol_tail.value;
					 return new Symbol(new ExprList((Expression[])e.toArray(new Expression[e.size()])));
			}
			case 182: // simple_expression = LBRACK expression_list_opt.e COLON for_generator_list.l RBRACK
			{
					final Symbol _symbol_e = _symbols[offset + 2];
					final ArrayList e = (ArrayList) _symbol_e.value;
					final Symbol _symbol_l = _symbols[offset + 4];
					final ArrayList l = (ArrayList) _symbol_l.value;
					 return new Symbol(new ExprList((Expression[])e.toArray(new Expression[e.size()]), (GeneratorFilter[])l.toArray(new GeneratorFilter[l.size()])));
			}
			case 183: // simple_expression = LBRACK expression_list_opt.e COLON for_generator_list.l tail.tail RBRACK
			{
					final Symbol _symbol_e = _symbols[offset + 2];
					final ArrayList e = (ArrayList) _symbol_e.value;
					final Symbol _symbol_l = _symbols[offset + 4];
					final ArrayList l = (ArrayList) _symbol_l.value;
					final Symbol _symbol_tail = _symbols[offset + 5];
					final Expression tail = (Expression) _symbol_tail.value;
					 return new Symbol(new ExprList((Expression[])e.toArray(new Expression[e.size()]), (GeneratorFilter[])l.toArray(new GeneratorFilter[l.size()])));
			}
			case 186: // simple_expression = MAP LBRACE opt$map_list.m RBRACE
			{
					final Symbol _symbol_m = _symbols[offset + 3];
					final ArrayList m = (ArrayList) _symbol_m.value;
					 return new Symbol(new ExprMap(m==null? new java.util.Map.Entry[0] : 
                                                                                                              (java.util.Map.Entry<Expression,Expression>[])m.toArray(new java.util.Map.Entry[m.size()])));
			}
			case 187: // simple_expression = MAP LBRACE opt$map_list.m COLON for_generator_list.generators RBRACE
			{
					final Symbol _symbol_m = _symbols[offset + 3];
					final ArrayList m = (ArrayList) _symbol_m.value;
					final Symbol _symbol_generators = _symbols[offset + 5];
					final ArrayList generators = (ArrayList) _symbol_generators.value;
					 return new Symbol(new ExprMap(m==null? new java.util.Map.Entry[0] : 
                                                                                                              (java.util.Map.Entry<Expression,Expression>[])m.toArray(new java.util.Map.Entry[m.size()]), 
                                                                                                              (GeneratorFilter[])generators.toArray(new GeneratorFilter[generators.size()])));
			}
			case 188: // simple_expression = LET decl_list.l COLON expression.e end_let
			{
					final Symbol _symbol_l = _symbols[offset + 2];
					final ArrayList l = (ArrayList) _symbol_l.value;
					final Symbol _symbol_e = _symbols[offset + 4];
					final Expression e = (Expression) _symbol_e.value;
					 return new Symbol(new ExprLet(new DeclType[0], (DeclVar[])l.toArray(new DeclVar[l.size()]), e));
			}
			case 189: // simple_expression = LAMBDA lambda_expr_body.lambda
			{
					final Symbol _symbol_lambda = _symbols[offset + 2];
					final ExprLambda lambda = (ExprLambda) _symbol_lambda.value;
					 return _symbol_lambda;
			}
			case 190: // simple_expression = CONST LAMBDA lambda_expr_body.lambda
			{
					final Symbol _symbol_lambda = _symbols[offset + 3];
					final ExprLambda lambda = (ExprLambda) _symbol_lambda.value;
					 return _symbol_lambda;
			}
			case 191: // simple_expression = PROC procedure_expr_body.p
			{
					final Symbol _symbol_p = _symbols[offset + 2];
					final ExprProc p = (ExprProc) _symbol_p.value;
					 return _symbol_p;
			}
			case 192: // unary_expression = simple_expression.e
			{
					final Symbol _symbol_e = _symbols[offset + 1];
					final Expression e = (Expression) _symbol_e.value;
					 return _symbol_e;
			}
			case 193: // unary_expression = operator.operator unary_expression.expr
			{
					final Symbol _symbol_operator = _symbols[offset + 1];
					final String operator = (String) _symbol_operator.value;
					final Symbol _symbol_expr = _symbols[offset + 2];
					final Expression expr = (Expression) _symbol_expr.value;
					 return new Symbol(new ExprUnaryOp(operator, expr));
			}
			case 194: // indexing_expression = unary_expression.e
			{
					final Symbol _symbol_e = _symbols[offset + 1];
					final Expression e = (Expression) _symbol_e.value;
					 return _symbol_e;
			}
			case 195: // indexing_expression = indexer.i
			{
					final Symbol i = _symbols[offset + 1];
					 return i;
			}
			case 196: // indexing_expression = indexing_expression.p DOT field.f
			{
					final Symbol _symbol_p = _symbols[offset + 1];
					final Expression p = (Expression) _symbol_p.value;
					final Symbol _symbol_f = _symbols[offset + 3];
					final Field f = (Field) _symbol_f.value;
					 return new Symbol(new ExprField(p, f));
			}
			case 197: // indexer = indexer_start.s expression.i RBRACK
			{
					final Symbol _symbol_s = _symbols[offset + 1];
					final Expression s = (Expression) _symbol_s.value;
					final Symbol _symbol_i = _symbols[offset + 2];
					final Expression i = (Expression) _symbol_i.value;
					 return new Symbol(new ExprIndexer(s, i));
			}
			case 198: // indexer_start = indexing_expression.e LBRACK
			{
					final Symbol _symbol_e = _symbols[offset + 1];
					final Expression e = (Expression) _symbol_e.value;
					 return _symbol_e;
			}
			case 199: // indexer_start = indexer_start.s expression.i COMMA
			{
					final Symbol _symbol_s = _symbols[offset + 1];
					final Expression s = (Expression) _symbol_s.value;
					final Symbol _symbol_i = _symbols[offset + 2];
					final Expression i = (Expression) _symbol_i.value;
					 return new Symbol(new ExprIndexer(s, i));
			}
			case 200: // expression = indexing_expression.e
			{
					final Symbol _symbol_e = _symbols[offset + 1];
					final Expression e = (Expression) _symbol_e.value;
					 return _symbol_e;
			}
			case 201: // expression = expression.arg1 operator.operator indexing_expression.arg2
			{
					final Symbol _symbol_arg1 = _symbols[offset + 1];
					final Expression arg1 = (Expression) _symbol_arg1.value;
					final Symbol _symbol_operator = _symbols[offset + 2];
					final String operator = (String) _symbol_operator.value;
					final Symbol _symbol_arg2 = _symbols[offset + 3];
					final Expression arg2 = (Expression) _symbol_arg2.value;
					 String[] operators;
                                                               Expression[] operands;
                                                               boolean arg1IsPar = _symbol_arg1 instanceof ParenthesSymbol;
                                                               if((arg1 instanceof ExprBinaryOp) && !(arg1IsPar)){
                                                                 ExprBinaryOp expr = (ExprBinaryOp)arg1;
                                                                 operators = Arrays.copyOf(expr.getOperations(), expr.getOperations().length + 1);
                                                                 operators[operators.length-1] = operator;
                                                                 operands = Arrays.copyOf(expr.getOperands(), expr.getOperands().length + 1);
                                                                 operands[operands.length-1] = arg2;
                                                               } else {
                                                                 operators = new String[1];
                                                                 operators[0] = operator;
                                                                 operands = new Expression[2];
                                                                 operands[0] = arg1;
                                                                 operands[1] = arg2;
                                                               }
                                                               return new Symbol(new ExprBinaryOp(operators, operands));
			}
			case 202: // operator = OPERATOR.op
			{
					final Symbol op = _symbols[offset + 1];
					 return op;
			}
			case 203: // operator = EQ.op
			{
					final Symbol op = _symbols[offset + 1];
					 return op;
			}
			case 204: // operator = IN.op
			{
					final Symbol op = _symbols[offset + 1];
					 return op;
			}
			case 205: // operator = GT.op
			{
					final Symbol op = _symbols[offset + 1];
					 return op;
			}
			case 206: // operator = MULT.op
			{
					final Symbol op = _symbols[offset + 1];
					 return op;
			}
			case 207: // formal_parameter = IDENTIFIER.id
			{
					final Symbol id = _symbols[offset + 1];
					 return new Symbol(new ParDeclValue((String)id.value, null));
			}
			case 208: // formal_parameter = type.t IDENTIFIER.id
			{
					final Symbol _symbol_t = _symbols[offset + 1];
					final TypeExpr t = (TypeExpr) _symbol_t.value;
					final Symbol id = _symbols[offset + 2];
					 return new Symbol(new ParDeclValue((String)id.value, t));
			}
			case 209: // formal_parameter_list = formal_parameter.p
			{
					final Symbol _symbol_p = _symbols[offset + 1];
					final ParDeclValue p = (ParDeclValue) _symbol_p.value;
					 ArrayList l = new ArrayList(); l.add(p); return new Symbol(l);
			}
			case 210: // formal_parameter_list = formal_parameter_list.l COMMA formal_parameter.p
			{
					final Symbol _symbol_l = _symbols[offset + 1];
					final ArrayList l = (ArrayList) _symbol_l.value;
					final Symbol _symbol_p = _symbols[offset + 3];
					final ParDeclValue p = (ParDeclValue) _symbol_p.value;
					 l.add(p);  return _symbol_l;
			}
			case 211: // statement = expression.lhs COLONEQ expression.value SEMICOLON
			{
					final Symbol _symbol_lhs = _symbols[offset + 1];
					final Expression lhs = (Expression) _symbol_lhs.value;
					final Symbol _symbol_value = _symbols[offset + 3];
					final Expression value = (Expression) _symbol_value.value;
					 LValue lvalue = expressionToLValue(lhs);
                                                         if (lvalue != null) return new Symbol(new StmtAssignment(lvalue, value));
                                                         newError("Illegal left hand sign of assignment.", _symbol_lhs);
                                                         return new Symbol(new StmtAssignment(new LValueVariable(new Variable("$illegal")), value));
			}
			case 212: // statement = method_invocation.m SEMICOLON
			{
					final Symbol _symbol_m = _symbols[offset + 1];
					final ExprApplication m = (ExprApplication) _symbol_m.value;
					 return new Symbol(new StmtCall(m.getFunction(), m.getArgs()));
			}
			case 213: // statement = BEGIN statement_list_opt.s END
			{
					final Symbol _symbol_s = _symbols[offset + 2];
					final ArrayList s = (ArrayList) _symbol_s.value;
					 return new Symbol(new StmtBlock(new DeclType[0], new DeclVar[0], (Statement[])s.toArray(new Statement[s.size()])));
			}
			case 214: // statement = BEGIN VAR decl_list.d DO statement_list_opt.s END
			{
					final Symbol _symbol_d = _symbols[offset + 3];
					final ArrayList d = (ArrayList) _symbol_d.value;
					final Symbol _symbol_s = _symbols[offset + 5];
					final ArrayList s = (ArrayList) _symbol_s.value;
					 return new Symbol(new StmtBlock(new DeclType[0], (DeclVar[])d.toArray(new DeclVar[d.size()]), (Statement[])s.toArray(new Statement[s.size()])));
			}
			case 215: // statement = IF expression.e THEN statement_list_opt.s end_if
			{
					final Symbol _symbol_e = _symbols[offset + 2];
					final Expression e = (Expression) _symbol_e.value;
					final Symbol _symbol_s = _symbols[offset + 4];
					final ArrayList s = (ArrayList) _symbol_s.value;
					 return new Symbol(new StmtIf(e, new StmtBlock(null, null, (Statement[])s.toArray(new Statement[s.size()])), null));
			}
			case 216: // statement = IF expression.e THEN statement_list_opt.s1 ELSE statement_list_opt.s2 end_if
			{
					final Symbol _symbol_e = _symbols[offset + 2];
					final Expression e = (Expression) _symbol_e.value;
					final Symbol _symbol_s1 = _symbols[offset + 4];
					final ArrayList s1 = (ArrayList) _symbol_s1.value;
					final Symbol _symbol_s2 = _symbols[offset + 6];
					final ArrayList s2 = (ArrayList) _symbol_s2.value;
					 return new Symbol(new StmtIf(e, 
                                                                                                                 new StmtBlock(null, null, (Statement[])s1.toArray(new Statement[s1.size()])),
                                                                                                                 new StmtBlock(null, null, (Statement[])s2.toArray(new Statement[s2.size()]))));
			}
			case 217: // statement = WHILE expression.e decl_block_opt.d DO statement_list_opt.s end_while
			{
					final Symbol _symbol_e = _symbols[offset + 2];
					final Expression e = (Expression) _symbol_e.value;
					final Symbol _symbol_d = _symbols[offset + 3];
					final ArrayList d = (ArrayList) _symbol_d.value;
					final Symbol _symbol_s = _symbols[offset + 5];
					final ArrayList s = (ArrayList) _symbol_s.value;
					 return new Symbol(new StmtWhile(e, new StmtBlock(new DeclType[0],
                                                                                                                              (DeclVar[])d.toArray(new DeclVar[d.size()]),
                                                                                                                              (Statement[])s.toArray(new Statement[s.size()]))));
			}
			case 221: // statement = for_generator_list.g DO statement_list_opt.s end_foreach
			{
					final Symbol _symbol_g = _symbols[offset + 1];
					final ArrayList g = (ArrayList) _symbol_g.value;
					final Symbol _symbol_s = _symbols[offset + 3];
					final ArrayList s = (ArrayList) _symbol_s.value;
					 return new Symbol(new StmtForeach((GeneratorFilter[])g.toArray(new GeneratorFilter[g.size()]),
                                                                                                               new StmtBlock(new DeclType[0], new DeclVar[0], (Statement[])s.toArray(new Statement[s.size()]))));
			}
			case 222: // statement = for_generator_list.g decl_block.d DO statement_list_opt.s end_foreach
			{
					final Symbol _symbol_g = _symbols[offset + 1];
					final ArrayList g = (ArrayList) _symbol_g.value;
					final Symbol _symbol_d = _symbols[offset + 2];
					final ArrayList d = (ArrayList) _symbol_d.value;
					final Symbol _symbol_s = _symbols[offset + 4];
					final ArrayList s = (ArrayList) _symbol_s.value;
					 return new Symbol(new StmtForeach((GeneratorFilter[])g.toArray(new GeneratorFilter[g.size()]),
                                                                                                               new StmtBlock(new DeclType[0], (DeclVar[])d.toArray(new DeclVar[d.size()]), (Statement[])s.toArray(new Statement[s.size()]))));
			}
			case 223: // choose_generator_list = CHOOSE generator_variable_list.vars IN expression.e
			{
					final Symbol _symbol_vars = _symbols[offset + 2];
					final ArrayList vars = (ArrayList) _symbol_vars.value;
					final Symbol _symbol_e = _symbols[offset + 4];
					final Expression e = (Expression) _symbol_e.value;
					 ArrayList l = new ArrayList(); l.add(makeGeneratorFilter(null, vars, e, null)); return new Symbol(l);
			}
			case 224: // choose_generator_list = CHOOSE type.t generator_variable_list.vars IN expression.e
			{
					final Symbol _symbol_t = _symbols[offset + 2];
					final TypeExpr t = (TypeExpr) _symbol_t.value;
					final Symbol _symbol_vars = _symbols[offset + 3];
					final ArrayList vars = (ArrayList) _symbol_vars.value;
					final Symbol _symbol_e = _symbols[offset + 5];
					final Expression e = (Expression) _symbol_e.value;
					 ArrayList l = new ArrayList(); l.add(makeGeneratorFilter(t, vars, e, null)); return new Symbol(l);
			}
			case 225: // choose_generator_list = CHOOSE generator_variable_list.vars IN expression.e COMMA expression_list.filters
			{
					final Symbol _symbol_vars = _symbols[offset + 2];
					final ArrayList vars = (ArrayList) _symbol_vars.value;
					final Symbol _symbol_e = _symbols[offset + 4];
					final Expression e = (Expression) _symbol_e.value;
					final Symbol _symbol_filters = _symbols[offset + 6];
					final ArrayList filters = (ArrayList) _symbol_filters.value;
					 ArrayList l = new ArrayList(); l.add(makeGeneratorFilter(null, vars, e, filters)); return new Symbol(l);
			}
			case 226: // choose_generator_list = CHOOSE type.t generator_variable_list.vars IN expression.e COMMA expression_list.filters
			{
					final Symbol _symbol_t = _symbols[offset + 2];
					final TypeExpr t = (TypeExpr) _symbol_t.value;
					final Symbol _symbol_vars = _symbols[offset + 3];
					final ArrayList vars = (ArrayList) _symbol_vars.value;
					final Symbol _symbol_e = _symbols[offset + 5];
					final Expression e = (Expression) _symbol_e.value;
					final Symbol _symbol_filters = _symbols[offset + 7];
					final ArrayList filters = (ArrayList) _symbol_filters.value;
					 ArrayList l = new ArrayList(); l.add(makeGeneratorFilter(t, vars, e, filters)); return new Symbol(l);
			}
			case 227: // choose_generator_list = CHOOSE generator_variable_list.vars IN expression.e COMMA choose_generator_list.l
			{
					final Symbol _symbol_vars = _symbols[offset + 2];
					final ArrayList vars = (ArrayList) _symbol_vars.value;
					final Symbol _symbol_e = _symbols[offset + 4];
					final Expression e = (Expression) _symbol_e.value;
					final Symbol _symbol_l = _symbols[offset + 6];
					final ArrayList l = (ArrayList) _symbol_l.value;
					 l.add(0, makeGeneratorFilter(null, vars, e, null)); return _symbol_l;
			}
			case 228: // choose_generator_list = CHOOSE type.t generator_variable_list.vars IN expression.e COMMA choose_generator_list.l
			{
					final Symbol _symbol_t = _symbols[offset + 2];
					final TypeExpr t = (TypeExpr) _symbol_t.value;
					final Symbol _symbol_vars = _symbols[offset + 3];
					final ArrayList vars = (ArrayList) _symbol_vars.value;
					final Symbol _symbol_e = _symbols[offset + 5];
					final Expression e = (Expression) _symbol_e.value;
					final Symbol _symbol_l = _symbols[offset + 7];
					final ArrayList l = (ArrayList) _symbol_l.value;
					 l.add(0, makeGeneratorFilter(t, vars, e, null)); return _symbol_l;
			}
			case 229: // choose_generator_list = CHOOSE generator_variable_list.vars IN expression.e COMMA expression_list.filters COMMA choose_generator_list.l
			{
					final Symbol _symbol_vars = _symbols[offset + 2];
					final ArrayList vars = (ArrayList) _symbol_vars.value;
					final Symbol _symbol_e = _symbols[offset + 4];
					final Expression e = (Expression) _symbol_e.value;
					final Symbol _symbol_filters = _symbols[offset + 6];
					final ArrayList filters = (ArrayList) _symbol_filters.value;
					final Symbol _symbol_l = _symbols[offset + 8];
					final ArrayList l = (ArrayList) _symbol_l.value;
					 l.add(0, makeGeneratorFilter(null, vars, e, filters)); return _symbol_l;
			}
			case 230: // choose_generator_list = CHOOSE type.t generator_variable_list.vars IN expression.e COMMA expression_list.filters COMMA choose_generator_list.l
			{
					final Symbol _symbol_t = _symbols[offset + 2];
					final TypeExpr t = (TypeExpr) _symbol_t.value;
					final Symbol _symbol_vars = _symbols[offset + 3];
					final ArrayList vars = (ArrayList) _symbol_vars.value;
					final Symbol _symbol_e = _symbols[offset + 5];
					final Expression e = (Expression) _symbol_e.value;
					final Symbol _symbol_filters = _symbols[offset + 7];
					final ArrayList filters = (ArrayList) _symbol_filters.value;
					final Symbol _symbol_l = _symbols[offset + 9];
					final ArrayList l = (ArrayList) _symbol_l.value;
					 l.add(0, makeGeneratorFilter(t, vars, e, filters)); return _symbol_l;
			}
			case 231: // for_generator_list = for_foreach generator_variable_list.vars IN expression.e
			{
					final Symbol _symbol_vars = _symbols[offset + 2];
					final ArrayList vars = (ArrayList) _symbol_vars.value;
					final Symbol _symbol_e = _symbols[offset + 4];
					final Expression e = (Expression) _symbol_e.value;
					 ArrayList l = new ArrayList(); l.add(makeGeneratorFilter(null, vars, e, null)); return new Symbol(l);
			}
			case 232: // for_generator_list = for_foreach type.t generator_variable_list.vars IN expression.e
			{
					final Symbol _symbol_t = _symbols[offset + 2];
					final TypeExpr t = (TypeExpr) _symbol_t.value;
					final Symbol _symbol_vars = _symbols[offset + 3];
					final ArrayList vars = (ArrayList) _symbol_vars.value;
					final Symbol _symbol_e = _symbols[offset + 5];
					final Expression e = (Expression) _symbol_e.value;
					 ArrayList l = new ArrayList(); l.add(makeGeneratorFilter(t, vars, e, null)); return new Symbol(l);
			}
			case 233: // for_generator_list = for_foreach generator_variable_list.vars IN expression.e COMMA expression_list.filters
			{
					final Symbol _symbol_vars = _symbols[offset + 2];
					final ArrayList vars = (ArrayList) _symbol_vars.value;
					final Symbol _symbol_e = _symbols[offset + 4];
					final Expression e = (Expression) _symbol_e.value;
					final Symbol _symbol_filters = _symbols[offset + 6];
					final ArrayList filters = (ArrayList) _symbol_filters.value;
					 ArrayList l = new ArrayList(); l.add(makeGeneratorFilter(null, vars, e, filters)); return new Symbol(l);
			}
			case 234: // for_generator_list = for_foreach type.t generator_variable_list.vars IN expression.e COMMA expression_list.filters
			{
					final Symbol _symbol_t = _symbols[offset + 2];
					final TypeExpr t = (TypeExpr) _symbol_t.value;
					final Symbol _symbol_vars = _symbols[offset + 3];
					final ArrayList vars = (ArrayList) _symbol_vars.value;
					final Symbol _symbol_e = _symbols[offset + 5];
					final Expression e = (Expression) _symbol_e.value;
					final Symbol _symbol_filters = _symbols[offset + 7];
					final ArrayList filters = (ArrayList) _symbol_filters.value;
					 ArrayList l = new ArrayList(); l.add(makeGeneratorFilter(t, vars, e, filters)); return new Symbol(l);
			}
			case 235: // for_generator_list = for_foreach generator_variable_list.vars IN expression.e COMMA for_generator_list.l
			{
					final Symbol _symbol_vars = _symbols[offset + 2];
					final ArrayList vars = (ArrayList) _symbol_vars.value;
					final Symbol _symbol_e = _symbols[offset + 4];
					final Expression e = (Expression) _symbol_e.value;
					final Symbol _symbol_l = _symbols[offset + 6];
					final ArrayList l = (ArrayList) _symbol_l.value;
					 l.add(0, makeGeneratorFilter(null, vars, e, null)); return _symbol_l;
			}
			case 236: // for_generator_list = for_foreach type.t generator_variable_list.vars IN expression.e COMMA for_generator_list.l
			{
					final Symbol _symbol_t = _symbols[offset + 2];
					final TypeExpr t = (TypeExpr) _symbol_t.value;
					final Symbol _symbol_vars = _symbols[offset + 3];
					final ArrayList vars = (ArrayList) _symbol_vars.value;
					final Symbol _symbol_e = _symbols[offset + 5];
					final Expression e = (Expression) _symbol_e.value;
					final Symbol _symbol_l = _symbols[offset + 7];
					final ArrayList l = (ArrayList) _symbol_l.value;
					 l.add(0, makeGeneratorFilter(t, vars, e, null)); return _symbol_l;
			}
			case 237: // for_generator_list = for_foreach generator_variable_list.vars IN expression.e COMMA expression_list.filters COMMA for_generator_list.l
			{
					final Symbol _symbol_vars = _symbols[offset + 2];
					final ArrayList vars = (ArrayList) _symbol_vars.value;
					final Symbol _symbol_e = _symbols[offset + 4];
					final Expression e = (Expression) _symbol_e.value;
					final Symbol _symbol_filters = _symbols[offset + 6];
					final ArrayList filters = (ArrayList) _symbol_filters.value;
					final Symbol _symbol_l = _symbols[offset + 8];
					final ArrayList l = (ArrayList) _symbol_l.value;
					 l.add(0, makeGeneratorFilter(null, vars, e, filters)); return _symbol_l;
			}
			case 238: // for_generator_list = for_foreach type.t generator_variable_list.vars IN expression.e COMMA expression_list.filters COMMA for_generator_list.l
			{
					final Symbol _symbol_t = _symbols[offset + 2];
					final TypeExpr t = (TypeExpr) _symbol_t.value;
					final Symbol _symbol_vars = _symbols[offset + 3];
					final ArrayList vars = (ArrayList) _symbol_vars.value;
					final Symbol _symbol_e = _symbols[offset + 5];
					final Expression e = (Expression) _symbol_e.value;
					final Symbol _symbol_filters = _symbols[offset + 7];
					final ArrayList filters = (ArrayList) _symbol_filters.value;
					final Symbol _symbol_l = _symbols[offset + 9];
					final ArrayList l = (ArrayList) _symbol_l.value;
					 l.add(0, makeGeneratorFilter(t, vars, e, filters)); return _symbol_l;
			}
			case 239: // generator_variable_list = IDENTIFIER.id
			{
					final Symbol id = _symbols[offset + 1];
					 ArrayList l = new ArrayList(); l.add(id); return new Symbol(l);
			}
			case 240: // generator_variable_list = generator_variable_list.l COMMA IDENTIFIER.id
			{
					final Symbol _symbol_l = _symbols[offset + 1];
					final ArrayList l = (ArrayList) _symbol_l.value;
					final Symbol id = _symbols[offset + 3];
					 l.add(id); return _symbol_l;
			}
			case 259: // statement_list_opt = 
			{
					 return new Symbol(new ArrayList());
			}
			case 260: // statement_list_opt = statement_list.l
			{
					final Symbol _symbol_l = _symbols[offset + 1];
					final ArrayList l = (ArrayList) _symbol_l.value;
					 return _symbol_l;
			}
			case 261: // statement_list = statement.n
			{
					final Symbol _symbol_n = _symbols[offset + 1];
					final Statement n = (Statement) _symbol_n.value;
					 ArrayList l = new ArrayList(); l.add(n); return new Symbol(l);
			}
			case 262: // statement_list = statement_list.l statement.n
			{
					final Symbol _symbol_l = _symbols[offset + 1];
					final ArrayList l = (ArrayList) _symbol_l.value;
					final Symbol _symbol_n = _symbols[offset + 2];
					final Statement n = (Statement) _symbol_n.value;
					 l.add(n); return _symbol_l;
			}
			case 0: // opt$type_parameter_block = 
			case 2: // opt$actor_parameter_list = 
			case 6: // opt$lst$network_body_part = 
			case 8: // opt$SEMICOLON = 
			case 18: // opt$lst$network_decl = 
			case 26: // opt$lst$entity = 
			case 30: // opt$param_assign_list = 
			case 32: // opt$tool_attribute_block = 
			case 36: // opt$entity_expr_list = 
			case 47: // opt$lst$entity_statement = 
			case 56: // opt$lst$entity_indexing = 
			case 71: // opt$lst$tool_attribute = 
			case 80: // opt$actor_parameter_init_expression = 
			case 119: // opt$type_parameter_list = 
			case 127: // opt$type_list = 
			case 130: // opt$type_attribute_list = 
			case 140: // opt$formal_parameter_list = 
			case 142: // opt$decl_block = 
			case 158: // opt$expression_list = 
			case 184: // opt$map_list = 
			{
				return new Symbol(null);
			}
			case 1: // opt$type_parameter_block = type_parameter_block
			case 3: // opt$actor_parameter_list = actor_parameter_list
			case 7: // opt$lst$network_body_part = lst$network_body_part
			case 9: // opt$SEMICOLON = SEMICOLON
			case 19: // opt$lst$network_decl = lst$network_decl
			case 27: // opt$lst$entity = lst$entity
			case 31: // opt$param_assign_list = param_assign_list
			case 33: // opt$tool_attribute_block = tool_attribute_block
			case 37: // opt$entity_expr_list = entity_expr_list
			case 48: // opt$lst$entity_statement = lst$entity_statement
			case 57: // opt$lst$entity_indexing = lst$entity_indexing
			case 72: // opt$lst$tool_attribute = lst$tool_attribute
			case 76: // end_network = END
			case 77: // end_network = ENDNETWORK
			case 81: // opt$actor_parameter_init_expression = actor_parameter_init_expression
			case 120: // opt$type_parameter_list = type_parameter_list
			case 128: // opt$type_list = type_list
			case 131: // opt$type_attribute_list = type_attribute_list
			case 141: // opt$formal_parameter_list = formal_parameter_list
			case 143: // opt$decl_block = decl_block
			case 159: // opt$expression_list = expression_list
			case 185: // opt$map_list = map_list
			case 241: // for_foreach = FOREACH.FOREACH
			case 242: // for_foreach = FOR.FOR
			case 243: // do_begin = BEGIN.BEGIN
			case 244: // do_begin = DO.DO
			case 245: // end_choose = END.END
			case 246: // end_choose = ENDCHOOSE.ENDCHOOSE
			case 247: // end_foreach = END.END
			case 248: // end_foreach = ENDFOREACH.ENDFOREACH
			case 249: // end_if = END.END
			case 250: // end_if = ENDIF.ENDIF
			case 251: // end_lambda = END.END
			case 252: // end_lambda = ENDLAMBDA.ENDLAMBDA
			case 253: // end_let = END.END
			case 254: // end_let = ENDLET.ENDLET
			case 255: // end_proc = END.END
			case 256: // end_proc = ENDPROC.ENDPROC
			case 257: // end_while = END.END
			case 258: // end_while = ENDWHILE.ENDWHILE
			{
				return _symbols[offset + 1];
			}
			case 218: // statement = choose_generator_list.l decl_block_opt.do_v DO statement_list_opt.do_s end_choose
			{
				return _symbols[offset + 4];
			}
			case 219: // statement = choose_generator_list.l decl_block_opt.do_v DO statement_list_opt.do_s ELSE statement_list_opt.else_s end_choose
			{
				return _symbols[offset + 6];
			}
			case 220: // statement = choose_generator_list.l decl_block_opt.do_v DO statement_list_opt.do_s ELSE decl_block_opt.else_v DO statement_list_opt.else_s end_choose
			{
				return _symbols[offset + 8];
			}
			default:
				throw new IllegalArgumentException("unknown production #" + rule_num);
		}
	}
}
