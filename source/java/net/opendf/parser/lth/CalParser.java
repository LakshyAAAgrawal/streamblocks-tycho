/* 
 *  @author Per Andersson<Per.Andersson@cs.lth.se>, Lund University
 *  To parse a CAL file use one of the methods:
 *  - public net.opendf.ir.cal.Actor parse(String path, String fileName)
 *  - public net.opendf.ir.cal.Actor parse(File file)
 *
 *  After parsing check for errors in the attribute parseProblems.
 *
 *  The parser is created using jflex and beaver.
 */
 
package net.opendf.parser.lth;

import net.opendf.ir.cal.Action;
import java.util.ArrayList;
import java.util.Map;
import net.opendf.ir.cal.*;
import java.util.AbstractMap;
import net.opendf.ir.*;
import java.io.PrintStream;
import java.util.TreeSet;
import beaver.*;
import java.io.File;
import java.util.Arrays;
import net.opendf.ir.common.*;

/**
 * This class is a LALR parser generated by
 * <a href="http://beaver.sourceforge.net">Beaver</a> v0.9.6.1
 * from the grammar specification "CalParser.beaver".
 */
public class CalParser extends Parser {
	static public class Terminals {
		static public final short EOF = 0;
		static public final short ACTOR = 1;
		static public final short IDENTIFIER = 2;
		static public final short LPAREN = 3;
		static public final short RPAREN = 4;
		static public final short PORTCONN = 5;
		static public final short COLON = 6;
		static public final short EDGE = 7;
		static public final short SEMICOLON = 8;
		static public final short BAR = 9;
		static public final short IMPORT = 10;
		static public final short EQ = 11;
		static public final short IF = 12;
		static public final short THEN = 13;
		static public final short ELSE = 14;
		static public final short END = 15;
		static public final short MAP = 16;
		static public final short LBRACE = 17;
		static public final short RBRACE = 18;
		static public final short BEGIN = 19;
		static public final short VAR = 20;
		static public final short DO = 21;
		static public final short CHOOSE = 22;
		static public final short IN = 23;
		static public final short COMMA = 24;
		static public final short ALL = 25;
		static public final short SCHEDULE = 26;
		static public final short LBRACK = 27;
		static public final short RBRACK = 28;
		static public final short DOUBLECOLON = 29;
		static public final short ACTION = 30;
		static public final short INITIALIZE = 31;
		static public final short PRIORITY = 32;
		static public final short REGEXP = 33;
		static public final short DOT = 34;
		static public final short MUTABLE = 35;
		static public final short EQCOLON = 36;
		static public final short FUNCTION = 37;
		static public final short PROCEDURE = 38;
		static public final short MULTI = 39;
		static public final short LET = 40;
		static public final short CONST = 41;
		static public final short LAMBDA = 42;
		static public final short COLONEQ = 43;
		static public final short WHILE = 44;
		static public final short GUARD = 45;
		static public final short DELAY = 46;
		static public final short AT = 47;
		static public final short ATSTAR = 48;
		static public final short ANY = 49;
		static public final short REPEAT = 50;
		static public final short TIME = 51;
		static public final short INVARIANT = 52;
		static public final short FSM = 53;
		static public final short MULT = 54;
		static public final short GT = 55;
		static public final short ENDACTION = 56;
		static public final short ENDACTOR = 57;
		static public final short ENDINVARIANT = 58;
		static public final short ENDSCHEDULE = 59;
		static public final short LT = 60;
		static public final short ARROW = 61;
		static public final short INTEGER_LITERAL = 62;
		static public final short LONG_LITERAL = 63;
		static public final short FLOATING_POINT_LITERAL = 64;
		static public final short DOUBLE_LITERAL = 65;
		static public final short TRUE_LITERAL = 66;
		static public final short FALSE_LITERAL = 67;
		static public final short CHARACTER_LITERAL = 68;
		static public final short STRING_LITERAL = 69;
		static public final short NULL_LITERAL = 70;
		static public final short OLD = 71;
		static public final short PROC = 72;
		static public final short OPERATOR = 73;
		static public final short FOREACH = 74;
		static public final short FOR = 75;
		static public final short ENDCHOOSE = 76;
		static public final short ENDFOREACH = 77;
		static public final short ENDIF = 78;
		static public final short ENDLAMBDA = 79;
		static public final short ENDLET = 80;
		static public final short ENDPROC = 81;
		static public final short ENDWHILE = 82;

		static public final String[] NAMES = {
			"EOF",
			"ACTOR",
			"IDENTIFIER",
			"LPAREN",
			"RPAREN",
			"PORTCONN",
			"COLON",
			"EDGE",
			"SEMICOLON",
			"BAR",
			"IMPORT",
			"EQ",
			"IF",
			"THEN",
			"ELSE",
			"END",
			"MAP",
			"LBRACE",
			"RBRACE",
			"BEGIN",
			"VAR",
			"DO",
			"CHOOSE",
			"IN",
			"COMMA",
			"ALL",
			"SCHEDULE",
			"LBRACK",
			"RBRACK",
			"DOUBLECOLON",
			"ACTION",
			"INITIALIZE",
			"PRIORITY",
			"REGEXP",
			"DOT",
			"MUTABLE",
			"EQCOLON",
			"FUNCTION",
			"PROCEDURE",
			"MULTI",
			"LET",
			"CONST",
			"LAMBDA",
			"COLONEQ",
			"WHILE",
			"GUARD",
			"DELAY",
			"AT",
			"ATSTAR",
			"ANY",
			"REPEAT",
			"TIME",
			"INVARIANT",
			"FSM",
			"MULT",
			"GT",
			"ENDACTION",
			"ENDACTOR",
			"ENDINVARIANT",
			"ENDSCHEDULE",
			"LT",
			"ARROW",
			"INTEGER_LITERAL",
			"LONG_LITERAL",
			"FLOATING_POINT_LITERAL",
			"DOUBLE_LITERAL",
			"TRUE_LITERAL",
			"FALSE_LITERAL",
			"CHARACTER_LITERAL",
			"STRING_LITERAL",
			"NULL_LITERAL",
			"OLD",
			"PROC",
			"OPERATOR",
			"FOREACH",
			"FOR",
			"ENDCHOOSE",
			"ENDFOREACH",
			"ENDIF",
			"ENDLAMBDA",
			"ENDLET",
			"ENDPROC",
			"ENDWHILE"
		};
	}

	static final ParsingTables PARSING_TABLES = new ParsingTables(
		"U9pjN0TqL5NpdtdRKaYY21995CKkYeWLIx1hW2He510a442mq0H4YlGc20ZIcrIHOWChYj9" +
		"K54N4WWqKUnSRri#zt#$EczsytMIpENpdVuw7F#kPDxVCdVkRkNFdtiTk9ChwcwwZbwcOMj" +
		"3bT0szHDTIQoga3To4DuK$eE7KcPlG6bfBsxWc5V4Mtc3QKb#LlrJbhwOET1aVmMlfRhgVP" +
		"dCp#fE2j8EQS3DkJEaqZz#arNGLDQS7UHIVJeTH3kNIL$GrVKFVqdVqFVr0U#X7Qaahg83w" +
		"q6qM4r$EFzALLDzymfUJpsAYa2cXNHQJ6KDh#28pL33j8ZyTMZ4cQaQlAwRjmFGe7KUrA9j" +
		"EfbEudp7ygSLatkQxQIVdKO2oac8Qm7T0lZyFvlTWd$KJogwVQ3emdSFd2QOyleLJ4$c9Jd" +
		"0ncIt0z2Pjv#lDFxI3R#9k3bDr5nDDvvrMc#bMHKmx#3z0r4KmfL4ztYIOZiBQRUEF5DDpl" +
		"24P9ae3fXscBLzFdm7Jhno47LzOJFmiB3n2BFmv6IOQI3$HQJIKJkLfTBjW6aTrU6GKqqxU" +
		"fPZkf7u9uobDr#vmODhDOxasfGBJfpoEjq6NZQSFWUbWYucQ9lNJ9ZeMg$OclSENyLI9fuT" +
		"vFJnYCHqfVdhTnKI$qky9$TH0CPre$KGVy76K1qozgHgFv5l4Jr$ITFEY#AbNKanOSxe4Uc" +
		"nzWM2wa7VI7xBlyccDQMvUSZ59v2V2j4FNRWVzoJzH9ZMncEXrh7jZnPGFJCt5JpEgWeblG" +
		"mmyJsVJKbcxftaJhn5Ceu09IAAvuBe4#suylw0n$Wdyz3fzR5PHLxgPpk7lU06$8p5kzIpX" +
		"D$WXVY0ffcUmTiz3po4yrzrtPg$PIuUNstUlaC5Qz4LqtCMRwHKxYlVmgrJ8Oq3hr4yDuQT" +
		"5L9jkeYAw0NGGrQLE4a#lObG6tSWzwTYac3wJ4PQwSnrPE$JmOl4J8PxitC244KU34kGdxg" +
		"7nb0jCcn4BfoDEkz8TCik5ejtgmSxbC7T9XiaKid48UhhI65XWr#uIhDsbWgb16IQxTbml8" +
		"QQN5DC95XFmF6TpBKs6vu$1xh3nPF7ib1KiIPeBTY0FTECMDDh6fFWfBvB7QIOmZNBp4mt2" +
		"3DiIndWaZr#3U3gEFkMRJMi#0$jq1pVWWyHFkp1w6oB$4MIiP9WUuwEmFyu2eXtgfrfOmpp" +
		"1z3VYwH2k9tuwb8z6Uo9CVoYcLi1K22HRaR4MOknLvcKpH31DfY9JnEsv3Z9xidYwWfjW$Q" +
		"xc6iXFFQ2l3HUA3hjsCx6J6$1uxECYvAcl#7R4#EaqXQRID4H50Tt3LugE6hH8CNtDawmEe" +
		"BBhPi$CZx2VxTeD0wRx#H5#2dObmkJkaugYuthHCGgHD1JFStXAKhkMyN8dX5Dy23T6DW0c" +
		"iniZZnUxr0Ow4Rvko4$Gf0GnMOAHYJ6r5pzjuubcAUnw59Obm$ITUG6pOUrnFpb9V3qC6Q5" +
		"H3AOp1DFdz6m2J1rvTIMOUeYVTlENl1XdtG$yHL9CNzEPlDT69FpKIJ3zpX$WLkB1vFWi9i" +
		"VFfoN0DCpSK0ccyOBfJ$w3pk8t4EqN9yqdhs57NKHNK5FDksrYycw#d2XvY4cRLru4fkke5" +
		"V2lGnl#GzwrUosFRb5CUTn6Oh8NSl5cqR6G#Wick$y7q60yayNa4EWRGUFeJdSE6aiZQQwi" +
		"$nnvtajBQ5b27HPF0UJjQR8SQxz8$BoE7g2LNZ$Btcz83$75s6SDQ1KzXJpuCZqZUSlgM8#" +
		"PtNts3KhM9llCKvksHcrw3NahkKqLhTL4iUODURv5RzExIMnwZzwdZv0NrIRwX3vtySJPz0" +
		"jtJH0xi#YtIl3S9qZ#Gs5ssEUaSQ0oFDoRKt0VicTHDSuK7v$CrN46M$$aSGwby0mRDtmad" +
		"yHrgI$YB8ySFfvFuLDfClyZEdf6V8mHZSIckOYRSqL7APzlyOJVWNSVu0lsqSSRPPtabEMc" +
		"NCn5INoS1xJjSDFCOtT$teZoPBNfLkx3mxalaBXnsTTypAFDAsYxY#$X2JnTT3JYMHetix6" +
		"phOuvi6cUhDEzF5#GB8LV5jhdFjdqekYGrUBx4UShAhU9L$A3$32lWkJZWkSnb9uKF1lD8$" +
		"mQlsKs0S#xvbb#7tlXG$wOFu6rt$CtPhFfAElq2slS85$zBJh#eaB7iJgSW1Dqxp1KvAGug" +
		"VjeqnRHGVgqdyhNoVknSUD#x3gLVOgKzwNuZzLXFowUCXs57XqkaYBLj2ysVRaVslJN$cSJ" +
		"P##7DXsp7zfqvdveqzdxeKtDzqERhjqFRMgv7zfKkX$QrFrVOPDNXzScsYUR1dgiIMvJxEV" +
		"VQjEW$T2c4VkXJT$#dzeKEsDZkJN7sbJ#KrKyNjrFwety0iXtvImYPdg2GtHUPLASRgNetC" +
		"gbN5tqU9MadgwIrBe4Ki$7IFrS9LrxgoJrJrMas5ybgOmgIHsSI8eRY#$V5AdwaABeDwJ9j" +
		"9ulyL0$mRzEMxcsaQ3Xj#dM2j$PvaSbjcj1lo6DYy8QV9cM5iUqrwnaTiyUu8u9lf#57FLE" +
		"q5S87JTGEpan2xd0ShxExYVvFg8G#wgjxAqYaI18HdQRMtyXklCeMkyPtK#HRsyYTPabMYj" +
		"GYGBv1gSeKZUNS6lfBQJDj4b65EXifBCNA0S#FYnc1g89WlxOw7oHJu5dnYBk43VA#t4nnO" +
		"wAxo$V6lyf88TyyFery7SBv8zMo6RfL8rAg9Iow20w6AL3g0Qa3aKyt88r2Y4YO#LR8zjTZ" +
		"nKOG2VGYNGItO6eoO9KPvHAw24QARhEehDHSgWBtKWtqSsKXwnt8Lr45zCbME$BiEfNq9MK" +
		"JqsegM2QJw$G61eCFVFfAS7KIDejfg1WgYcOIX0ranDYob5CYu3fAgfBIv5Vbz5o6WtR1mg" +
		"cmr0kWUOK6f4KqwdKW4wZ9NGVpO9cYycMNJyT3Kp7qd62oG6wh8IOIXKJ0zCScYidH0xsMN" +
		"rAeqSKqz7GORK5geZfLPmQENINO6f6zs0EYsawC3bql6AogvSCamDCDkDqXezpa7SpOKUwO" +
		"1e7JCy9fcr9CGLf7f2dqX5KHp5r1wQUKKmb#C$5b8sv4c5gffWw09Fz5hapF9Q3LUiEJ3q5" +
		"q#l0D48mPIV5L8hdBF5tB#YocFgAHoocBF7JkOefivArUy23oVLJCNXtwE#9DRUO763o2wR" +
		"#IJ7PDS$1VxP#ks2gY$P2mUG0anyoBYOhdIp6SmIJNp7bODrBoc7gKYLCOp0w22#ucAR0Tr" +
		"EZc1p5P7tdJveBN4pP6DMEsjCvGFGqdQwOVBGUpmsqCIccezJ#8DNMVMSZwyXo##vCOEuEY" +
		"PvqhtZ2Zff1Ps14Vr2gOXeY#Ia5skm9LmkHceALj9WEnwY7gJfDmiXac3R924jMYyLaUyuJ" +
		"J5Tx$9GFYVo4VkeN4qyvD1I#jfwokkf6$MHzFO4cLc7VBQ25q68rE8Bf4EYhAPXgnAsTatJ" +
		"jN4nslCsrsL9s19CxtcehIOef1tw$5SY2Of$5L1pDu#d0L5tpKwv4IR8OFmQOx1xfZDLDbt" +
		"rgiLbCFa5KJ8#XDHcc5u4xX#e98jTFTWsB1LCVOChIy#vMQK#4gL0nFGDCwNBUDSD8ksjOC" +
		"TdeyekEjAIOie4fYDEr0Fcfd#OdgyDY6Yex#L78sLmmaqPXjiWvEX4wkk6ajJhi$SJ5j8As" +
		"Y8uSmMzrvEePl1WwKh0cfMXFXCdLKR7LRamwEACSxEVa#sGQF61liQU9poscNBIxvrF41hk" +
		"7kW5fZwJhNnccKMAN7xgJOIg1LBQilRtdM4oBuPsQCPY69SKqhKf#EWzppAGPIJ6jmBjYja" +
		"Ha2JnaCJauwr9YCAK8flHACEKcnRILNiEDoP5Tc0oJpQ0lIsnMb7VT4wLOOj8dPu63MUr#B" +
		"vR$pj2xPVKefdj5HxRi5lVS7I#OtFq$7izaCMdVXGw6XkewnsQyAVX4no1v#h67Jagem#B9" +
		"bqpXWtm9Tel5auhQoXW$7of#zekVQ#0DDqNE#YmPPoaBCxjuqb5oSrgwveyiw8tOP7sItAR" +
		"4QvMhMQG4UQ5ocspC#2MUNPlceLHSWKrtLX8xToR5KnDlp7tmd42tLOgdE$fxobbK4oMBfn" +
		"UDnHbiyHJ3dWTn1XVhlUPMVSDz4kqr8PLDQqN7fAYFYpL7#$0Sf3vspw7jq67Nxd$niQDFc" +
		"tqhzt6neCqM2ooUVk3PKPjog27igALncIEt5TjcTqKkxXXMHqra5HVFSCIKrT4RppLwjmeg" +
		"abguQpl$aqrJeYTYihYnxprJzUoqU4BHt7mMIklatAubledaIqVNmwTx8HTl7f5tXnBHSJw" +
		"UfMfJIjIcKibU#soJCUxJVYgtoNW#5e#MWCVJNajvZedxM1t21K#P3aelqw5uQhcQ3jXqmA" +
		"O3DXsmwO1D1smwODC1c$x$sUJLuRN9wjXtcpppLc9J7C83DXsmwLzhKqKpnjfK$bDbF1LQ0" +
		"$bsr1xF3jIHEj4DbKdXpRuAKbNJTK2ggb9uPxQ#Bur8GJxoBpP9jKey3AvSJgDcidmhLA6S" +
		"IYnIhj#GnaNXAkgbfRunxSzMPNRK4iukrbVicNJfovGJCvrM2y#IazB#ctywU8RTM#3fCaT" +
		"cPBTflLvavoc6Ul8lyRgVej$UHEhkB95QlahaopSujQBrN6fkUo6PGXao8j#TBRBNtJFMOe" +
		"hCvZcRBv2UxCXyqL7vdXdBZOhF1f5JF38glhzyQpaj#KHE#b3t5m1hGRcWEq0RRLk4YFXQK" +
		"03qAcW1Q2deCtHimNZ8yulWGL1pq0Nk6F#ViJgSFd7riHZNsrCVeFmRb$lE1WrMNUcWExpZ" +
		"5TT1U9m9VZp6rK1v1kHweXu6tnmhIpjrp74kpsf25BmIzViW#tUyRbSca0bA0nscEFx2c4c" +
		"WnokMTrQYRtMSZcDYwq7eoBgAA0HVPxK4xuIsfcvVQ3HqT2cJ3Rs6#ksAknzqrT5veCCPX$" +
		"uVeQCT$FG9#eu2lfDZvqev1#EEKHmdwDWsaDTou3oLQmqz0r67Fr8MeR##oWv3MxxANeo#v" +
		"zLt$ObIgs7#EgX0ncT$6xIil3zyDK6dGxO#PB7UWHAr1N4Jw8Y#zQ2PSVxg0Fc#uATglJ6e" +
		"hvQ7w7ZO7R3w47lEJZJ4#PXxUlIDinp1ZfW8Z7RRw6UC#m$uFMYxosrBdGcxiBRyD3XiJTq" +
		"DFhLCJvg3CJUfNPTYt0ejb#Bn0#ghTRurQEkeynoCkjqpmy5VYlDDAxHzh7wkZV9dYXtxoD" +
		"T9vqICXdw9zsiYmjY1giyF7KMnVMbTOS$bY3L6Vo6eLMo$0$y4CSwPQNz9flWH3pGlLYu8h" +
		"0xYpTTQxMW6EXaqCCu#h8yFSwOzXdcdmpx8116ZWJvbCYbjqNQ#whq0yeZnj1sGNmWvZ0aY" +
		"hW8Vnjcu7UsdGHOnufkbRUUZhO7EUpLH#X7GlHdyGgmZP8F8Iy6hTPxhG6tLvaDHrXp3s7k" +
		"#wN4sF01wIsNFXUmmZxzsepu4Szm9Z8h3jyFbwIimxnnmn5dMbUNNAJXK#LICcKrK3RahQn" +
		"NsBsmA8bRywptsJdPvjUlH1upyElWOr0V3Lm7LSnV6P6iPVWyU1q9#2FP6WoUVL4EUJki1$" +
		"XNuUnZZYyMLqG2OBy6uoQ3xGLFSTd#Ewfw6yk7WTcq6eM6LslqkwW$7sVWGP6t##G1bhAVl" +
		"2$37r7TsJJQ2re60oNzRtDYNbNy3#WxzY8CWC0V$WHxuDFY7uj9y4ZJO9uXhFt9f2FMGuxQ" +
		"7WkLzxo3tEbqzTTt7mHsUDkJTm95Q$XNbVcLz8Pn56OWnRbfUDsul54hroEBiy2EVXJAW7$" +
		"d6LrlzbOEs6cg3ZJ7uANHesJZ$xQ07tNB0auCo42lf3q8s6tIGPvx38FyAEFPl2FlJ3z#7Z" +
		"bQxlY#J2sIKbNtBOx7xhOxNL1$sQkXuBICcGgV4oWOc89$E1lqGxuC8eM#uAyllgMzqJMWN" +
		"g9PRpkoWijiJwT4no9Mqg7oxytXPsVU#nvOw2VHygvZi#Nc5tYiGx$uniN8PInIVtadyoz6" +
		"cETr$HIKsnzyvaF$zMokHZzip$ZTZwpwSHVvtmFU2Ou$viRv#zQSVvw9$bsUkDcLbVjlZem" +
		"qgZvplHzxEdAYsVHo7rTw37erjSsv6sveuZFRSrRpZd#cHlIjMZhUwF90AwkxUetplg5qn#" +
		"rtb9wayyax0hikNwYFT1vcubt11#N619z0#muFFA7zNn#kvp4WC3iuY$yxOyHbFbjUPiSMZ" +
		"xoXjy$WwUAHxLygmzv02DzS6cdlwRSxGyoOGaoUet5t5FGyfUZyDZ2gFXoR6ZIdqb7KzGoK" +
		"epuuVcuWWsyFbcJwK1yNsXLx26cb#oiGP6IYD6xj4#qv4UQbRpfXirwByF9aucmFFwBWDg1" +
		"U1huoLyHtkyfI6wFiSXJrktIajambyxIblK$cvA6CDk97An#ZrO40E3ZpdblstnFQbuhuLG" +
		"3v8nNj38ApwFRca8fi22VABhqk2zfOwr$ieDtJBGNqFIRiKPTmtqv2pdIyg6XyhduxS7yGz" +
		"BbFtL#OUZyonweUzYdEiZi6T8bXK9iTdUCeZ5EErs2jxozhJSUu6yTvNhGLuY$9uggr7Uyl" +
		"oxVI2n#wwodT3TuNlM6MoWRNktIru5gWHg9dQbEB1YZjFyC8ulxGiA$lcnFRn48zSjxAoFy" +
		"Khf$tbtb#06UzpDCwZxv3outXLv9qD$6vGN4xtDVRwld8VkFSZnLXSGV#QYiVvStMkYyhQC" +
		"awoToljhnqhJqtYz8vHkNgUjfVAoiuLSV9Rl7LFUzpvvQHJz6F2PggPGd4VqqsUwyrpPftP" +
		"ODQQPr1xsgmnJqdx4#PnF6U1PXZSUSreQPrfdZIFcKTHGgumlvWzvajPhU$DT3Cj$87v8ln" +
		"##5sHnFkdgMr6ccoJQtBC4TAMPxRYUP6fOGunrSt1vY2336SEDwSPt7JCgMQKgH#3KFxknH" +
		"ncQfaBmK#MMZstB$mx26Tp#AVmz#7lf1zUDoUAp0cWurK7xkFc62aTROx5K$vonboglSFDO" +
		"3F8u5tMu1tS300T5PqzF$nf#1CjNodF8q5rf5HeckBPBFnH#4DOtIJydgblqgGdDJe#HN1#" +
		"eBLqSuRmq#NPq9G8RsFmRc7QHSUqD2rCUocrakSryYm6NMqkCEURyyovff4vnvnjpZ9d6kG" +
		"84x8pc63uy$1dwXbR3uHtXNT6Qtvv#i9VXx$I5aSvXxyCVw7ZS9CFuvOV$ZFyjq5M3F#WxN" +
		"Wx3UC67VuZ$5TuJtYFZhIuXfaH1k#D1dTc8tyZQ7hBivUv3Sy#ClhRy3T6$WB6L3DPU6QQZ" +
		"AYrk0SQl1EO$bAh6$uulDjSRXg7Vz6PVmFXF0$$6FxP$61msXYybPYlGL#PdmpUHimsrVIX" +
		"sMbUDHRNE#OjW$TOywPvm#2#Q$GlgGpUtSod7kdtfVIkUSzy5XF9twaCxlfcfPbaxZOFc8S" +
		"evcDmNpFBFFKbe4LciLbk7fRw2hC0p$dcNZFFp9MMEVASRHRgYDNc7ZFP$2f##jPir5Qyiv" +
		"kRpQruuaGqU5iqtSqjqZF1Z3VZ3Dur3TvvKHvh9iOWAZKtciwc2qet6Pouvc$pb$bJUlwGv" +
		"#$o$CrW7Va4iglKcvYsau$MWjjV#qq0jxG0RGieG0l9JyZv82QyQuEO9WevccQObb8gtKyf" +
		"j0Xj$JmqZEo$JJc4zoiGW#pl4Gd4XDm1OXe5FWhSvfNHu7TJaBQ0Ru7i4eor13#3E5fV39g" +
		"4#YJ882U1cFfZN4#qOxr0J7Qj7WAtA$4m#2FWZu0$A#GGpWmGqvEKGQ#YFXbbbyhApmdPkY" +
		"$QjXpbDMJ$Nu9CwuKSmZi2Y6aPC2o3lpQWl07jTZqteZn5VjaNf6aeJyFu0U03q3z0$fw0G" +
		"Gvr1U#AkgLxK9yERcausYqzfRHEQPpI9Y4VpSHSCr6UWR4pv3VCzjU33FBXdPZfPL0F8H$r" +
		"Gf$TbNt0kw4jGZUYVYFmksJhFg4kA7T1tqqetmmQYFf0#Ksq9H#DWAuHQ9ibvAEjQCVxEuX" +
		"fDifsTsv3#HNqFG$#FFWSy3do#syckpVcWjlVWcD$Wjno2UBFyXTGVm6oyvHMG#T8o8r4ky" +
		"qtVS5Nmhzujm0vD0ZZ1b48b4ARqRSPO#u5ZIT7$dAfCyhOGo2cww2$9NWoQYNa0mNeMfHTS" +
		"fI7G3vGGBbVoq72FHx4sXRKTaVb76g1lXRWhS5Tyj7re3PeQmFU5crjvRVRN8xk479eFlXy" +
		"o7J471rHxoZb82W02iMLKrKkG1t0EmWFWa8UdW9AfVReRu$#zcXlZ$OodWAoVql281#r0xV" +
		"qej9jIcELxbIwNUaPfSULdb3g15zr0hz1oA4t$WkwXRK4");

/*******************************************************
 *  Inject code for custom error handling in the parser class.
 *******************************************************/
  // all errors encountered during parsing is stored in the array parseProblems. This includes lexical, syntactical and semantic error (multiple initialization actors et.c.)
  public java.util.TreeSet<String> parseProblems = new TreeSet<String>();
  public void newError(String msg, Symbol token){
      parseProblems.add(msg + " At row " + Symbol.getLine(token.getStart()) + ", column " + Symbol.getColumn(token.getStart()));
  };
  public void printParseProblems(){ printParseProblems(System.err); }
  public void printParseProblems(PrintStream out){
    out.println("number of problems: " + parseProblems.size());
    for(String msg : parseProblems){
      out.println("ERROR: " + msg);
    }
  }

  // parser plug-in methods that are called when the parser encounters a syntactical problem
  class Events extends Parser.Events {
    public void scannerError(Scanner.Exception e) {
      parseProblems.add(e.getMessage());
    }
    public void syntaxError(Symbol token) {
      // This method is always called when a problem is encountered, even if it is repaired.
      // beaver.Parser$Exception is thrown if recovery fails.
      String value = token.value != null ? token.value.toString() : Terminals.NAMES[token.getId()];
      parseProblems.add("unexpected token \"" + value + "\" at " + Symbol.getLine(token.getStart()) + ", " + Symbol.getColumn(token.getStart()));
    }
    public void unexpectedTokenRemoved(Symbol token) {
      String value = token.value != null ? token.value.toString() : Terminals.NAMES[token.getId()];
      parseProblems.add("parser recovered after removing token \"" + value + "\" at " + Symbol.getLine(token.getStart()) + ", " + Symbol.getColumn(token.getStart()));
    }
    public void missingTokenInserted(Symbol token) {
      String value = token.value != null ? token.value.toString() : Terminals.NAMES[token.getId()];
      parseProblems.add("parser recovered after inserting token \"" + value + "\" at " + Symbol.getLine(token.getStart()) + ", " + Symbol.getColumn(token.getStart()));
    }
    public void misspelledTokenReplaced(Symbol token) {
      String value = token.value != null ? token.value.toString() : Terminals.NAMES[token.getId()];
      parseProblems.add("parser recovered after replacing token \"" + value + "\" at " + Symbol.getLine(token.getStart()) + ", " + Symbol.getColumn(token.getStart()));
    }
    public void errorPhraseRemoved(Symbol token) {
      String value = token.value != null ? token.value.toString() : Terminals.NAMES[token.getId()];
      parseProblems.add("parser recovered after removing token \"" + value + "\" at " + Symbol.getLine(token.getStart()) + ", " + Symbol.getColumn(token.getStart()));
    }
  }

  {
    // initialization, before the constructor
    report = new Events(); // Use error handler in parser
  }

/*******************************************************
 *  Help routine that parses a file, given its name.
 *  A compilation unit is always returned, containing all parseProblems encountered during parsing.
 *  If a Parser.exception is thrown a CompilationUnit with an empty AST is returned.
 *******************************************************/
  private Actor makeEmptyActor(File file){
    String name;
    int lastPeriodPos = file.getName().lastIndexOf('.');
    if(lastPeriodPos >=0){
      name = file.getName().substring(0, lastPeriodPos);
    } else {
      name = file.getName();
    }
    return new Actor(name, null, new ParDeclType[0], new ParDeclValue[0], new DeclType[0], new DeclVar[0], new CompositePortDecl(), 
                     new CompositePortDecl(), new Action[0], new Action[0], null, new java.util.List[0], new Expression[0]);   
  }
  
  public net.opendf.ir.cal.Actor parse(String path, String fileName){
    return parse(new java.io.File(path + "/" + fileName));
  }
  public net.opendf.ir.cal.Actor parse(File file){
     Actor actor;
     parseProblems = new TreeSet<String>();
     java.io.FileReader fr = null;
     try {
       try{
         fr = new java.io.FileReader(file);
  	     CalScanner scanner = new CalScanner(new java.io.BufferedReader(fr));
         actor = (Actor)parse(scanner);
       } catch(CalParser.Exception e) {
         // build empty compilation unit for failed error recovery
         // The problem is added to parseProblems[] by the syntaxError() method added to the parser above.
         actor = makeEmptyActor(file);
       } finally {
         if(fr != null){
           fr.close();
         }
       }
     } catch (java.io.FileNotFoundException e){
       parseProblems.add("file not found: " + e.getMessage());
       actor = makeEmptyActor(file);
//       actor.setFileNotFound(true);
     } catch (java.io.IOException e){
       parseProblems.add("error reading file: " + e.getMessage());
       actor = makeEmptyActor(file);
     }
//     actor.setSourceFile(file);
//     actor.parseProblems = parseProblems;
     return actor;
   }

  private enum ActionPartKind{ GUARD, DECL_LIST, DELAY; }
  private enum ActorPartKind{ DECL_VAR, INIT_ACTION, ACTION, FSM_SCHEDULE, PRIORITY, INVARIANT_LIST; }

  /****************************************************************************
   * Needed by CommonParser.beaver
   * Repeated in both NlParser.beaver and CalParser.beaver
   ***************************************************************************/
  private GeneratorFilter makeGeneratorFilter(TypeExpr type, ArrayList varList, Expression e, ArrayList filterList){
    DeclVar[] vars = new DeclVar[varList.size()];
    for(int i = 0; i<varList.size(); i++){
      Symbol symbol = (Symbol)varList.get(i);
      vars[i] = new DeclVar(type, (String)symbol.value, null);
    }
    Expression[] filters = filterList == null ? new Expression[0] : (Expression[])filterList.toArray(new Expression[filterList.size()]);
    return new GeneratorFilter(vars, e, filters);
  }
  class ParenthesSymbol extends Symbol{ // used by the parser to wrap subexpressions that are enclosed by parentheses, i.e. do not add them to a ExprBinaryOp sequence.
     ParenthesSymbol(Symbol s){
       super(s.getId(), s.getStart(), s.getEnd(), s.value);
     }
  }
  
  private LValue expressionToLValue(Expression expression) {
    if (expression instanceof ExprVariable) {
      return new LValueVariable(((ExprVariable) expression).getVariable());
    } else if (expression instanceof ExprIndexer) {
      ExprIndexer exprIndexer = (ExprIndexer) expression;
      LValue structure = expressionToLValue(exprIndexer.getStructure());
      if (structure == null) return null;
      return new LValueIndexer(structure, exprIndexer.getIndex());
    } else if (expression instanceof ExprField) {
      ExprField exprField = (ExprField) expression;
      LValue structure = expressionToLValue(exprField.getStructure());
      if (structure == null) return null;
      return new LValueField(structure, exprField.getField());
    } else {
      return null;
    }
  }

	public CalParser() {
		super(PARSING_TABLES);
	}

	protected Symbol invokeReduceAction(int rule_num, int offset) {
		switch(rule_num) {
			case 2: // goal = actor_decl.actor_decl end_actor opt$SEMICOLON
			{
					final Symbol _symbol_actor_decl = _symbols[offset + 1];
					final Actor actor_decl = (Actor) _symbol_actor_decl.value;
					 return _symbol_actor_decl;
			}
			case 3: // import_list = import_part.i
			{
					final Symbol _symbol_i = _symbols[offset + 1];
					final String i = (String) _symbol_i.value;
					 ArrayList l = new ArrayList(); l.add(i); return new Symbol(l);
			}
			case 4: // import_list = import_list.l import_part.i
			{
					final Symbol _symbol_l = _symbols[offset + 1];
					final ArrayList l = (ArrayList) _symbol_l.value;
					final Symbol _symbol_i = _symbols[offset + 2];
					final String i = (String) _symbol_i.value;
					 l.add(i); return _symbol_l;
			}
			case 5: // import_part = import_single.i
			{
					final Symbol _symbol_i = _symbols[offset + 1];
					final String i = (String) _symbol_i.value;
					 return _symbol_i;
			}
			case 6: // import_part = import_group.i
			{
					final Symbol _symbol_i = _symbols[offset + 1];
					final String i = (String) _symbol_i.value;
					 return _symbol_i;
			}
			case 7: // import_single = IMPORT qual_id.qual_id SEMICOLON
			{
					final Symbol _symbol_qual_id = _symbols[offset + 2];
					final ArrayList qual_id = (ArrayList) _symbol_qual_id.value;
					 return new Symbol(null);
			}
			case 8: // import_single = IMPORT qual_id.qual_id EQ IDENTIFIER.alias SEMICOLON
			{
					final Symbol _symbol_qual_id = _symbols[offset + 2];
					final ArrayList qual_id = (ArrayList) _symbol_qual_id.value;
					final Symbol alias = _symbols[offset + 4];
					 return new Symbol(null);
			}
			case 9: // import_group = IMPORT ALL qual_id.qual_id SEMICOLON
			{
					final Symbol _symbol_qual_id = _symbols[offset + 3];
					final ArrayList qual_id = (ArrayList) _symbol_qual_id.value;
					 return new Symbol(null);
			}
			case 14: // lst$action_head = action_head
			{
					ArrayList lst = new ArrayList(); lst.add(_symbols[offset + 1].value); return new Symbol(lst);
			}
			case 15: // lst$action_head = lst$action_head action_head
			{
					((ArrayList) _symbols[offset + 1].value).add(_symbols[offset + 2].value); return _symbols[offset + 1];
			}
			case 18: // action_decl = opt$action_tag.tag ACTION.ACTION action_in_pattern_list.in_pattern_list PORTCONN opt$action_output_expression_list.out_expr_list opt$lst$action_head.head action_statement_body.body end_action opt$SEMICOLON
			{
					final Symbol _symbol_tag = _symbols[offset + 1];
					final QID tag = (QID) _symbol_tag.value;
					final Symbol ACTION = _symbols[offset + 2];
					final Symbol _symbol_in_pattern_list = _symbols[offset + 3];
					final ArrayList in_pattern_list = (ArrayList) _symbol_in_pattern_list.value;
					final Symbol _symbol_out_expr_list = _symbols[offset + 5];
					final ArrayList out_expr_list = (ArrayList) _symbol_out_expr_list.value;
					final Symbol _symbol_head = _symbols[offset + 6];
					final ArrayList _list_head = (ArrayList) _symbol_head.value;
					final Map.Entry[] head = _list_head == null ? new Map.Entry[0] : (Map.Entry[]) _list_head.toArray(new Map.Entry[_list_head.size()]);
					final Symbol _symbol_body = _symbols[offset + 7];
					final ArrayList body = (ArrayList) _symbol_body.value;
					
           // split the action head to it's parts
           ArrayList<Expression> guardList = new ArrayList<Expression>();
           Expression delay = null;
           ArrayList<DeclVar> declVarList = new ArrayList<DeclVar>();
           for(Map.Entry part : head){
             switch((ActionPartKind)part.getKey()){
               case GUARD:
                 guardList.addAll((ArrayList)part.getValue());
                 break;
               case DECL_LIST:
                 declVarList.addAll((ArrayList<DeclVar>)part.getValue());
                 break;
               case DELAY:
                 if(delay != null){ parseProblems.add("multiple delays is not allowed in action, at " + Symbol.getLine(ACTION.getStart()) + ", " + Symbol.getColumn(ACTION.getStart())); }
                 delay = (Expression)part.getValue();
                 break;
             }
           }
            Action a = new Action(-1,                        // id
                                  tag,                       // tag
                                  (InputPattern[])in_pattern_list.toArray(new InputPattern[in_pattern_list.size()]), //inputPatterns
                                  out_expr_list==null ? new OutputExpression[0] : (OutputExpression[])out_expr_list.toArray(new OutputExpression[out_expr_list.size()]),  //outputExpressions
                                  new DeclType[0],                                              // typeDecls
                                  declVarList.toArray(new DeclVar[declVarList.size()]),         // varDecls
                                  guardList.toArray(new Expression[guardList.size()]),              // guards 
                                  (Statement[])body.toArray(new Statement[body.size()]),        // body
                                  delay,                      // delay
                                  new Expression[0],         // preconditions  NOTE, can not be expressed in CAL
                                  new Expression[0]);        // postconditions NOTE, can not be expressed in CAL
            return new Symbol(a);
			}
			case 19: // init_action_decl = opt$action_tag.tag INITIALIZE.INITIALIZE PORTCONN opt$action_output_expression_list.out_expr_list opt$lst$action_head.head action_statement_body.body end_action opt$SEMICOLON
			{
					final Symbol _symbol_tag = _symbols[offset + 1];
					final QID tag = (QID) _symbol_tag.value;
					final Symbol INITIALIZE = _symbols[offset + 2];
					final Symbol _symbol_out_expr_list = _symbols[offset + 4];
					final ArrayList out_expr_list = (ArrayList) _symbol_out_expr_list.value;
					final Symbol _symbol_head = _symbols[offset + 5];
					final ArrayList _list_head = (ArrayList) _symbol_head.value;
					final Map.Entry[] head = _list_head == null ? new Map.Entry[0] : (Map.Entry[]) _list_head.toArray(new Map.Entry[_list_head.size()]);
					final Symbol _symbol_body = _symbols[offset + 6];
					final ArrayList body = (ArrayList) _symbol_body.value;
					 
           // split the action head to it's parts
           ArrayList<Expression> guardList = new ArrayList<Expression>();
           Expression delay = null;
           ArrayList<DeclVar> declVarList = new ArrayList<DeclVar>();
           for(Map.Entry part : head){
             switch((ActionPartKind)part.getKey()){
               case GUARD:
                 guardList.addAll((ArrayList)part.getValue());
                 break;
               case DECL_LIST:
                 declVarList.addAll((ArrayList<DeclVar>)part.getValue());
                 break;
               case DELAY:
                 if(delay != null){ parseProblems.add("multiple delays is not allowed in action, at " + Symbol.getLine(INITIALIZE.getStart()) + ", " + Symbol.getColumn(INITIALIZE.getStart())); }
                 delay = (Expression)part.getValue();
                 break;
             }
           }
            Action a = new Action(-1,                        // id
                                  tag,                       // tag
                                  new InputPattern[0],       //inputPatterns
                                  out_expr_list==null ? new OutputExpression[0] : (OutputExpression[])out_expr_list.toArray(new OutputExpression[out_expr_list.size()]),  //outputExpressions
                                  new DeclType[0],                                              // typeDecls
                                  declVarList.toArray(new DeclVar[declVarList.size()]),         // varDecls
                                  guardList.toArray(new Expression[guardList.size()]),          // guards 
                                  (Statement[])body.toArray(new Statement[body.size()]),        // body
                                  delay,                      // delay
                                  new Expression[0],         // preconditions  NOTE, can not be expressed in CAL
                                  new Expression[0]);        // postconditions NOTE, can not be expressed in CAL
            return new Symbol(a);
			}
			case 20: // action_tag = qual_id.n COLON
			{
					final Symbol _symbol_n = _symbols[offset + 1];
					final ArrayList n = (ArrayList) _symbol_n.value;
					 return new Symbol(new QID((String[])n.toArray(new String[n.size()])));
			}
			case 21: // action_head = GUARD expression_list.l
			{
					final Symbol _symbol_l = _symbols[offset + 2];
					final ArrayList l = (ArrayList) _symbol_l.value;
					 return new Symbol(new AbstractMap.SimpleEntry(ActionPartKind.GUARD, l));
			}
			case 22: // action_head = VAR decl_list.d
			{
					final Symbol _symbol_d = _symbols[offset + 2];
					final ArrayList d = (ArrayList) _symbol_d.value;
					 return new Symbol(new AbstractMap.SimpleEntry(ActionPartKind.DECL_LIST, d));
			}
			case 23: // action_head = DELAY expression.e
			{
					final Symbol _symbol_e = _symbols[offset + 2];
					final Expression e = (Expression) _symbol_e.value;
					 return new Symbol(new AbstractMap.SimpleEntry(ActionPartKind.DELAY, e));
			}
			case 24: // action_statement_body = 
			{
					 return new Symbol(new ArrayList());
			}
			case 25: // action_statement_body = DO statement_list_opt.s
			{
					final Symbol _symbol_s = _symbols[offset + 2];
					final ArrayList s = (ArrayList) _symbol_s.value;
					 return new Symbol(s);
			}
			case 26: // action_in_pattern_list = 
			{
					 return new Symbol(new ArrayList());
			}
			case 27: // action_in_pattern_list = action_in_pattern.p
			{
					final Symbol _symbol_p = _symbols[offset + 1];
					final InputPattern p = (InputPattern) _symbol_p.value;
					 ArrayList l = new ArrayList(); l.add(p); return new Symbol(l);
			}
			case 28: // action_in_pattern_list = action_in_pattern_list.l COMMA action_in_pattern.p
			{
					final Symbol _symbol_l = _symbols[offset + 1];
					final ArrayList l = (ArrayList) _symbol_l.value;
					final Symbol _symbol_p = _symbols[offset + 3];
					final InputPattern p = (InputPattern) _symbol_p.value;
					 l.add(p); return _symbol_l;
			}
			case 37: // action_in_pattern = opt$port_name_colon.actor_port_name LBRACK opt$token_name_list.tokens RBRACK opt$repeat.r opt$channel_selector.c
			{
					final Symbol _symbol_actor_port_name = _symbols[offset + 1];
					final PortName actor_port_name = (PortName) _symbol_actor_port_name.value;
					final Symbol _symbol_tokens = _symbols[offset + 3];
					final ArrayList tokens = (ArrayList) _symbol_tokens.value;
					final Symbol _symbol_r = _symbols[offset + 5];
					final Expression r = (Expression) _symbol_r.value;
					final Symbol _symbol_c = _symbols[offset + 6];
					final String c = (String) _symbol_c.value;
					 return new Symbol(new InputPattern(actor_port_name, tokens==null ? new String[0] : (String[])tokens.toArray(new String[tokens.size()]), r));
			}
			case 38: // token_name_list = IDENTIFIER.ID
			{
					final Symbol ID = _symbols[offset + 1];
					 ArrayList l = new ArrayList(); l.add(ID.value); return new Symbol(l);
			}
			case 39: // token_name_list = token_name_list.l COMMA IDENTIFIER.ID
			{
					final Symbol _symbol_l = _symbols[offset + 1];
					final ArrayList l = (ArrayList) _symbol_l.value;
					final Symbol ID = _symbols[offset + 3];
					 l.add(ID.value); return _symbol_l;
			}
			case 40: // channel_selector = AT expression.e
			{
					final Symbol _symbol_e = _symbols[offset + 2];
					final Expression e = (Expression) _symbol_e.value;
					 return new Symbol(null);
			}
			case 41: // channel_selector = ATSTAR expression.e
			{
					final Symbol _symbol_e = _symbols[offset + 2];
					final Expression e = (Expression) _symbol_e.value;
					 return new Symbol(null);
			}
			case 44: // channel_selector = opt$ATSTAR ANY
			{
					 return new Symbol(null);
			}
			case 45: // channel_selector = opt$ATSTAR ALL
			{
					 return new Symbol(null);
			}
			case 46: // repeat = REPEAT expression.e
			{
					final Symbol _symbol_e = _symbols[offset + 2];
					final Expression e = (Expression) _symbol_e.value;
					 return _symbol_e;
			}
			case 47: // action_output_expression_list = action_output_expression.e
			{
					final Symbol _symbol_e = _symbols[offset + 1];
					final OutputExpression e = (OutputExpression) _symbol_e.value;
					 ArrayList l = new ArrayList(); l.add(e); return new Symbol(l);
			}
			case 48: // action_output_expression_list = action_output_expression_list.l COMMA action_output_expression.e
			{
					final Symbol _symbol_l = _symbols[offset + 1];
					final ArrayList l = (ArrayList) _symbol_l.value;
					final Symbol _symbol_e = _symbols[offset + 3];
					final OutputExpression e = (OutputExpression) _symbol_e.value;
					 l.add(e); return _symbol_l;
			}
			case 51: // action_output_expression = opt$port_name_colon.actor_port_name LBRACK opt$expression_list.values RBRACK opt$repeat.r opt$channel_selector.c
			{
					final Symbol _symbol_actor_port_name = _symbols[offset + 1];
					final PortName actor_port_name = (PortName) _symbol_actor_port_name.value;
					final Symbol _symbol_values = _symbols[offset + 3];
					final ArrayList values = (ArrayList) _symbol_values.value;
					final Symbol _symbol_r = _symbols[offset + 5];
					final Expression r = (Expression) _symbol_r.value;
					final Symbol _symbol_c = _symbols[offset + 6];
					final String c = (String) _symbol_c.value;
					 return new Symbol(new OutputExpression(actor_port_name, 
                                                values==null ? new Expression[0] : (Expression[])values.toArray(new Expression[values.size()]), r));
			}
			case 52: // port_name_colon = IDENTIFIER.IDENTIFIER COLON
			{
					final Symbol IDENTIFIER = _symbols[offset + 1];
					 return new Symbol(new PortName((String)IDENTIFIER.value));
			}
			case 61: // lst$actor_body = actor_body
			{
					ArrayList lst = new ArrayList(); lst.add(_symbols[offset + 1].value); return new Symbol(lst);
			}
			case 62: // lst$actor_body = lst$actor_body actor_body
			{
					((ArrayList) _symbols[offset + 1].value).add(_symbols[offset + 2].value); return _symbols[offset + 1];
			}
			case 65: // actor_decl = opt$import_list.imports ACTOR IDENTIFIER.name opt$type_parameter_block.typePars LPAREN opt$actor_parameter_list.valuePars RPAREN port_decl_list_opt.in PORTCONN port_decl_list_opt.out opt$time.t COLON opt$lst$actor_body.body
			{
					final Symbol _symbol_imports = _symbols[offset + 1];
					final ArrayList imports = (ArrayList) _symbol_imports.value;
					final Symbol name = _symbols[offset + 3];
					final Symbol _symbol_typePars = _symbols[offset + 4];
					final ArrayList typePars = (ArrayList) _symbol_typePars.value;
					final Symbol _symbol_valuePars = _symbols[offset + 6];
					final ArrayList valuePars = (ArrayList) _symbol_valuePars.value;
					final Symbol _symbol_in = _symbols[offset + 8];
					final CompositePortDecl in = (CompositePortDecl) _symbol_in.value;
					final Symbol _symbol_out = _symbols[offset + 10];
					final CompositePortDecl out = (CompositePortDecl) _symbol_out.value;
					final Symbol _symbol_t = _symbols[offset + 11];
					final TypeExpr t = (TypeExpr) _symbol_t.value;
					final Symbol _symbol_body = _symbols[offset + 13];
					final ArrayList _list_body = (ArrayList) _symbol_body.value;
					final Map.Entry[] body = _list_body == null ? new Map.Entry[0] : (Map.Entry[]) _list_body.toArray(new Map.Entry[_list_body.size()]);
					
    ArrayList varDecls = new ArrayList();
    ArrayList initializers = new ArrayList();
    ArrayList actions = new ArrayList();
    ScheduleFSM scheduleFSM = null;
    ArrayList priorities = new ArrayList();
    ArrayList invariants = new ArrayList();
    for(Map.Entry part : body){
      switch((ActorPartKind)part.getKey()){
        case DECL_VAR:
          varDecls.add(part.getValue());
          break;
        case INIT_ACTION:
          initializers.add(part.getValue());
          break;
        case ACTION:
          actions.add(part.getValue());
          break;
        case FSM_SCHEDULE:
          scheduleFSM = (ScheduleFSM)part.getValue();
          break;
        case PRIORITY:
          priorities.addAll((ArrayList)part.getValue());
          break;
        case INVARIANT_LIST:
          invariants.addAll((ArrayList)part.getValue());
          break;
      }
    }
    Actor a = new Actor((String)name.value,
                         null,                 // NamespaceDecl namespace,
                         typePars == null ? new ParDeclType[0] : (ParDeclType[])typePars.toArray(new ParDeclType[typePars.size()]),     // typePars,
                         valuePars == null ? new ParDeclValue[0] : (ParDeclValue[])valuePars.toArray(new ParDeclValue[valuePars.size()]), // valuePars,
                         new DeclType[0],      // typeDecls, NOTE, can not be expressed in CAL
                         (DeclVar[])varDecls.toArray(new DeclVar[varDecls.size()]),             // varDecls
                         in,                   // CompositePortDecl inputPorts,
                         out,                  // CompositePortDecl outputPorts,
                         (Action[])initializers.toArray(new Action[initializers.size()]),
                         (Action[])actions.toArray(new Action[actions.size()]),
                         scheduleFSM,
                         (java.util.List<QID>[])priorities.toArray(new java.util.List[priorities.size()]),
                         (Expression[])invariants.toArray(new Expression[invariants.size()])
                        );
     
    return new Symbol(a);
			}
			case 66: // time = TIME type.t
			{
					final Symbol _symbol_t = _symbols[offset + 2];
					final TypeExpr t = (TypeExpr) _symbol_t.value;
					 return _symbol_t;
			}
			case 67: // actor_body = action_decl.a
			{
					final Symbol _symbol_a = _symbols[offset + 1];
					final Action a = (Action) _symbol_a.value;
					 return new Symbol(new AbstractMap.SimpleEntry(ActorPartKind.ACTION, a));
			}
			case 68: // actor_body = init_action_decl.a
			{
					final Symbol _symbol_a = _symbols[offset + 1];
					final Action a = (Action) _symbol_a.value;
					 return new Symbol(new AbstractMap.SimpleEntry(ActorPartKind.INIT_ACTION, a));
			}
			case 69: // actor_body = var_decl.d SEMICOLON
			{
					final Symbol _symbol_d = _symbols[offset + 1];
					final DeclVar d = (DeclVar) _symbol_d.value;
					 return new Symbol(new AbstractMap.SimpleEntry(ActorPartKind.DECL_VAR, d));
			}
			case 70: // actor_body = fun_decl.d
			{
					final Symbol _symbol_d = _symbols[offset + 1];
					final DeclVar d = (DeclVar) _symbol_d.value;
					 return new Symbol(new AbstractMap.SimpleEntry(ActorPartKind.DECL_VAR, d));
			}
			case 71: // actor_body = proc_decl.d
			{
					final Symbol _symbol_d = _symbols[offset + 1];
					final DeclVar d = (DeclVar) _symbol_d.value;
					 return new Symbol(new AbstractMap.SimpleEntry(ActorPartKind.DECL_VAR, d));
			}
			case 72: // lst$pri_inequality_list = pri_inequality_list
			{
					ArrayList lst = new ArrayList(); lst.add(_symbols[offset + 1].value); return new Symbol(lst);
			}
			case 73: // lst$pri_inequality_list = lst$pri_inequality_list pri_inequality_list
			{
					((ArrayList) _symbols[offset + 1].value).add(_symbols[offset + 2].value); return _symbols[offset + 1];
			}
			case 74: // actor_body = PRIORITY lst$pri_inequality_list.l END
			{
					final Symbol _symbol_l = _symbols[offset + 2];
					final ArrayList _list_l = (ArrayList) _symbol_l.value;
					final ArrayList[] l = _list_l == null ? new ArrayList[0] : (ArrayList[]) _list_l.toArray(new ArrayList[_list_l.size()]);
					 return new Symbol(new AbstractMap.SimpleEntry(ActorPartKind.PRIORITY, _list_l));
			}
			case 75: // actor_body = schedule.s
			{
					final Symbol _symbol_s = _symbols[offset + 1];
					final ScheduleFSM s = (ScheduleFSM) _symbol_s.value;
					 return new Symbol(new AbstractMap.SimpleEntry(ActorPartKind.FSM_SCHEDULE, s));
			}
			case 76: // actor_body = invariant.i
			{
					final Symbol _symbol_i = _symbols[offset + 1];
					final ArrayList i = (ArrayList) _symbol_i.value;
					 return new Symbol(new AbstractMap.SimpleEntry(ActorPartKind.INVARIANT_LIST, i));
			}
			case 77: // invariant = INVARIANT expression_list.l end_invariant
			{
					final Symbol _symbol_l = _symbols[offset + 2];
					final ArrayList l = (ArrayList) _symbol_l.value;
					 return _symbol_l;
			}
			case 80: // lst$fsm_state_transitions = fsm_state_transitions
			{
					ArrayList lst = new ArrayList(); lst.add(_symbols[offset + 1].value); return new Symbol(lst);
			}
			case 81: // lst$fsm_state_transitions = lst$fsm_state_transitions fsm_state_transitions
			{
					((ArrayList) _symbols[offset + 1].value).add(_symbols[offset + 2].value); return _symbols[offset + 1];
			}
			case 84: // schedule = SCHEDULE opt$FSM IDENTIFIER.ID COLON opt$lst$fsm_state_transitions.trans end_schedule
			{
					final Symbol ID = _symbols[offset + 3];
					final Symbol _symbol_trans = _symbols[offset + 5];
					final ArrayList _list_trans = (ArrayList) _symbol_trans.value;
					final ArrayList[] trans = _list_trans == null ? new ArrayList[0] : (ArrayList[]) _list_trans.toArray(new ArrayList[_list_trans.size()]);
					  ArrayList tl = trans[0];
          for(int i=1; i<trans.length; i++){
            tl.addAll(trans[i]);
          }
          return new Symbol(new ScheduleFSM((Transition[])tl.toArray(new Transition[tl.size()]), (String)ID.value));
			}
			case 85: // schedule = SCHEDULE.SCHEDULE REGEXP regexpr.r end_schedule
			{
					final Symbol SCHEDULE = _symbols[offset + 1];
					final Symbol _symbol_r = _symbols[offset + 3];
					final AbstractIRNode r = (AbstractIRNode) _symbol_r.value;
					 parseProblems.add("Regular expression schedules are not supported, at " + Symbol.getLine(SCHEDULE.getStart()) + ", " + Symbol.getColumn(SCHEDULE.getStart())); return new Symbol(null);
			}
			case 86: // lst$fsm_state_target = fsm_state_target
			{
					ArrayList lst = new ArrayList(); lst.add(_symbols[offset + 1].value); return new Symbol(lst);
			}
			case 87: // lst$fsm_state_target = lst$fsm_state_target fsm_state_target
			{
					((ArrayList) _symbols[offset + 1].value).add(_symbols[offset + 2].value); return _symbols[offset + 1];
			}
			case 90: // fsm_state_transitions = IDENTIFIER.Src_state LPAREN action_tag_list.tags RPAREN EDGE IDENTIFIER.Dst_state opt$lst$fsm_state_target.more SEMICOLON
			{
					final Symbol Src_state = _symbols[offset + 1];
					final Symbol _symbol_tags = _symbols[offset + 3];
					final ArrayList tags = (ArrayList) _symbol_tags.value;
					final Symbol Dst_state = _symbols[offset + 6];
					final Symbol _symbol_more = _symbols[offset + 7];
					final ArrayList _list_more = (ArrayList) _symbol_more.value;
					final Transition[] more = _list_more == null ? new Transition[0] : (Transition[]) _list_more.toArray(new Transition[_list_more.size()]);
					 ArrayList result = new ArrayList();
          String startState = (String)Src_state.value;
          result.add(new Transition(startState,
                                    (String)Dst_state.value,
                                    (QID[])tags.toArray(new QID[tags.size()]))); 
          for(Transition t : more){
            result.add(new Transition(startState, t.getDestinationState(), t.getActionTags()));
          }
          return new Symbol(result);
			}
			case 91: // fsm_state_target = BAR LPAREN action_tag_list.tags RPAREN EDGE IDENTIFIER.Dst_state
			{
					final Symbol _symbol_tags = _symbols[offset + 3];
					final ArrayList tags = (ArrayList) _symbol_tags.value;
					final Symbol Dst_state = _symbols[offset + 6];
					 return new Symbol(new Transition(null,  // the start state is unknown. This is filled in later.
                                           (String)Dst_state.value,
                                           (QID[])tags.toArray(new QID[tags.size()])));
			}
			case 92: // action_tag_list = qual_id.id
			{
					final Symbol _symbol_id = _symbols[offset + 1];
					final ArrayList id = (ArrayList) _symbol_id.value;
					 ArrayList l = new ArrayList(); l.add(new QID((String[])id.toArray(new String[id.size()]))); return new Symbol(l);
			}
			case 93: // action_tag_list = action_tag_list.l COMMA qual_id.id
			{
					final Symbol _symbol_l = _symbols[offset + 1];
					final ArrayList l = (ArrayList) _symbol_l.value;
					final Symbol _symbol_id = _symbols[offset + 3];
					final ArrayList id = (ArrayList) _symbol_id.value;
					 l.add(new QID((String[])id.toArray(new String[id.size()]))); return _symbol_l;
			}
			case 94: // regexpr = regexpr_kleene.r
			{
					final Symbol _symbol_r = _symbols[offset + 1];
					final AbstractIRNode r = (AbstractIRNode) _symbol_r.value;
					 return new Symbol(null);
			}
			case 95: // regexpr = regexpr.r1 regexpr_kleene.r2
			{
					final Symbol _symbol_r1 = _symbols[offset + 1];
					final AbstractIRNode r1 = (AbstractIRNode) _symbol_r1.value;
					final Symbol _symbol_r2 = _symbols[offset + 2];
					final AbstractIRNode r2 = (AbstractIRNode) _symbol_r2.value;
					 return new Symbol(null);
			}
			case 96: // regexpr = regexpr.r1 BAR regexpr_kleene.r2
			{
					final Symbol _symbol_r1 = _symbols[offset + 1];
					final AbstractIRNode r1 = (AbstractIRNode) _symbol_r1.value;
					final Symbol _symbol_r2 = _symbols[offset + 3];
					final AbstractIRNode r2 = (AbstractIRNode) _symbol_r2.value;
					 return new Symbol(null);
			}
			case 97: // regexpr_kleene = regexpr_simple.r
			{
					final Symbol _symbol_r = _symbols[offset + 1];
					final AbstractIRNode r = (AbstractIRNode) _symbol_r.value;
					 return new Symbol(null);
			}
			case 98: // regexpr_kleene = regexpr_simple.r MULT
			{
					final Symbol _symbol_r = _symbols[offset + 1];
					final AbstractIRNode r = (AbstractIRNode) _symbol_r.value;
					 return new Symbol(null);
			}
			case 99: // regexpr_simple = qual_id.n
			{
					final Symbol _symbol_n = _symbols[offset + 1];
					final ArrayList n = (ArrayList) _symbol_n.value;
					 return new Symbol(null);
			}
			case 100: // regexpr_simple = LPAREN regexpr.r RPAREN
			{
					final Symbol _symbol_r = _symbols[offset + 2];
					final AbstractIRNode r = (AbstractIRNode) _symbol_r.value;
					 return new Symbol(null);
			}
			case 101: // regexpr_simple = LBRACK regexpr.r RBRACK
			{
					final Symbol _symbol_r = _symbols[offset + 2];
					final AbstractIRNode r = (AbstractIRNode) _symbol_r.value;
					 return new Symbol(null);
			}
			case 102: // pri_inequality_list = pri_inequality.p SEMICOLON
			{
					final Symbol _symbol_p = _symbols[offset + 1];
					final ArrayList p = (ArrayList) _symbol_p.value;
					 return _symbol_p;
			}
			case 103: // pri_inequality = qual_id.high GT qual_id.low
			{
					final Symbol _symbol_high = _symbols[offset + 1];
					final ArrayList high = (ArrayList) _symbol_high.value;
					final Symbol _symbol_low = _symbols[offset + 3];
					final ArrayList low = (ArrayList) _symbol_low.value;
					 ArrayList l = new ArrayList(); 
                                          l.add(new QID((String[])high.toArray(new String[high.size()])));
                                          l.add(new QID((String[])low.toArray(new String[low.size()])));
                                          return new Symbol(l);
			}
			case 104: // pri_inequality = pri_inequality.l GT qual_id.n
			{
					final Symbol _symbol_l = _symbols[offset + 1];
					final ArrayList l = (ArrayList) _symbol_l.value;
					final Symbol _symbol_n = _symbols[offset + 3];
					final ArrayList n = (ArrayList) _symbol_n.value;
					 l.add(new QID((String[])n.toArray(new String[n.size()]))); return _symbol_l;
			}
			case 113: // actor_parameter_list = actor_parameter.p
			{
					final Symbol _symbol_p = _symbols[offset + 1];
					final ParDeclValue p = (ParDeclValue) _symbol_p.value;
					 ArrayList result = new ArrayList(); result.add(p); return new Symbol(result);
			}
			case 114: // actor_parameter_list = actor_parameter_list.l COMMA actor_parameter.p
			{
					final Symbol _symbol_l = _symbols[offset + 1];
					final ArrayList l = (ArrayList) _symbol_l.value;
					final Symbol _symbol_p = _symbols[offset + 3];
					final ParDeclValue p = (ParDeclValue) _symbol_p.value;
					 l.add(p); return _symbol_l;
			}
			case 117: // actor_parameter = IDENTIFIER.id opt$actor_parameter_init_expression.e
			{
					final Symbol id = _symbols[offset + 1];
					final Symbol _symbol_e = _symbols[offset + 2];
					final Expression e = (Expression) _symbol_e.value;
					 return new Symbol(new ParDeclValue((String)id.value, null));
			}
			case 118: // actor_parameter = type.t IDENTIFIER.id opt$actor_parameter_init_expression.e
			{
					final Symbol _symbol_t = _symbols[offset + 1];
					final TypeExpr t = (TypeExpr) _symbol_t.value;
					final Symbol id = _symbols[offset + 2];
					final Symbol _symbol_e = _symbols[offset + 3];
					final Expression e = (Expression) _symbol_e.value;
					 return new Symbol(new ParDeclValue((String)id.value, t));
			}
			case 119: // actor_parameter_init_expression = EQ expression.e
			{
					final Symbol _symbol_e = _symbols[offset + 2];
					final Expression e = (Expression) _symbol_e.value;
					 return _symbol_e;
			}
			case 120: // qual_id = IDENTIFIER.id
			{
					final Symbol id = _symbols[offset + 1];
					 ArrayList l = new ArrayList(); l.add(id.value); return new Symbol(l);
			}
			case 121: // qual_id = IDENTIFIER.id DOT qual_id.l
			{
					final Symbol id = _symbols[offset + 1];
					final Symbol _symbol_l = _symbols[offset + 3];
					final ArrayList l = (ArrayList) _symbol_l.value;
					 l.add(0, id.value); return _symbol_l;
			}
			case 122: // variable = IDENTIFIER.id
			{
					final Symbol id = _symbols[offset + 1];
					 return new Symbol(new Variable((String) id.value));
			}
			case 123: // field = IDENTIFIER.id
			{
					final Symbol id = _symbols[offset + 1];
					 return new Symbol(new Field((String) id.value));
			}
			case 124: // decl_list = decl.d
			{
					final Symbol _symbol_d = _symbols[offset + 1];
					final DeclVar d = (DeclVar) _symbol_d.value;
					 ArrayList l = new ArrayList(); l.add(d); return new Symbol(l);
			}
			case 125: // decl_list = decl_list.l COMMA decl.d
			{
					final Symbol _symbol_l = _symbols[offset + 1];
					final ArrayList l = (ArrayList) _symbol_l.value;
					final Symbol _symbol_d = _symbols[offset + 3];
					final DeclVar d = (DeclVar) _symbol_d.value;
					 l.add(d); return _symbol_l;
			}
			case 126: // decl_block = VAR decl_list.d
			{
					final Symbol _symbol_d = _symbols[offset + 2];
					final ArrayList d = (ArrayList) _symbol_d.value;
					 return _symbol_d;
			}
			case 127: // decl_block_opt = 
			{
					 return new Symbol(new ArrayList());
			}
			case 128: // decl_block_opt = VAR decl_list.d
			{
					final Symbol _symbol_d = _symbols[offset + 2];
					final ArrayList d = (ArrayList) _symbol_d.value;
					 return _symbol_d;
			}
			case 129: // decl = var_decl.d
			{
					final Symbol _symbol_d = _symbols[offset + 1];
					final DeclVar d = (DeclVar) _symbol_d.value;
					 return _symbol_d;
			}
			case 130: // decl = fun_decl.d
			{
					final Symbol _symbol_d = _symbols[offset + 1];
					final DeclVar d = (DeclVar) _symbol_d.value;
					 return _symbol_d;
			}
			case 131: // decl = proc_decl.d
			{
					final Symbol _symbol_d = _symbols[offset + 1];
					final DeclVar d = (DeclVar) _symbol_d.value;
					 return _symbol_d;
			}
			case 132: // var_decl = MUTABLE var_name_type.v
			{
					final Symbol _symbol_v = _symbols[offset + 2];
					final DeclVar v = (DeclVar) _symbol_v.value;
					 return new Symbol(new DeclVar(v.getType(), v.getName(), null, null, true));
			}
			case 133: // var_decl = MUTABLE var_name_type.v EQ expression.init
			{
					final Symbol _symbol_v = _symbols[offset + 2];
					final DeclVar v = (DeclVar) _symbol_v.value;
					final Symbol _symbol_init = _symbols[offset + 4];
					final Expression init = (Expression) _symbol_init.value;
					 return new Symbol(new DeclVar(v.getType(), v.getName(), null, init, false));
			}
			case 134: // var_decl = MUTABLE var_name_type.v EQCOLON expression.init
			{
					final Symbol _symbol_v = _symbols[offset + 2];
					final DeclVar v = (DeclVar) _symbol_v.value;
					final Symbol _symbol_init = _symbols[offset + 4];
					final Expression init = (Expression) _symbol_init.value;
					 return new Symbol(new DeclVar(v.getType(), v.getName(), null, init, true));
			}
			case 135: // var_decl = var_name_type.v
			{
					final Symbol _symbol_v = _symbols[offset + 1];
					final DeclVar v = (DeclVar) _symbol_v.value;
					 return new Symbol(new DeclVar(v.getType(), v.getName(), null, null, true));
			}
			case 136: // var_decl = var_name_type.v EQ expression.init
			{
					final Symbol _symbol_v = _symbols[offset + 1];
					final DeclVar v = (DeclVar) _symbol_v.value;
					final Symbol _symbol_init = _symbols[offset + 3];
					final Expression init = (Expression) _symbol_init.value;
					 return new Symbol(new DeclVar(v.getType(), v.getName(), null, init, false));
			}
			case 137: // var_decl = var_name_type.v COLONEQ expression.init
			{
					final Symbol _symbol_v = _symbols[offset + 1];
					final DeclVar v = (DeclVar) _symbol_v.value;
					final Symbol _symbol_init = _symbols[offset + 3];
					final Expression init = (Expression) _symbol_init.value;
					 return new Symbol(new DeclVar(v.getType(), v.getName(), null, init, true));
			}
			case 138: // var_name_type = IDENTIFIER.id
			{
					final Symbol id = _symbols[offset + 1];
					 return new Symbol(new DeclVar(null, (String)id.value, null));
			}
			case 139: // var_name_type = type.type IDENTIFIER.id
			{
					final Symbol _symbol_type = _symbols[offset + 1];
					final TypeExpr type = (TypeExpr) _symbol_type.value;
					final Symbol id = _symbols[offset + 2];
					 return new Symbol(new DeclVar(type, (String)id.value, null));
			}
			case 140: // fun_decl = FUNCTION IDENTIFIER.id lambda_expr_body.lambda
			{
					final Symbol id = _symbols[offset + 2];
					final Symbol _symbol_lambda = _symbols[offset + 3];
					final ExprLambda lambda = (ExprLambda) _symbol_lambda.value;
					 return new Symbol(new DeclVar(null, (String)id.value, null, lambda, false));
			}
			case 141: // proc_decl = PROCEDURE IDENTIFIER.id procedure_expr_body.body
			{
					final Symbol id = _symbols[offset + 2];
					final Symbol _symbol_body = _symbols[offset + 3];
					final ExprProc body = (ExprProc) _symbol_body.value;
					 return new Symbol(new DeclVar(null, (String)id.value, null, body, false));
			}
			case 142: // port_decl = IDENTIFIER.id
			{
					final Symbol id = _symbols[offset + 1];
					 return new Symbol(new AtomicPortDecl((String)id.value, null));
			}
			case 143: // port_decl = type.type IDENTIFIER.id
			{
					final Symbol _symbol_type = _symbols[offset + 1];
					final TypeExpr type = (TypeExpr) _symbol_type.value;
					final Symbol id = _symbols[offset + 2];
					 return new Symbol(new AtomicPortDecl((String)id.value, type));
			}
			case 144: // port_decl = MULTI IDENTIFIER.id
			{
					final Symbol id = _symbols[offset + 2];
					 return new Symbol(new AtomicPortDecl((String)id.value, null));
			}
			case 145: // port_decl = MULTI type.type IDENTIFIER.id
			{
					final Symbol _symbol_type = _symbols[offset + 2];
					final TypeExpr type = (TypeExpr) _symbol_type.value;
					final Symbol id = _symbols[offset + 3];
					 return new Symbol(new AtomicPortDecl((String)id.value, type));
			}
			case 146: // port_decl_list_opt = 
			{
					 return new Symbol(new CompositePortDecl());
			}
			case 147: // port_decl_list_opt = port_decl_list.l
			{
					final Symbol _symbol_l = _symbols[offset + 1];
					final CompositePortDecl l = (CompositePortDecl) _symbol_l.value;
					 return _symbol_l;
			}
			case 148: // port_decl_list = port_decl.port_decl
			{
					final Symbol _symbol_port_decl = _symbols[offset + 1];
					final PortDecl port_decl = (PortDecl) _symbol_port_decl.value;
					 CompositePortDecl l = new CompositePortDecl(); l.addChild(port_decl); return new Symbol(l);
			}
			case 149: // port_decl_list = port_decl_list.l COMMA port_decl.d
			{
					final Symbol _symbol_l = _symbols[offset + 1];
					final CompositePortDecl l = (CompositePortDecl) _symbol_l.value;
					final Symbol _symbol_d = _symbols[offset + 3];
					final PortDecl d = (PortDecl) _symbol_d.value;
					 l.addChild(d); return _symbol_l;
			}
			case 150: // type_bound = LT type.type
			{
					final Symbol _symbol_type = _symbols[offset + 2];
					final TypeExpr type = (TypeExpr) _symbol_type.value;
					 return _symbol_type;
			}
			case 151: // type_bound_opt = 
			{
					 return new Symbol(null);
			}
			case 152: // type_bound_opt = type_bound.n
			{
					final Symbol _symbol_n = _symbols[offset + 1];
					final TypeExpr n = (TypeExpr) _symbol_n.value;
					 return _symbol_n;
			}
			case 153: // type_parameter = IDENTIFIER.id type_bound_opt.type_bound
			{
					final Symbol id = _symbols[offset + 1];
					final Symbol _symbol_type_bound = _symbols[offset + 2];
					final TypeExpr type_bound = (TypeExpr) _symbol_type_bound.value;
					 return new Symbol(new ParDeclType((String)id.value));
			}
			case 156: // type_parameter_block = LBRACK opt$type_parameter_list.l RBRACK
			{
					final Symbol _symbol_l = _symbols[offset + 2];
					final ArrayList l = (ArrayList) _symbol_l.value;
					 return _symbol_l;
			}
			case 157: // type_parameter_list = type_parameter.tp
			{
					final Symbol _symbol_tp = _symbols[offset + 1];
					final ParDeclType tp = (ParDeclType) _symbol_tp.value;
					 ArrayList l = new ArrayList(); l.add(tp); return new Symbol(l);
			}
			case 158: // type_parameter_list = type_parameter_list.l COMMA type_parameter.tp
			{
					final Symbol _symbol_l = _symbols[offset + 1];
					final ArrayList l = (ArrayList) _symbol_l.value;
					final Symbol _symbol_tp = _symbols[offset + 3];
					final ParDeclType tp = (ParDeclType) _symbol_tp.value;
					 l.add(tp); return _symbol_l;
			}
			case 159: // type_list = type.t
			{
					final Symbol _symbol_t = _symbols[offset + 1];
					final TypeExpr t = (TypeExpr) _symbol_t.value;
					 ArrayList l = new ArrayList(); l.add(t); return new Symbol(l);
			}
			case 160: // type_list = type_list.l COMMA type.t
			{
					final Symbol _symbol_l = _symbols[offset + 1];
					final ArrayList l = (ArrayList) _symbol_l.value;
					final Symbol _symbol_t = _symbols[offset + 3];
					final TypeExpr t = (TypeExpr) _symbol_t.value;
					 l.add(t); return _symbol_l;
			}
			case 161: // type = IDENTIFIER.id
			{
					final Symbol id = _symbols[offset + 1];
					 return new Symbol(new TypeExpr((String)id.value));
			}
			case 164: // type = IDENTIFIER.id LBRACK opt$type_list.t RBRACK
			{
					final Symbol id = _symbols[offset + 1];
					final Symbol _symbol_t = _symbols[offset + 3];
					final ArrayList t = (ArrayList) _symbol_t.value;
					 return new Symbol(t==null ? new TypeExpr((String)id.value) : new TypeExpr((String)id.value, (TypeExpr[])t.toArray(new TypeExpr[t.size()])));
			}
			case 167: // type = IDENTIFIER.id LPAREN opt$type_attribute_list.attributes RPAREN
			{
					final Symbol id = _symbols[offset + 1];
					final Symbol _symbol_attributes = _symbols[offset + 3];
					final ArrayList attributes = (ArrayList) _symbol_attributes.value;
					 Map<String,Expression> valueParameters = new java.util.HashMap();
                                                                   Map<String,TypeExpr> typeParameters = new java.util.HashMap();
                                                                   for(Map.Entry map : (ArrayList<Map.Entry>)attributes){
                                                                     if(map.getValue() instanceof Expression){
                                                                       valueParameters.put((String)map.getKey(), (Expression)map.getValue());
                                                                     } else {
                                                                       typeParameters.put((String)map.getKey(), (TypeExpr)map.getValue());
                                                                     }
                                                                   }
                                                                   return new Symbol(new TypeExpr((String)id.value, typeParameters, valueParameters));
			}
			case 168: // type = LBRACK opt$type_list.param EDGE type.result_type RBRACK
			{
					final Symbol _symbol_param = _symbols[offset + 2];
					final ArrayList param = (ArrayList) _symbol_param.value;
					final Symbol _symbol_result_type = _symbols[offset + 4];
					final TypeExpr result_type = (TypeExpr) _symbol_result_type.value;
					 return new Symbol(null);
			}
			case 169: // type = LBRACK opt$type_list.param EDGE RBRACK
			{
					final Symbol _symbol_param = _symbols[offset + 2];
					final ArrayList param = (ArrayList) _symbol_param.value;
					 return new Symbol(null);
			}
			case 170: // type_attribute_list = type_attribute.t
			{
					final Symbol _symbol_t = _symbols[offset + 1];
					final Map.Entry t = (Map.Entry) _symbol_t.value;
					 ArrayList l = new ArrayList(); l.add(t); return new Symbol(l);
			}
			case 171: // type_attribute_list = type_attribute_list.l COMMA type_attribute.t
			{
					final Symbol _symbol_l = _symbols[offset + 1];
					final ArrayList l = (ArrayList) _symbol_l.value;
					final Symbol _symbol_t = _symbols[offset + 3];
					final Map.Entry t = (Map.Entry) _symbol_t.value;
					 l.add(t); return _symbol_l;
			}
			case 172: // type_attribute = IDENTIFIER.id COLON type.type
			{
					final Symbol id = _symbols[offset + 1];
					final Symbol _symbol_type = _symbols[offset + 3];
					final TypeExpr type = (TypeExpr) _symbol_type.value;
					 return new Symbol(new AbstractMap.SimpleEntry((String)id.value, type));
			}
			case 173: // type_attribute = IDENTIFIER.id EQ expression.e
			{
					final Symbol id = _symbols[offset + 1];
					final Symbol _symbol_e = _symbols[offset + 3];
					final Expression e = (Expression) _symbol_e.value;
					 return new Symbol(new AbstractMap.SimpleEntry((String)id.value, e));
			}
			case 174: // edge_type = EDGE type.t
			{
					final Symbol _symbol_t = _symbols[offset + 2];
					final TypeExpr t = (TypeExpr) _symbol_t.value;
					 return _symbol_t;
			}
			case 179: // procedure_expr_body = LPAREN opt$formal_parameter_list.param RPAREN opt$decl_block.decl stmt_block_opt.body end_proc
			{
					final Symbol _symbol_param = _symbols[offset + 2];
					final ArrayList param = (ArrayList) _symbol_param.value;
					final Symbol _symbol_decl = _symbols[offset + 4];
					final ArrayList decl = (ArrayList) _symbol_decl.value;
					final Symbol _symbol_body = _symbols[offset + 5];
					final ArrayList body = (ArrayList) _symbol_body.value;
					 return new Symbol(new ExprProc(new ParDeclType[0], 
                                                                                                                    param==null ? new ParDeclValue[0] : (ParDeclValue[])param.toArray(new ParDeclValue[param.size()]),
                                                                                                                    new DeclType[0],
                                                                                                                    decl==null ? new DeclVar[0] : (DeclVar[])decl.toArray(new DeclVar[decl.size()]),
                                                                                                                    (Statement[])body.toArray(new Statement[body.size()])));
			}
			case 180: // stmt_block_opt = 
			{
					 return new Symbol(new ArrayList());
			}
			case 181: // stmt_block_opt = do_begin statement_list_opt.s
			{
					final Symbol _symbol_s = _symbols[offset + 2];
					final ArrayList s = (ArrayList) _symbol_s.value;
					 return _symbol_s;
			}
			case 182: // lambda_expr_body = LPAREN opt$formal_parameter_list.param RPAREN expression.body end_lambda
			{
					final Symbol _symbol_param = _symbols[offset + 2];
					final ArrayList param = (ArrayList) _symbol_param.value;
					final Symbol _symbol_body = _symbols[offset + 4];
					final Expression body = (Expression) _symbol_body.value;
					 return new Symbol(new ExprLambda(new ParDeclType[0],
                                             param==null ? new ParDeclValue[0] : (ParDeclValue[])param.toArray(new ParDeclValue[param.size()]),
                                             new DeclType[0], 
                                             new DeclVar[0],
                                             body,
                                             null));
			}
			case 183: // lambda_expr_body = LPAREN opt$formal_parameter_list.param RPAREN opt$decl_block.decl COLON expression.body end_lambda
			{
					final Symbol _symbol_param = _symbols[offset + 2];
					final ArrayList param = (ArrayList) _symbol_param.value;
					final Symbol _symbol_decl = _symbols[offset + 4];
					final ArrayList decl = (ArrayList) _symbol_decl.value;
					final Symbol _symbol_body = _symbols[offset + 6];
					final Expression body = (Expression) _symbol_body.value;
					 return new Symbol(new ExprLambda(new ParDeclType[0],
                                             param==null ? new ParDeclValue[0] : (ParDeclValue[])param.toArray(new ParDeclValue[param.size()]),
                                             new DeclType[0],
                                             decl==null ? new DeclVar[0] : (DeclVar[])decl.toArray(new DeclVar[decl.size()]),
                                             body,
                                             null));
			}
			case 184: // lambda_expr_body = LPAREN opt$formal_parameter_list.param RPAREN edge_type.t opt$decl_block.decl COLON expression.body end_lambda
			{
					final Symbol _symbol_param = _symbols[offset + 2];
					final ArrayList param = (ArrayList) _symbol_param.value;
					final Symbol _symbol_t = _symbols[offset + 4];
					final TypeExpr t = (TypeExpr) _symbol_t.value;
					final Symbol _symbol_decl = _symbols[offset + 5];
					final ArrayList decl = (ArrayList) _symbol_decl.value;
					final Symbol _symbol_body = _symbols[offset + 7];
					final Expression body = (Expression) _symbol_body.value;
					 return new Symbol(new ExprLambda(new ParDeclType[0],
                                             param==null ? new ParDeclValue[0] : (ParDeclValue[])param.toArray(new ParDeclValue[param.size()]),
                                             new DeclType[0],
                                             decl==null ? new DeclVar[0] : (DeclVar[])decl.toArray(new DeclVar[decl.size()]),
                                             body,
                                             t));
			}
			case 185: // map_list = map_entry.m
			{
					final Symbol _symbol_m = _symbols[offset + 1];
					final Map.Entry m = (Map.Entry) _symbol_m.value;
					 ArrayList l = new ArrayList(); l.add(m); return new Symbol(l);
			}
			case 186: // map_list = map_list.l COMMA map_entry.m
			{
					final Symbol _symbol_l = _symbols[offset + 1];
					final ArrayList l = (ArrayList) _symbol_l.value;
					final Symbol _symbol_m = _symbols[offset + 3];
					final Map.Entry m = (Map.Entry) _symbol_m.value;
					 l.add(m); return _symbol_l;
			}
			case 187: // map_entry = expression.e1 ARROW expression.e2
			{
					final Symbol _symbol_e1 = _symbols[offset + 1];
					final Expression e1 = (Expression) _symbol_e1.value;
					final Symbol _symbol_e2 = _symbols[offset + 3];
					final Expression e2 = (Expression) _symbol_e2.value;
					 return new Symbol(new AbstractMap.SimpleEntry(e1, e2));
			}
			case 188: // tail = BAR expression.e
			{
					final Symbol _symbol_e = _symbols[offset + 2];
					final Expression e = (Expression) _symbol_e.value;
					 return _symbol_e;
			}
			case 189: // expression_list = expression.e
			{
					final Symbol _symbol_e = _symbols[offset + 1];
					final Expression e = (Expression) _symbol_e.value;
					 ArrayList l = new ArrayList(); l.add(e); return new Symbol(l);
			}
			case 190: // expression_list = expression_list.l COMMA expression.e
			{
					final Symbol _symbol_l = _symbols[offset + 1];
					final ArrayList l = (ArrayList) _symbol_l.value;
					final Symbol _symbol_e = _symbols[offset + 3];
					final Expression e = (Expression) _symbol_e.value;
					 l.add(e); return _symbol_l;
			}
			case 191: // expression_list_opt = 
			{
					 return new Symbol(new ArrayList());
			}
			case 192: // expression_list_opt = expression_list.n
			{
					final Symbol _symbol_n = _symbols[offset + 1];
					final ArrayList n = (ArrayList) _symbol_n.value;
					 return _symbol_n;
			}
			case 193: // method_invocation = simple_expression.function LPAREN opt$expression_list.args RPAREN
			{
					final Symbol _symbol_function = _symbols[offset + 1];
					final Expression function = (Expression) _symbol_function.value;
					final Symbol _symbol_args = _symbols[offset + 3];
					final ArrayList args = (ArrayList) _symbol_args.value;
					 return new Symbol(new ExprApplication(function, args==null ? new Expression[0] : (Expression[])args.toArray(new Expression[args.size()])));
			}
			case 194: // literal = INTEGER_LITERAL.txt
			{
					final Symbol txt = _symbols[offset + 1];
					 return new Symbol(new ExprLiteral(ExprLiteral.litInteger, ((String)txt.value)));
			}
			case 195: // literal = LONG_LITERAL.txt
			{
					final Symbol txt = _symbols[offset + 1];
					 return new Symbol(new ExprLiteral(ExprLiteral.litInteger, ((String)txt.value)));
			}
			case 196: // literal = FLOATING_POINT_LITERAL.txt
			{
					final Symbol txt = _symbols[offset + 1];
					 return new Symbol(new ExprLiteral(ExprLiteral.litInteger, ((String)txt.value)));
			}
			case 197: // literal = DOUBLE_LITERAL.txt
			{
					final Symbol txt = _symbols[offset + 1];
					 return new Symbol(new ExprLiteral(ExprLiteral.litReal, ((String)txt.value)));
			}
			case 198: // literal = TRUE_LITERAL.txt
			{
					final Symbol txt = _symbols[offset + 1];
					 return new Symbol(new ExprLiteral(ExprLiteral.litTrue, ((String)txt.value)));
			}
			case 199: // literal = FALSE_LITERAL.txt
			{
					final Symbol txt = _symbols[offset + 1];
					 return new Symbol(new ExprLiteral(ExprLiteral.litFalse, ((String)txt.value)));
			}
			case 200: // literal = CHARACTER_LITERAL.txt
			{
					final Symbol txt = _symbols[offset + 1];
					 return new Symbol(new ExprLiteral(ExprLiteral.litChar, ((String)txt.value)));
			}
			case 201: // literal = STRING_LITERAL.txt
			{
					final Symbol txt = _symbols[offset + 1];
					 return new Symbol(new ExprLiteral(ExprLiteral.litString, ((String)txt.value)));
			}
			case 202: // literal = NULL_LITERAL.txt
			{
					final Symbol txt = _symbols[offset + 1];
					 return new Symbol(new ExprLiteral(ExprLiteral.litNull, ((String)txt.value)));
			}
			case 203: // primary = literal.l
			{
					final Symbol _symbol_l = _symbols[offset + 1];
					final ExprLiteral l = (ExprLiteral) _symbol_l.value;
					 return _symbol_l;
			}
			case 204: // primary = LPAREN expression.e RPAREN
			{
					final Symbol _symbol_e = _symbols[offset + 2];
					final Expression e = (Expression) _symbol_e.value;
					 return new ParenthesSymbol(_symbol_e);
			}
			case 205: // primary = LPAREN.start expression.e DOUBLECOLON type.t RPAREN
			{
					final Symbol start = _symbols[offset + 1];
					final Symbol _symbol_e = _symbols[offset + 2];
					final Expression e = (Expression) _symbol_e.value;
					final Symbol _symbol_t = _symbols[offset + 4];
					final TypeExpr t = (TypeExpr) _symbol_t.value;
					 parseProblems.add("Type assertion is not supported. Assertion is ignored at " + Symbol.getLine(start.getStart()) + ", " + Symbol.getColumn(start.getStart()));
			}
			case 206: // simple_expression = primary.p
			{
					final Symbol _symbol_p = _symbols[offset + 1];
					final Expression p = (Expression) _symbol_p.value;
					 return _symbol_p;
			}
			case 207: // simple_expression = variable.v
			{
					final Symbol _symbol_v = _symbols[offset + 1];
					final Variable v = (Variable) _symbol_v.value;
					 return new Symbol(new ExprVariable(v));
			}
			case 208: // simple_expression = OLD variable.v
			{
					final Symbol _symbol_v = _symbols[offset + 2];
					final Variable v = (Variable) _symbol_v.value;
					 return new Symbol(new ExprVariable(v));
			}
			case 209: // simple_expression = method_invocation.m
			{
					final Symbol _symbol_m = _symbols[offset + 1];
					final ExprApplication m = (ExprApplication) _symbol_m.value;
					 return _symbol_m;
			}
			case 210: // simple_expression = IF expression.c THEN expression.e1 ELSE expression.e2 END
			{
					final Symbol _symbol_c = _symbols[offset + 2];
					final Expression c = (Expression) _symbol_c.value;
					final Symbol _symbol_e1 = _symbols[offset + 4];
					final Expression e1 = (Expression) _symbol_e1.value;
					final Symbol _symbol_e2 = _symbols[offset + 6];
					final Expression e2 = (Expression) _symbol_e2.value;
					 return new Symbol(new ExprIf(c, e1, e2));
			}
			case 211: // simple_expression = LBRACE expression_list_opt.e RBRACE
			{
					final Symbol _symbol_e = _symbols[offset + 2];
					final ArrayList e = (ArrayList) _symbol_e.value;
					 return new Symbol(new ExprSet((Expression[])e.toArray(new Expression[e.size()])));
			}
			case 212: // simple_expression = LBRACE expression_list_opt.e COLON for_generator_list.l RBRACE
			{
					final Symbol _symbol_e = _symbols[offset + 2];
					final ArrayList e = (ArrayList) _symbol_e.value;
					final Symbol _symbol_l = _symbols[offset + 4];
					final ArrayList l = (ArrayList) _symbol_l.value;
					 return new Symbol(new ExprSet((Expression[])e.toArray(new Expression[e.size()]), (GeneratorFilter[])l.toArray(new GeneratorFilter[l.size()])));
			}
			case 213: // simple_expression = LBRACK expression_list_opt.e RBRACK
			{
					final Symbol _symbol_e = _symbols[offset + 2];
					final ArrayList e = (ArrayList) _symbol_e.value;
					 return new Symbol(new ExprList((Expression[])e.toArray(new Expression[e.size()])));
			}
			case 214: // simple_expression = LBRACK expression_list_opt.e tail.tail RBRACK
			{
					final Symbol _symbol_e = _symbols[offset + 2];
					final ArrayList e = (ArrayList) _symbol_e.value;
					final Symbol _symbol_tail = _symbols[offset + 3];
					final Expression tail = (Expression) _symbol_tail.value;
					 return new Symbol(new ExprList((Expression[])e.toArray(new Expression[e.size()])));
			}
			case 215: // simple_expression = LBRACK expression_list_opt.e COLON for_generator_list.l RBRACK
			{
					final Symbol _symbol_e = _symbols[offset + 2];
					final ArrayList e = (ArrayList) _symbol_e.value;
					final Symbol _symbol_l = _symbols[offset + 4];
					final ArrayList l = (ArrayList) _symbol_l.value;
					 return new Symbol(new ExprList((Expression[])e.toArray(new Expression[e.size()]), (GeneratorFilter[])l.toArray(new GeneratorFilter[l.size()])));
			}
			case 216: // simple_expression = LBRACK expression_list_opt.e COLON for_generator_list.l tail.tail RBRACK
			{
					final Symbol _symbol_e = _symbols[offset + 2];
					final ArrayList e = (ArrayList) _symbol_e.value;
					final Symbol _symbol_l = _symbols[offset + 4];
					final ArrayList l = (ArrayList) _symbol_l.value;
					final Symbol _symbol_tail = _symbols[offset + 5];
					final Expression tail = (Expression) _symbol_tail.value;
					 return new Symbol(new ExprList((Expression[])e.toArray(new Expression[e.size()]), (GeneratorFilter[])l.toArray(new GeneratorFilter[l.size()])));
			}
			case 219: // simple_expression = MAP LBRACE opt$map_list.m RBRACE
			{
					final Symbol _symbol_m = _symbols[offset + 3];
					final ArrayList m = (ArrayList) _symbol_m.value;
					 return new Symbol(new ExprMap(m==null? new java.util.Map.Entry[0] : 
                                                                                                              (java.util.Map.Entry<Expression,Expression>[])m.toArray(new java.util.Map.Entry[m.size()])));
			}
			case 220: // simple_expression = MAP LBRACE opt$map_list.m COLON for_generator_list.generators RBRACE
			{
					final Symbol _symbol_m = _symbols[offset + 3];
					final ArrayList m = (ArrayList) _symbol_m.value;
					final Symbol _symbol_generators = _symbols[offset + 5];
					final ArrayList generators = (ArrayList) _symbol_generators.value;
					 return new Symbol(new ExprMap(m==null? new java.util.Map.Entry[0] : 
                                                                                                              (java.util.Map.Entry<Expression,Expression>[])m.toArray(new java.util.Map.Entry[m.size()]), 
                                                                                                              (GeneratorFilter[])generators.toArray(new GeneratorFilter[generators.size()])));
			}
			case 221: // simple_expression = LET decl_list.l COLON expression.e end_let
			{
					final Symbol _symbol_l = _symbols[offset + 2];
					final ArrayList l = (ArrayList) _symbol_l.value;
					final Symbol _symbol_e = _symbols[offset + 4];
					final Expression e = (Expression) _symbol_e.value;
					 return new Symbol(new ExprLet(new DeclType[0], (DeclVar[])l.toArray(new DeclVar[l.size()]), e));
			}
			case 222: // simple_expression = LAMBDA lambda_expr_body.lambda
			{
					final Symbol _symbol_lambda = _symbols[offset + 2];
					final ExprLambda lambda = (ExprLambda) _symbol_lambda.value;
					 return _symbol_lambda;
			}
			case 223: // simple_expression = CONST LAMBDA lambda_expr_body.lambda
			{
					final Symbol _symbol_lambda = _symbols[offset + 3];
					final ExprLambda lambda = (ExprLambda) _symbol_lambda.value;
					 return _symbol_lambda;
			}
			case 224: // simple_expression = PROC procedure_expr_body.p
			{
					final Symbol _symbol_p = _symbols[offset + 2];
					final ExprProc p = (ExprProc) _symbol_p.value;
					 return _symbol_p;
			}
			case 225: // unary_expression = simple_expression.e
			{
					final Symbol _symbol_e = _symbols[offset + 1];
					final Expression e = (Expression) _symbol_e.value;
					 return _symbol_e;
			}
			case 226: // unary_expression = operator.operator unary_expression.expr
			{
					final Symbol _symbol_operator = _symbols[offset + 1];
					final String operator = (String) _symbol_operator.value;
					final Symbol _symbol_expr = _symbols[offset + 2];
					final Expression expr = (Expression) _symbol_expr.value;
					 return new Symbol(new ExprUnaryOp(operator, expr));
			}
			case 227: // indexing_expression = unary_expression.e
			{
					final Symbol _symbol_e = _symbols[offset + 1];
					final Expression e = (Expression) _symbol_e.value;
					 return _symbol_e;
			}
			case 228: // indexing_expression = indexer.i
			{
					final Symbol i = _symbols[offset + 1];
					 return i;
			}
			case 229: // indexing_expression = indexing_expression.p DOT field.f
			{
					final Symbol _symbol_p = _symbols[offset + 1];
					final Expression p = (Expression) _symbol_p.value;
					final Symbol _symbol_f = _symbols[offset + 3];
					final Field f = (Field) _symbol_f.value;
					 return new Symbol(new ExprField(p, f));
			}
			case 230: // indexer = indexer_start.s expression.i RBRACK
			{
					final Symbol _symbol_s = _symbols[offset + 1];
					final Expression s = (Expression) _symbol_s.value;
					final Symbol _symbol_i = _symbols[offset + 2];
					final Expression i = (Expression) _symbol_i.value;
					 return new Symbol(new ExprIndexer(s, i));
			}
			case 231: // indexer_start = indexing_expression.e LBRACK
			{
					final Symbol _symbol_e = _symbols[offset + 1];
					final Expression e = (Expression) _symbol_e.value;
					 return _symbol_e;
			}
			case 232: // indexer_start = indexer_start.s expression.i COMMA
			{
					final Symbol _symbol_s = _symbols[offset + 1];
					final Expression s = (Expression) _symbol_s.value;
					final Symbol _symbol_i = _symbols[offset + 2];
					final Expression i = (Expression) _symbol_i.value;
					 return new Symbol(new ExprIndexer(s, i));
			}
			case 233: // expression = indexing_expression.e
			{
					final Symbol _symbol_e = _symbols[offset + 1];
					final Expression e = (Expression) _symbol_e.value;
					 return _symbol_e;
			}
			case 234: // expression = expression.arg1 operator.operator indexing_expression.arg2
			{
					final Symbol _symbol_arg1 = _symbols[offset + 1];
					final Expression arg1 = (Expression) _symbol_arg1.value;
					final Symbol _symbol_operator = _symbols[offset + 2];
					final String operator = (String) _symbol_operator.value;
					final Symbol _symbol_arg2 = _symbols[offset + 3];
					final Expression arg2 = (Expression) _symbol_arg2.value;
					 String[] operators;
                                                               Expression[] operands;
                                                               boolean arg1IsPar = _symbol_arg1 instanceof ParenthesSymbol;
                                                               if((arg1 instanceof ExprBinaryOp) && !(arg1IsPar)){
                                                                 ExprBinaryOp expr = (ExprBinaryOp)arg1;
                                                                 operators = Arrays.copyOf(expr.getOperations(), expr.getOperations().length + 1);
                                                                 operators[operators.length-1] = operator;
                                                                 operands = Arrays.copyOf(expr.getOperands(), expr.getOperands().length + 1);
                                                                 operands[operands.length-1] = arg2;
                                                               } else {
                                                                 operators = new String[1];
                                                                 operators[0] = operator;
                                                                 operands = new Expression[2];
                                                                 operands[0] = arg1;
                                                                 operands[1] = arg2;
                                                               }
                                                               return new Symbol(new ExprBinaryOp(operators, operands));
			}
			case 235: // operator = OPERATOR.op
			{
					final Symbol op = _symbols[offset + 1];
					 return op;
			}
			case 236: // operator = EQ.op
			{
					final Symbol op = _symbols[offset + 1];
					 return op;
			}
			case 237: // operator = IN.op
			{
					final Symbol op = _symbols[offset + 1];
					 return op;
			}
			case 238: // operator = GT.op
			{
					final Symbol op = _symbols[offset + 1];
					 return op;
			}
			case 239: // operator = MULT.op
			{
					final Symbol op = _symbols[offset + 1];
					 return op;
			}
			case 240: // formal_parameter = IDENTIFIER.id
			{
					final Symbol id = _symbols[offset + 1];
					 return new Symbol(new ParDeclValue((String)id.value, null));
			}
			case 241: // formal_parameter = type.t IDENTIFIER.id
			{
					final Symbol _symbol_t = _symbols[offset + 1];
					final TypeExpr t = (TypeExpr) _symbol_t.value;
					final Symbol id = _symbols[offset + 2];
					 return new Symbol(new ParDeclValue((String)id.value, t));
			}
			case 242: // formal_parameter_list = formal_parameter.p
			{
					final Symbol _symbol_p = _symbols[offset + 1];
					final ParDeclValue p = (ParDeclValue) _symbol_p.value;
					 ArrayList l = new ArrayList(); l.add(p); return new Symbol(l);
			}
			case 243: // formal_parameter_list = formal_parameter_list.l COMMA formal_parameter.p
			{
					final Symbol _symbol_l = _symbols[offset + 1];
					final ArrayList l = (ArrayList) _symbol_l.value;
					final Symbol _symbol_p = _symbols[offset + 3];
					final ParDeclValue p = (ParDeclValue) _symbol_p.value;
					 l.add(p);  return _symbol_l;
			}
			case 244: // statement = expression.lhs COLONEQ expression.value SEMICOLON
			{
					final Symbol _symbol_lhs = _symbols[offset + 1];
					final Expression lhs = (Expression) _symbol_lhs.value;
					final Symbol _symbol_value = _symbols[offset + 3];
					final Expression value = (Expression) _symbol_value.value;
					 LValue lvalue = expressionToLValue(lhs);
                                                         if (lvalue != null) return new Symbol(new StmtAssignment(lvalue, value));
                                                         newError("Illegal left hand sign of assignment.", _symbol_lhs);
                                                         return new Symbol(new StmtAssignment(new LValueVariable(new Variable("$illegal")), value));
			}
			case 245: // statement = method_invocation.m SEMICOLON
			{
					final Symbol _symbol_m = _symbols[offset + 1];
					final ExprApplication m = (ExprApplication) _symbol_m.value;
					 return new Symbol(new StmtCall(m.getFunction(), m.getArgs()));
			}
			case 246: // statement = BEGIN statement_list_opt.s END
			{
					final Symbol _symbol_s = _symbols[offset + 2];
					final ArrayList s = (ArrayList) _symbol_s.value;
					 return new Symbol(new StmtBlock(new DeclType[0], new DeclVar[0], (Statement[])s.toArray(new Statement[s.size()])));
			}
			case 247: // statement = BEGIN VAR decl_list.d DO statement_list_opt.s END
			{
					final Symbol _symbol_d = _symbols[offset + 3];
					final ArrayList d = (ArrayList) _symbol_d.value;
					final Symbol _symbol_s = _symbols[offset + 5];
					final ArrayList s = (ArrayList) _symbol_s.value;
					 return new Symbol(new StmtBlock(new DeclType[0], (DeclVar[])d.toArray(new DeclVar[d.size()]), (Statement[])s.toArray(new Statement[s.size()])));
			}
			case 248: // statement = IF expression.e THEN statement_list_opt.s end_if
			{
					final Symbol _symbol_e = _symbols[offset + 2];
					final Expression e = (Expression) _symbol_e.value;
					final Symbol _symbol_s = _symbols[offset + 4];
					final ArrayList s = (ArrayList) _symbol_s.value;
					 return new Symbol(new StmtIf(e, new StmtBlock(null, null, (Statement[])s.toArray(new Statement[s.size()])), null));
			}
			case 249: // statement = IF expression.e THEN statement_list_opt.s1 ELSE statement_list_opt.s2 end_if
			{
					final Symbol _symbol_e = _symbols[offset + 2];
					final Expression e = (Expression) _symbol_e.value;
					final Symbol _symbol_s1 = _symbols[offset + 4];
					final ArrayList s1 = (ArrayList) _symbol_s1.value;
					final Symbol _symbol_s2 = _symbols[offset + 6];
					final ArrayList s2 = (ArrayList) _symbol_s2.value;
					 return new Symbol(new StmtIf(e, 
                                                                                                                 new StmtBlock(null, null, (Statement[])s1.toArray(new Statement[s1.size()])),
                                                                                                                 new StmtBlock(null, null, (Statement[])s2.toArray(new Statement[s2.size()]))));
			}
			case 250: // statement = WHILE expression.e decl_block_opt.d DO statement_list_opt.s end_while
			{
					final Symbol _symbol_e = _symbols[offset + 2];
					final Expression e = (Expression) _symbol_e.value;
					final Symbol _symbol_d = _symbols[offset + 3];
					final ArrayList d = (ArrayList) _symbol_d.value;
					final Symbol _symbol_s = _symbols[offset + 5];
					final ArrayList s = (ArrayList) _symbol_s.value;
					 return new Symbol(new StmtWhile(e, new StmtBlock(new DeclType[0],
                                                                                                                              (DeclVar[])d.toArray(new DeclVar[d.size()]),
                                                                                                                              (Statement[])s.toArray(new Statement[s.size()]))));
			}
			case 254: // statement = for_generator_list.g DO statement_list_opt.s end_foreach
			{
					final Symbol _symbol_g = _symbols[offset + 1];
					final ArrayList g = (ArrayList) _symbol_g.value;
					final Symbol _symbol_s = _symbols[offset + 3];
					final ArrayList s = (ArrayList) _symbol_s.value;
					 return new Symbol(new StmtForeach((GeneratorFilter[])g.toArray(new GeneratorFilter[g.size()]),
                                                                                                               new StmtBlock(new DeclType[0], new DeclVar[0], (Statement[])s.toArray(new Statement[s.size()]))));
			}
			case 255: // statement = for_generator_list.g decl_block.d DO statement_list_opt.s end_foreach
			{
					final Symbol _symbol_g = _symbols[offset + 1];
					final ArrayList g = (ArrayList) _symbol_g.value;
					final Symbol _symbol_d = _symbols[offset + 2];
					final ArrayList d = (ArrayList) _symbol_d.value;
					final Symbol _symbol_s = _symbols[offset + 4];
					final ArrayList s = (ArrayList) _symbol_s.value;
					 return new Symbol(new StmtForeach((GeneratorFilter[])g.toArray(new GeneratorFilter[g.size()]),
                                                                                                               new StmtBlock(new DeclType[0], (DeclVar[])d.toArray(new DeclVar[d.size()]), (Statement[])s.toArray(new Statement[s.size()]))));
			}
			case 256: // choose_generator_list = CHOOSE generator_variable_list.vars IN expression.e
			{
					final Symbol _symbol_vars = _symbols[offset + 2];
					final ArrayList vars = (ArrayList) _symbol_vars.value;
					final Symbol _symbol_e = _symbols[offset + 4];
					final Expression e = (Expression) _symbol_e.value;
					 ArrayList l = new ArrayList(); l.add(makeGeneratorFilter(null, vars, e, null)); return new Symbol(l);
			}
			case 257: // choose_generator_list = CHOOSE type.t generator_variable_list.vars IN expression.e
			{
					final Symbol _symbol_t = _symbols[offset + 2];
					final TypeExpr t = (TypeExpr) _symbol_t.value;
					final Symbol _symbol_vars = _symbols[offset + 3];
					final ArrayList vars = (ArrayList) _symbol_vars.value;
					final Symbol _symbol_e = _symbols[offset + 5];
					final Expression e = (Expression) _symbol_e.value;
					 ArrayList l = new ArrayList(); l.add(makeGeneratorFilter(t, vars, e, null)); return new Symbol(l);
			}
			case 258: // choose_generator_list = CHOOSE generator_variable_list.vars IN expression.e COMMA expression_list.filters
			{
					final Symbol _symbol_vars = _symbols[offset + 2];
					final ArrayList vars = (ArrayList) _symbol_vars.value;
					final Symbol _symbol_e = _symbols[offset + 4];
					final Expression e = (Expression) _symbol_e.value;
					final Symbol _symbol_filters = _symbols[offset + 6];
					final ArrayList filters = (ArrayList) _symbol_filters.value;
					 ArrayList l = new ArrayList(); l.add(makeGeneratorFilter(null, vars, e, filters)); return new Symbol(l);
			}
			case 259: // choose_generator_list = CHOOSE type.t generator_variable_list.vars IN expression.e COMMA expression_list.filters
			{
					final Symbol _symbol_t = _symbols[offset + 2];
					final TypeExpr t = (TypeExpr) _symbol_t.value;
					final Symbol _symbol_vars = _symbols[offset + 3];
					final ArrayList vars = (ArrayList) _symbol_vars.value;
					final Symbol _symbol_e = _symbols[offset + 5];
					final Expression e = (Expression) _symbol_e.value;
					final Symbol _symbol_filters = _symbols[offset + 7];
					final ArrayList filters = (ArrayList) _symbol_filters.value;
					 ArrayList l = new ArrayList(); l.add(makeGeneratorFilter(t, vars, e, filters)); return new Symbol(l);
			}
			case 260: // choose_generator_list = CHOOSE generator_variable_list.vars IN expression.e COMMA choose_generator_list.l
			{
					final Symbol _symbol_vars = _symbols[offset + 2];
					final ArrayList vars = (ArrayList) _symbol_vars.value;
					final Symbol _symbol_e = _symbols[offset + 4];
					final Expression e = (Expression) _symbol_e.value;
					final Symbol _symbol_l = _symbols[offset + 6];
					final ArrayList l = (ArrayList) _symbol_l.value;
					 l.add(0, makeGeneratorFilter(null, vars, e, null)); return _symbol_l;
			}
			case 261: // choose_generator_list = CHOOSE type.t generator_variable_list.vars IN expression.e COMMA choose_generator_list.l
			{
					final Symbol _symbol_t = _symbols[offset + 2];
					final TypeExpr t = (TypeExpr) _symbol_t.value;
					final Symbol _symbol_vars = _symbols[offset + 3];
					final ArrayList vars = (ArrayList) _symbol_vars.value;
					final Symbol _symbol_e = _symbols[offset + 5];
					final Expression e = (Expression) _symbol_e.value;
					final Symbol _symbol_l = _symbols[offset + 7];
					final ArrayList l = (ArrayList) _symbol_l.value;
					 l.add(0, makeGeneratorFilter(t, vars, e, null)); return _symbol_l;
			}
			case 262: // choose_generator_list = CHOOSE generator_variable_list.vars IN expression.e COMMA expression_list.filters COMMA choose_generator_list.l
			{
					final Symbol _symbol_vars = _symbols[offset + 2];
					final ArrayList vars = (ArrayList) _symbol_vars.value;
					final Symbol _symbol_e = _symbols[offset + 4];
					final Expression e = (Expression) _symbol_e.value;
					final Symbol _symbol_filters = _symbols[offset + 6];
					final ArrayList filters = (ArrayList) _symbol_filters.value;
					final Symbol _symbol_l = _symbols[offset + 8];
					final ArrayList l = (ArrayList) _symbol_l.value;
					 l.add(0, makeGeneratorFilter(null, vars, e, filters)); return _symbol_l;
			}
			case 263: // choose_generator_list = CHOOSE type.t generator_variable_list.vars IN expression.e COMMA expression_list.filters COMMA choose_generator_list.l
			{
					final Symbol _symbol_t = _symbols[offset + 2];
					final TypeExpr t = (TypeExpr) _symbol_t.value;
					final Symbol _symbol_vars = _symbols[offset + 3];
					final ArrayList vars = (ArrayList) _symbol_vars.value;
					final Symbol _symbol_e = _symbols[offset + 5];
					final Expression e = (Expression) _symbol_e.value;
					final Symbol _symbol_filters = _symbols[offset + 7];
					final ArrayList filters = (ArrayList) _symbol_filters.value;
					final Symbol _symbol_l = _symbols[offset + 9];
					final ArrayList l = (ArrayList) _symbol_l.value;
					 l.add(0, makeGeneratorFilter(t, vars, e, filters)); return _symbol_l;
			}
			case 264: // for_generator_list = for_foreach generator_variable_list.vars IN expression.e
			{
					final Symbol _symbol_vars = _symbols[offset + 2];
					final ArrayList vars = (ArrayList) _symbol_vars.value;
					final Symbol _symbol_e = _symbols[offset + 4];
					final Expression e = (Expression) _symbol_e.value;
					 ArrayList l = new ArrayList(); l.add(makeGeneratorFilter(null, vars, e, null)); return new Symbol(l);
			}
			case 265: // for_generator_list = for_foreach type.t generator_variable_list.vars IN expression.e
			{
					final Symbol _symbol_t = _symbols[offset + 2];
					final TypeExpr t = (TypeExpr) _symbol_t.value;
					final Symbol _symbol_vars = _symbols[offset + 3];
					final ArrayList vars = (ArrayList) _symbol_vars.value;
					final Symbol _symbol_e = _symbols[offset + 5];
					final Expression e = (Expression) _symbol_e.value;
					 ArrayList l = new ArrayList(); l.add(makeGeneratorFilter(t, vars, e, null)); return new Symbol(l);
			}
			case 266: // for_generator_list = for_foreach generator_variable_list.vars IN expression.e COMMA expression_list.filters
			{
					final Symbol _symbol_vars = _symbols[offset + 2];
					final ArrayList vars = (ArrayList) _symbol_vars.value;
					final Symbol _symbol_e = _symbols[offset + 4];
					final Expression e = (Expression) _symbol_e.value;
					final Symbol _symbol_filters = _symbols[offset + 6];
					final ArrayList filters = (ArrayList) _symbol_filters.value;
					 ArrayList l = new ArrayList(); l.add(makeGeneratorFilter(null, vars, e, filters)); return new Symbol(l);
			}
			case 267: // for_generator_list = for_foreach type.t generator_variable_list.vars IN expression.e COMMA expression_list.filters
			{
					final Symbol _symbol_t = _symbols[offset + 2];
					final TypeExpr t = (TypeExpr) _symbol_t.value;
					final Symbol _symbol_vars = _symbols[offset + 3];
					final ArrayList vars = (ArrayList) _symbol_vars.value;
					final Symbol _symbol_e = _symbols[offset + 5];
					final Expression e = (Expression) _symbol_e.value;
					final Symbol _symbol_filters = _symbols[offset + 7];
					final ArrayList filters = (ArrayList) _symbol_filters.value;
					 ArrayList l = new ArrayList(); l.add(makeGeneratorFilter(t, vars, e, filters)); return new Symbol(l);
			}
			case 268: // for_generator_list = for_foreach generator_variable_list.vars IN expression.e COMMA for_generator_list.l
			{
					final Symbol _symbol_vars = _symbols[offset + 2];
					final ArrayList vars = (ArrayList) _symbol_vars.value;
					final Symbol _symbol_e = _symbols[offset + 4];
					final Expression e = (Expression) _symbol_e.value;
					final Symbol _symbol_l = _symbols[offset + 6];
					final ArrayList l = (ArrayList) _symbol_l.value;
					 l.add(0, makeGeneratorFilter(null, vars, e, null)); return _symbol_l;
			}
			case 269: // for_generator_list = for_foreach type.t generator_variable_list.vars IN expression.e COMMA for_generator_list.l
			{
					final Symbol _symbol_t = _symbols[offset + 2];
					final TypeExpr t = (TypeExpr) _symbol_t.value;
					final Symbol _symbol_vars = _symbols[offset + 3];
					final ArrayList vars = (ArrayList) _symbol_vars.value;
					final Symbol _symbol_e = _symbols[offset + 5];
					final Expression e = (Expression) _symbol_e.value;
					final Symbol _symbol_l = _symbols[offset + 7];
					final ArrayList l = (ArrayList) _symbol_l.value;
					 l.add(0, makeGeneratorFilter(t, vars, e, null)); return _symbol_l;
			}
			case 270: // for_generator_list = for_foreach generator_variable_list.vars IN expression.e COMMA expression_list.filters COMMA for_generator_list.l
			{
					final Symbol _symbol_vars = _symbols[offset + 2];
					final ArrayList vars = (ArrayList) _symbol_vars.value;
					final Symbol _symbol_e = _symbols[offset + 4];
					final Expression e = (Expression) _symbol_e.value;
					final Symbol _symbol_filters = _symbols[offset + 6];
					final ArrayList filters = (ArrayList) _symbol_filters.value;
					final Symbol _symbol_l = _symbols[offset + 8];
					final ArrayList l = (ArrayList) _symbol_l.value;
					 l.add(0, makeGeneratorFilter(null, vars, e, filters)); return _symbol_l;
			}
			case 271: // for_generator_list = for_foreach type.t generator_variable_list.vars IN expression.e COMMA expression_list.filters COMMA for_generator_list.l
			{
					final Symbol _symbol_t = _symbols[offset + 2];
					final TypeExpr t = (TypeExpr) _symbol_t.value;
					final Symbol _symbol_vars = _symbols[offset + 3];
					final ArrayList vars = (ArrayList) _symbol_vars.value;
					final Symbol _symbol_e = _symbols[offset + 5];
					final Expression e = (Expression) _symbol_e.value;
					final Symbol _symbol_filters = _symbols[offset + 7];
					final ArrayList filters = (ArrayList) _symbol_filters.value;
					final Symbol _symbol_l = _symbols[offset + 9];
					final ArrayList l = (ArrayList) _symbol_l.value;
					 l.add(0, makeGeneratorFilter(t, vars, e, filters)); return _symbol_l;
			}
			case 272: // generator_variable_list = IDENTIFIER.id
			{
					final Symbol id = _symbols[offset + 1];
					 ArrayList l = new ArrayList(); l.add(id); return new Symbol(l);
			}
			case 273: // generator_variable_list = generator_variable_list.l COMMA IDENTIFIER.id
			{
					final Symbol _symbol_l = _symbols[offset + 1];
					final ArrayList l = (ArrayList) _symbol_l.value;
					final Symbol id = _symbols[offset + 3];
					 l.add(id); return _symbol_l;
			}
			case 292: // statement_list_opt = 
			{
					 return new Symbol(new ArrayList());
			}
			case 293: // statement_list_opt = statement_list.l
			{
					final Symbol _symbol_l = _symbols[offset + 1];
					final ArrayList l = (ArrayList) _symbol_l.value;
					 return _symbol_l;
			}
			case 294: // statement_list = statement.n
			{
					final Symbol _symbol_n = _symbols[offset + 1];
					final Statement n = (Statement) _symbol_n.value;
					 ArrayList l = new ArrayList(); l.add(n); return new Symbol(l);
			}
			case 295: // statement_list = statement_list.l statement.n
			{
					final Symbol _symbol_l = _symbols[offset + 1];
					final ArrayList l = (ArrayList) _symbol_l.value;
					final Symbol _symbol_n = _symbols[offset + 2];
					final Statement n = (Statement) _symbol_n.value;
					 l.add(n); return _symbol_l;
			}
			case 0: // opt$SEMICOLON = 
			case 10: // opt$action_tag = 
			case 12: // opt$action_output_expression_list = 
			case 16: // opt$lst$action_head = 
			case 29: // opt$port_name_colon = 
			case 31: // opt$token_name_list = 
			case 33: // opt$repeat = 
			case 35: // opt$channel_selector = 
			case 42: // opt$ATSTAR = 
			case 49: // opt$expression_list = 
			case 53: // opt$import_list = 
			case 55: // opt$type_parameter_block = 
			case 57: // opt$actor_parameter_list = 
			case 59: // opt$time = 
			case 63: // opt$lst$actor_body = 
			case 78: // opt$FSM = 
			case 82: // opt$lst$fsm_state_transitions = 
			case 88: // opt$lst$fsm_state_target = 
			case 115: // opt$actor_parameter_init_expression = 
			case 154: // opt$type_parameter_list = 
			case 162: // opt$type_list = 
			case 165: // opt$type_attribute_list = 
			case 175: // opt$formal_parameter_list = 
			case 177: // opt$decl_block = 
			case 217: // opt$map_list = 
			{
				return new Symbol(null);
			}
			case 1: // opt$SEMICOLON = SEMICOLON
			case 11: // opt$action_tag = action_tag
			case 13: // opt$action_output_expression_list = action_output_expression_list
			case 17: // opt$lst$action_head = lst$action_head
			case 30: // opt$port_name_colon = port_name_colon
			case 32: // opt$token_name_list = token_name_list
			case 34: // opt$repeat = repeat
			case 36: // opt$channel_selector = channel_selector
			case 43: // opt$ATSTAR = ATSTAR
			case 50: // opt$expression_list = expression_list
			case 54: // opt$import_list = import_list
			case 56: // opt$type_parameter_block = type_parameter_block
			case 58: // opt$actor_parameter_list = actor_parameter_list
			case 60: // opt$time = time
			case 64: // opt$lst$actor_body = lst$actor_body
			case 79: // opt$FSM = FSM
			case 83: // opt$lst$fsm_state_transitions = lst$fsm_state_transitions
			case 89: // opt$lst$fsm_state_target = lst$fsm_state_target
			case 105: // end_action = END
			case 106: // end_action = ENDACTION
			case 107: // end_actor = END
			case 108: // end_actor = ENDACTOR
			case 109: // end_invariant = END
			case 110: // end_invariant = ENDINVARIANT
			case 111: // end_schedule = END
			case 112: // end_schedule = ENDSCHEDULE
			case 116: // opt$actor_parameter_init_expression = actor_parameter_init_expression
			case 155: // opt$type_parameter_list = type_parameter_list
			case 163: // opt$type_list = type_list
			case 166: // opt$type_attribute_list = type_attribute_list
			case 176: // opt$formal_parameter_list = formal_parameter_list
			case 178: // opt$decl_block = decl_block
			case 218: // opt$map_list = map_list
			case 274: // for_foreach = FOREACH.FOREACH
			case 275: // for_foreach = FOR.FOR
			case 276: // do_begin = BEGIN.BEGIN
			case 277: // do_begin = DO.DO
			case 278: // end_choose = END.END
			case 279: // end_choose = ENDCHOOSE.ENDCHOOSE
			case 280: // end_foreach = END.END
			case 281: // end_foreach = ENDFOREACH.ENDFOREACH
			case 282: // end_if = END.END
			case 283: // end_if = ENDIF.ENDIF
			case 284: // end_lambda = END.END
			case 285: // end_lambda = ENDLAMBDA.ENDLAMBDA
			case 286: // end_let = END.END
			case 287: // end_let = ENDLET.ENDLET
			case 288: // end_proc = END.END
			case 289: // end_proc = ENDPROC.ENDPROC
			case 290: // end_while = END.END
			case 291: // end_while = ENDWHILE.ENDWHILE
			{
				return _symbols[offset + 1];
			}
			case 251: // statement = choose_generator_list.l decl_block_opt.do_v DO statement_list_opt.do_s end_choose
			{
				return _symbols[offset + 4];
			}
			case 252: // statement = choose_generator_list.l decl_block_opt.do_v DO statement_list_opt.do_s ELSE statement_list_opt.else_s end_choose
			{
				return _symbols[offset + 6];
			}
			case 253: // statement = choose_generator_list.l decl_block_opt.do_v DO statement_list_opt.do_s ELSE decl_block_opt.else_v DO statement_list_opt.else_s end_choose
			{
				return _symbols[offset + 8];
			}
			default:
				throw new IllegalArgumentException("unknown production #" + rule_num);
		}
	}
}
