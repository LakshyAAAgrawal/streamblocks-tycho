%header {: 
/* 
 *  @author Per Andersson<Per.Andersson@cs.lth.se>, Lund University
 *  To parse a CAL file use one of the methods:
 *  - public net.opendf.ir.cal.Actor parse(String path, String fileName)
 *  - public net.opendf.ir.cal.Actor parse(File file)
 *
 *  After parsing check for errors in the attribute parseProblems.
 *
 *  The parser is created using jflex and beaver.
 */
 :} ;
%package "net.opendf.parser.lth";
%import "net.opendf.ir.*";
%import "net.opendf.ir.util.ImmutableList";
%import "net.opendf.ir.util.ImmutableEntry";
%import "net.opendf.ir.common.*";
%import "net.opendf.ir.common.decl.*";
%import "net.opendf.ir.common.expr.*";
%import "net.opendf.ir.common.lvalue.*";
%import "net.opendf.ir.common.stmt.*";
%import "net.opendf.ir.cal.*";
%import "net.opendf.ir.cal.Action";
%import "java.io.File";
%import "java.io.PrintStream";
%import "java.util.TreeSet";
%import "java.util.Map";
%import "java.util.AbstractMap";
%import "java.util.Arrays";
%import "java.util.Collection";
%import "net.opendf.ir.IRNode";
%import "net.opendf.ir.IRNode.Identifier";
%import "net.opendf.parser.SourceCodeOracle";
%import "net.opendf.parser.SourceCodeOracle.SourceCodePosition";
%import "net.opendf.errorhandling.BasicErrorModule";
%import "net.opendf.errorhandling.ErrorModule";
%embed {:
/*******************************************************
 *  Code for error handling in the parser class.
 *******************************************************/
  // all errors encountered during parsing is stored in the array parseProblems. This includes lexical, syntactical and semantic error (multiple initialization actors et.c.)
  BasicErrorModule em;

  public ErrorModule getErrorModule(){ return em; }

  private void warning(String msg, Symbol startS, Symbol endS){
    int start = startS.getStart();
    int end = endS.getEnd();
    em.warning(msg + " between " + Symbol.getLine(start) + ":" + Symbol.getColumn(start) + " and " + Symbol.getLine(end) + ":" + Symbol.getColumn(end) + " in " + file.getName(), null);
  }
  
  String posToString(Symbol s){
	  int start = s.getStart();
	  int end = s.getEnd();
	  return Symbol.getLine(start) + ":" + Symbol.getColumn(start) + ", " + Symbol.getLine(end) + ":" + Symbol.getColumn(end) + " in " + file.getName();
  }

  private void warnPortIndex(Expression[] index){
    if(index != null && index.length != 0){
      em.warning("port index is ignored", index[0]);
    }
  }

  // parser plug-in methods that are called when the parser encounters a syntactical problem
  class Events extends Parser.Events {
    public void scannerError(Scanner.Exception e) {
      em.error(e.getMessage(), null);
    }
    public void syntaxError(Symbol token) {
      // This method is always called when a problem is encountered, even if it is repaired.
      // beaver.Parser$Exception is thrown if recovery fails.
      String value = token.value != null ? token.value.toString() : Terminals.NAMES[token.getId()];
      em.error("unexpected token \"" + value + "\" at " + Symbol.getLine(token.getStart()) + ", " + Symbol.getColumn(token.getStart()), null);
    }
    public void unexpectedTokenRemoved(Symbol token) {
      String value = token.value != null ? token.value.toString() : Terminals.NAMES[token.getId()];
      em.warning("parser recovered after removing token \"" + value + "\" at " + Symbol.getLine(token.getStart()) + ", " + Symbol.getColumn(token.getStart()), null);
    }
    public void missingTokenInserted(Symbol token) {
      String value = token.value != null ? token.value.toString() : Terminals.NAMES[token.getId()];
      em.warning("parser recovered after inserting token \"" + value + "\" at " + Symbol.getLine(token.getStart()) + ", " + Symbol.getColumn(token.getStart()), null);
    }
    public void misspelledTokenReplaced(Symbol token) {
      String value = token.value != null ? token.value.toString() : Terminals.NAMES[token.getId()];
      em.warning("parser recovered after replacing token \"" + value + "\" at " + Symbol.getLine(token.getStart()) + ", " + Symbol.getColumn(token.getStart()), null);
    }
    public void errorPhraseRemoved(Symbol token) {
      String value = token.value != null ? token.value.toString() : Terminals.NAMES[token.getId()];
      em.warning("parser recovered after removing token \"" + value + "\" at " + Symbol.getLine(token.getStart()) + ", " + Symbol.getColumn(token.getStart()), null);
    }
  }

  {
    // initialization, before the constructor
    report = new Events(); // Use error handler in parser
  }

/********************************************************
 * Store the source code position of the symbols.
 * The following IR-nodes have source file information:
 * Registered by NLParser.beaver:
 * - EntityIfExpr
 * - EntityInstanceExpr
 * - EntityListExpr
 * - NetworkDefinition
 * - PortReference
 * - StructureConnectionStmt
 * - StructureForeachStmt
 * - StructureIfStmt
 * - ToolValueAttribute
 * - ToolTypeAttribute
 *
 * Registered by CommonParser.beaver
 * - ExprLiteral
 * - Field
 * - Variable
 * - ExprVariable
 *
 * The following IRNodes do not have source code info:
 * - GeneratorFilter
 * - Import
 * - LValue
 ********************************************************/

  private File file;
  private Map<Identifier, SourceCodePosition> srcLocations;
  public Symbol register(Symbol start, Symbol end, IRNode node){
    if(srcLocations != null){
      srcLocations.put(node.getIdentifier(), SourceCodePosition.newIncluding(start, end, file));
    }
    return new Symbol(node);
  }
  public Symbol register(IRNode start, Symbol end, IRNode node){
    if(srcLocations != null){
      srcLocations.put(node.getIdentifier(), SourceCodePosition.newIncluding(srcLocations.get(start.getIdentifier()), end));
    }
    return new Symbol(node);
  }
  public Symbol register(Symbol start, IRNode end, IRNode node){
    if(srcLocations != null){
      srcLocations.put(node.getIdentifier(), SourceCodePosition.newIncluding(start, srcLocations.get(end.getIdentifier())));
    }
    return new Symbol(node);
  }
  public Symbol register(IRNode start, IRNode end, IRNode node){
    if(srcLocations != null){
      srcLocations.put(node.getIdentifier(), SourceCodePosition.newIncluding(srcLocations.get(start.getIdentifier()), srcLocations.get(end.getIdentifier())));
    }
    return new Symbol(node);
  }
/*******************************************************
 *  Help routine that parses a file, given its name.
 *  A compilation unit is always returned, containing all parseProblems encountered during parsing.
 *  If a Parser.exception is thrown a CompilationUnit with an empty AST is returned.
 *******************************************************/
  private Actor makeEmptyActor(File file){
    String name;
    int lastPeriodPos = file.getName().lastIndexOf('.');
    if(lastPeriodPos >=0){
      name = file.getName().substring(0, lastPeriodPos);
    } else {
      name = file.getName();
    }
    return new Actor(name, null, null, null, null, null, null, null, null, null, null, null);   
  }
  
  public net.opendf.ir.cal.Actor parse(String path, String fileName, Map<Identifier, SourceCodePosition> srcLocations, SourceCodeOracle scOracle){
    return parse(new java.io.File(path + "/" + fileName), srcLocations, scOracle);
  }
  public net.opendf.ir.cal.Actor parse(File file, Map<Identifier, SourceCodePosition> srcLocations, SourceCodeOracle scOracle){
     this.file = file;
     this.srcLocations = srcLocations;
     em = new BasicErrorModule(scOracle);
     Actor actor;
     java.io.FileReader fr = null;
     try {
       try{
         fr = new java.io.FileReader(file);
  	     CalScanner scanner = new CalScanner(new java.io.BufferedReader(fr));
         actor = (Actor)parse(scanner);
       } catch(CalParser.Exception e) {
         // build empty compilation unit for failed error recovery
         // The problem is added to parseProblems[] by the syntaxError() method added to the parser above.
         actor = makeEmptyActor(file);
       } finally {
         if(fr != null){
           fr.close();
         }
       }
     } catch (java.io.FileNotFoundException e){
       em.error("file not found: " + e.getMessage(), null);
       actor = makeEmptyActor(file);
     } catch (java.io.IOException e){
       em.error("error reading file: " + e.getMessage(), null);
       actor = makeEmptyActor(file);
     }
     return actor;
   }

  private enum ActionPartKind{ GUARD, DECL_LIST, DELAY; }
  private enum ActorPartKind{ DECL_VAR, INIT_ACTION, ACTION, FSM_SCHEDULE, PRIORITY, INVARIANT_LIST; }

  /****************************************************************************
   * Needed by CommonParser.beaver
   * Repeated in both NlParser.beaver and CalParser.beaver
   ***************************************************************************/
  private Symbol makeGeneratorFilter(Symbol start, TypeExpr t, ImmutableList<Symbol>varList, Expression e, ImmutableList<Expression> filterList, ImmutableList l){
    GeneratorFilter gen = makeGeneratorFilter2(t, varList, e, filterList);
    Expression end = e;
    if(filterList != null && !filterList.isEmpty()){
   	 end = filterList.get(filterList.size()-1);
    }
    register(start, end, gen);
    ImmutableList.Builder newList = ImmutableList.builder().add(gen);
    if(l != null){
   	 newList.addAll(l);
    }
    return new Symbol(newList);
  }
  private GeneratorFilter makeGeneratorFilter2(TypeExpr type, ImmutableList<Symbol> varList, Expression e, ImmutableList<Expression> filterList){
    ImmutableList.Builder<LocalVarDecl> vars = ImmutableList.builder();
    for(Symbol var : varList){
      LocalVarDecl decl = new LocalVarDecl(type, (String)var.value);
      register(var, var, decl);
      vars.add(decl);
    }
    return new GeneratorFilter(vars.build(), e, filterList);
  }
  class ParenthesSymbol extends Symbol{ // used by the parser to wrap subexpressions that are enclosed by parentheses, i.e. do not add them to a ExprBinaryOp sequence.
    ParenthesSymbol(Symbol s){
      super(s.getId(), s.getStart(), s.getEnd(), s.value);
    }
  }
  
  private LValue expressionToLValue(Expression expression) {
    if (expression instanceof ExprVariable) {
      Variable var = ((ExprVariable) expression).getVariable();
      return new LValueVariable(expression, var);
    } else if (expression instanceof ExprIndexer) {
      ExprIndexer exprIndexer = (ExprIndexer) expression;
      LValue structure = expressionToLValue(exprIndexer.getStructure());
      if (structure == null) return null;
      LValue result = new LValueIndexer(structure, exprIndexer.getIndex());
      register(structure, exprIndexer, result);
      return result;
    } else if (expression instanceof ExprField) {
      ExprField exprField = (ExprField) expression;
      LValue structure = expressionToLValue(exprField.getStructure());
      if (structure == null) return null;
      LValue result = new LValueField(structure, exprField.getField());
      register(structure, exprField, result);
      return result;
    } else {
      return null;
    }
  }
:};

// common terminals
%terminals ARROW;
%terminals BAR;
%terminals BEGIN;
%terminals CHARACTER_LITERAL;
%terminals CHOOSE;
%terminals COMMA;
%terminals COLON;
%terminals COLONEQ;
%terminals CONST;
%terminals DO;
%terminals DOT;
%terminals DOUBLECOLON;
%terminals DOUBLE_LITERAL;
%terminals EDGE;
%terminals ELSE;
%terminals END;
%terminals ENDCHOOSE;
%terminals ENDFOREACH;
%terminals ENDIF;
%terminals ENDLAMBDA;
%terminals ENDLET;
%terminals ENDPROC;
%terminals ENDWHILE;
%terminals EQ;
%terminals FALSE_LITERAL;
%terminals FLOATING_POINT_LITERAL;
%terminals FOR;
%terminals FOREACH;
%terminals FUNCTION;
%terminals GT;
%terminals IDENTIFIER;
%terminals IF;
%terminals IN;
%terminals INTEGER_LITERAL;
%terminals LAMBDA;
%terminals LBRACE;
%terminals LBRACK;
%terminals LONG_LITERAL;
%terminals LPAREN;
%terminals LET;
%terminals LT;
%terminals MAP;
%terminals MULT;
%terminals MULTI;
%terminals MUTABLE;
%terminals NULL_LITERAL;
%terminals OLD;
%terminals OPERATOR;
%terminals PROC;
%terminals PROCEDURE;
%terminals RBRACE;
%terminals RBRACK;
%terminals RPAREN;
%terminals SEMICOLON;
%terminals STRING_LITERAL;
%terminals THEN;
%terminals TRUE_LITERAL;
%terminals VAR;
%terminals WHILE;

// Cal specific terminals
%terminals ACTION;
%terminals ACTOR;
%terminals ALL;
%terminals ANY;
%terminals AT;
%terminals ATSTAR;
%terminals DELAY;
%terminals ENDACTION;
%terminals ENDACTOR;
%terminals ENDINVARIANT;
%terminals ENDSCHEDULE;
%terminals FSM;
%terminals GUARD;
%terminals IMPORT;
%terminals INITIALIZE;
%terminals INVARIANT;
%terminals PORTCONN;
%terminals PRIORITY;
%terminals REPEAT;
%terminals REGEXP;
%terminals SCHEDULE;
%terminals TIME;

//--- rules from CommonParser.beaver 
%typeof actor_parameter_list = "ImmutableList.Builder";
%typeof actor_parameter = "ParDeclValue";
%typeof actor_parameter_init_expression = "Expression";
%typeof qual_id = "ArrayList";
%typeof variable = "Variable";
%typeof field = "Field";
%typeof decl_list = "ImmutableList.Builder";
%typeof decl_block = "ImmutableList";
%typeof decl_block_opt = "ImmutableList";
%typeof decl = "LocalVarDecl";
%typeof var_decl = "LocalVarDecl";
%typeof var_name_type = "LocalVarDecl";
%typeof fun_decl = "LocalVarDecl";
%typeof proc_decl = "LocalVarDecl";
%typeof port_decl = "PortDecl";
%typeof port_decl_list = "ImmutableList.Builder";
%typeof port_decl_list_opt = "ImmutableList";
%typeof type_bound = "TypeExpr";
%typeof type_bound_opt = "TypeExpr";
%typeof type_parameter = "ParDeclType";
%typeof type_parameter_block = "ImmutableList";
%typeof type_parameter_list = "ImmutableList.Builder";
%typeof type_list = "ImmutableList.Builder";
%typeof type = "TypeExpr";
%typeof type_attribute = "Map.Entry";
%typeof type_attribute_list = "ArrayList";
%typeof edge_type = "TypeExpr";
%typeof procedure_expr_body = "ExprProc";
%typeof stmt_block_opt = "ImmutableList";
%typeof lambda_expr_body = "ExprLambda";
%typeof map_list = "ImmutableList.Builder";
%typeof map_entry = "Map.Entry";
//%typeof tail = "Expression";
%typeof expression_list = "ImmutableList.Builder";
%typeof expression_list_opt = "ImmutableList";
%typeof method_invocation = "ExprApplication";
%typeof literal = "ExprLiteral";
%typeof primary = "Expression";
%typeof simple_expression = "Expression";
%typeof unary_expression = "Expression";
%typeof indexing_expression = "Expression";
%typeof indexer_start = "Expression";
%typeof expression = "Expression";
%typeof operator = "String";
%typeof formal_parameter = "ParDeclValue";
%typeof formal_parameter_list = "ImmutableList.Builder";
%typeof statement = "Statement";
%typeof choose_generator_list = "ImmutableList.Builder";
%typeof for_generator_list = "ImmutableList.Builder";
%typeof generator_variable_list = "ImmutableList.Builder";  //<Symbol>  (type information is not available, so I can not build the DeclVar object)
%typeof statement_list = "ImmutableList.Builder";
%typeof statement_list_opt = "ImmutableList";

//--- CAL specific
%typeof goal = "Actor";
%typeof action_decl = "Action";
%typeof action_head = "Map.Entry";
%typeof action_in_pattern = "InputPattern";
%typeof action_in_pattern_list = "ImmutableList.Builder";
%typeof action_output_expression = "OutputExpression";
%typeof action_output_expression_list = "ImmutableList.Builder";
%typeof action_statement_body = "ImmutableList";
%typeof action_tag = "QID";
%typeof action_tag_list = "ImmutableList.Builder";
%typeof actor_body = "Map.Entry";
%typeof actor_decl = "Actor";
%typeof channel_selector = "String";
%typeof init_action_decl = "Action";
%typeof fsm_state_transitions = "ImmutableList.Builder";
%typeof fsm_state_target = "Transition";
%typeof import_group = "ArrayList";
%typeof import_list = "ArrayList";
%typeof import_part = "ArrayList";
%typeof import_single = "ArrayList";
%typeof invariant = "ImmutableList";
%typeof port_name_colon = "Port";
%typeof pri_inequality = "ImmutableList.Builder";        //<QID>
%typeof pri_inequality_list = "ImmutableList";   //<QID>
//%typeof regexpr = "AbstractIRNode";
//%typeof regexpr_simple = "AbstractIRNode";
//%typeof regexpr_kleene = "AbstractIRNode";
%typeof repeat = "Expression";
%typeof schedule = "ScheduleFSM";
%typeof time = "TypeExpr";
%typeof token_name_list = "ImmutableList.Builder";

%goal goal;
goal =
    actor_decl.actor_decl SEMICOLON? {: return _symbol_actor_decl;:}
  ;
//=== import ==================================================================
import_list =
    import_part.i {: ArrayList l = new ArrayList(); l.add(i); return new Symbol(l);:}
  | import_list.l import_part.i {: l.add(i); return _symbol_l;:}
  ;
import_part =
    import_single.i {: return _symbol_i;:}
  | import_group.i {: return _symbol_i;:}
  ;
import_single =
//TODO return
    IMPORT qual_id.qual_id SEMICOLON {: return _symbol_qual_id; :}
  | IMPORT qual_id.qual_id EQ IDENTIFIER.alias SEMICOLON {: return _symbol_qual_id; :}
  ;
import_group =
//TODO return
    IMPORT ALL qual_id.qual_id SEMICOLON {: return _symbol_qual_id; :}
  ;
//=== Action ==================================================================
action_decl =
  action_tag.tag? ACTION.start action_in_pattern_list.in_pattern_list PORTCONN action_output_expression_list.out_expr_list?
  action_head.head*  // guard, variable declaration, or delay
  action_statement_body.body
  end_action.end
  SEMICOLON?
  /**
   * When the the content of an action is parsed, the Action object is not jet created. (the tree is build bottom up)
   * To allow multiple elements in any order (guard, declaration, delay) the parser first collect these in a list, using action_head.
   * When the Action object is created this list is traversed and each element is added to the right attribute
   **/
        {:
           // split the action head to it's parts
           ImmutableList.Builder<Expression> guardList = ImmutableList.builder();
           Expression delay = null;
           ImmutableList.Builder<LocalVarDecl> declVarList = ImmutableList.builder();
           for(Map.Entry part : head){
             switch((ActionPartKind)part.getKey()){
               case GUARD:
                 guardList.addAll((Iterable)part.getValue());
                 break;
               case DECL_LIST:
                 declVarList.addAll((Iterable)part.getValue());
                 break;
               case DELAY:
                 if(delay != null){ em.error("multiple delays is not allowed in action.", (Expression)part.getValue()); }
                 delay = (Expression)part.getValue();
                 break;
             }
           }
            Action a = new Action(-1,              // id
                                  tag,             // tag
                                  in_pattern_list.build(), //inputPatterns
                                  out_expr_list == null ? null : out_expr_list.build(),   //outputExpressions
                                  null,            // typeDecls
                                  declVarList.build(),     // varDecls
                                  guardList.build(),       // guards 
                                  body,            // body
                                  delay,           // delay
                                  null,            // preconditions  NOTE, can not be expressed in CAL
                                  null);           // postconditions NOTE, can not be expressed in CAL
            return register(start, end, a);
        :}

  ;
init_action_decl =
  action_tag.tag? INITIALIZE.start PORTCONN action_output_expression_list.out_expr_list?
  action_head.head*  // guard, variable declaration, or delay
  action_statement_body.body
  end_action.end
  SEMICOLON?
        {: 
           // split the action head to it's parts
           ImmutableList.Builder<Expression> guardList = ImmutableList.builder();
           Expression delay = null;
           ImmutableList.Builder<LocalVarDecl> declVarList = ImmutableList.builder();
           for(Map.Entry part : head){
             switch((ActionPartKind)part.getKey()){
               case GUARD:
                 guardList.addAll((ArrayList)part.getValue());
                 break;
               case DECL_LIST:
                 declVarList.addAll((ArrayList<LocalVarDecl>)part.getValue());
                 break;
               case DELAY:
                 if(delay != null){ em.error("multiple delays is not allowed in action.", (Expression)part.getValue()); }
                 delay = (Expression)part.getValue();
                 break;
             }
           }
            Action a = new Action(-1,                        // id
                                  tag,                       // tag
                                  null,       //inputPatterns
                                  out_expr_list==null ? null : out_expr_list.build(),  //outputExpressions
                                  null,                                              // typeDecls
                                  declVarList.build(),         // varDecls
                                  guardList.build(),          // guards 
                                  body,        // body
                                  delay,                      // delay
                                  null,         // preconditions  NOTE, can not be expressed in CAL
                                  null);        // postconditions NOTE, can not be expressed in CAL
            return register(start, end, a);
        :}
  ;
action_tag =
    qual_id.n COLON.end           {: return new Symbol(QID.of((String[])n.toArray(new String[n.size()]))); :}
  ;
action_head =
    GUARD expression_list.l       {: return new Symbol(new AbstractMap.SimpleEntry(ActionPartKind.GUARD, l.build())); :}
  | VAR decl_list.d               {: return new Symbol(new AbstractMap.SimpleEntry(ActionPartKind.DECL_LIST, d.build())); :}
  | DELAY.s expression.e          {: register(s, e, e); return new Symbol(new AbstractMap.SimpleEntry(ActionPartKind.DELAY, e)); :}
  ;
action_statement_body =
                            {: return new Symbol(ImmutableList.empty()); :}
  | DO statement_list_opt.s {: return new Symbol(s); :}
  ;
action_in_pattern_list =
                                                       {: return new Symbol(ImmutableList.builder()); :}
  | action_in_pattern.p                                {: return new Symbol(ImmutableList.builder().add(p)); :}
  | action_in_pattern_list.l COMMA action_in_pattern.p {: l.add(p); return _symbol_l;:}
  ;
action_in_pattern =
//TODO channels are ignored
  port_name_colon.actor_port_name? LBRACK.start token_name_list.tokens? RBRACK.end repeat.r? channel_selector.c? 
     {: Symbol s = actor_port_name == null ? start : _symbol_actor_port_name;
        Symbol e = r == null ? end : _symbol_r;  // FIXME, ignores channel selector
        return register(s, e, new InputPattern(actor_port_name, tokens==null ? null : tokens.build(), r)); :}
  ;
token_name_list =
//TODO, the position of the names are not saved
    IDENTIFIER.ID                           {: LocalVarDecl decl = new LocalVarDecl(null, (String) ID.value);
                                               register(ID, ID, decl);
                                               return new Symbol(ImmutableList.builder().add(decl)); :}
  | token_name_list.l COMMA IDENTIFIER.ID   {: Decl decl = new LocalVarDecl(null, (String) ID.value);
                                               register(ID, ID, decl);
                                               l.add(decl); return _symbol_l; :}
  ;
channel_selector =
    AT.a expression.e        {: em.error("channel selector is not supported, at found at " + posToString(a), null);
                                return _symbol_e; :} //TODO new SingleChannel(e); :}
  | ATSTAR.a expression.e    {: em.error("channel selector is not supported, at* found at " + posToString(a), null);
                                return _symbol_e; :} //TODO new AtStarChannel(e); :}
  | ATSTAR? ANY.a            {: em.error("channel selector is not supported, any found at " + posToString(a), null);
                                return a; :} //TODO new AnyChannel(); :}
  | ATSTAR? ALL.a            {: em.error("channel selector is not supported, all found at " + posToString(a), null);
                                return a; :} //TODO new AllChannels(); :}
  ;
repeat =
    REPEAT expression.e {: return _symbol_e; :}
  ;
action_output_expression_list =
    action_output_expression.e                                       {: return new Symbol(ImmutableList.builder().add(e)); :}
  | action_output_expression_list.l COMMA action_output_expression.e {: l.add(e); return _symbol_l; :}
  ;
action_output_expression =
//TODO channels are ignored
  port_name_colon.actor_port_name? LBRACK.start expression_list.values? RBRACK.end repeat.r? channel_selector.c? 
      {: OutputExpression out = new OutputExpression(actor_port_name, values == null ? null : values.build(), r);
         if(actor_port_name == null){
           if(r == null){
             return register(start, end, out);
           } else {
             return register(start, r, out);
           }
         } else {
           if(r == null){
             return register(actor_port_name, end, out);
           } else {
             return register(actor_port_name, r, out);
           }
         }
       :}
  ;
port_name_colon =
    IDENTIFIER.id COLON {: return register(id, id, new Port((String)id.value));:}
  ;
//=== Actor ===================================================================
actor_decl =
  import_list.imports? 
  ACTOR.start IDENTIFIER.name
  type_parameter_block.typePars?
  LPAREN actor_parameter_list.valuePars? RPAREN 
  port_decl_list_opt.in PORTCONN port_decl_list_opt.out 
//TODO, time is ignored
  time.t?
  COLON
  actor_body.body*
  end_actor.end
  /**
   * When the the content of an actor is parsed (actor_body_list), the Actor object is not jet created. (the tree is build bottom up)
   * To allow multiple elements in any order (actions, schedule...) the parser first collect these in a list, using actor_body_list.
   * When the Actor object is created this list is traversed and each element is added to the right attribute (Actor.VariableList, Actor.ActionList, ...)
   **/
  {:
    if(t != null){ 
      em.warning("time is not supported", t); 
    }
    ImmutableList.Builder varDecls = ImmutableList.builder();
    ImmutableList.Builder initializers = ImmutableList.builder();
    ImmutableList.Builder actions = ImmutableList.builder();
    ScheduleFSM scheduleFSM = null;
    ImmutableList.Builder priorities = ImmutableList.builder();
    ImmutableList.Builder invariants = ImmutableList.builder();
    for(Map.Entry part : body){
      switch((ActorPartKind)part.getKey()){
        case DECL_VAR:
          varDecls.add(part.getValue());
          break;
        case INIT_ACTION:
          initializers.add(part.getValue());
          break;
        case ACTION:
          actions.add(part.getValue());
          break;
        case FSM_SCHEDULE:
          scheduleFSM = (ScheduleFSM)part.getValue();
          break;
        case PRIORITY:
          priorities.addAll((Collection)part.getValue());
          break;
        case INVARIANT_LIST:
          invariants.addAll((Collection)part.getValue());
          break;
      }
    }
    Actor a = new Actor((String)name.value,
                         typePars,     // typePars,
                         valuePars == null ? null : valuePars.build(), // valuePars,
                         null,      // typeDecls, NOTE, can not be expressed in CAL
                         varDecls.build(),             // varDecls
                         in,
                         out,
                         initializers.build(),
                         actions.build(),
                         scheduleFSM,
                         priorities.build(),
                         invariants.build()
                        );
    return register(start, end, a);
  :}
  ;

time =
    TIME.start type.t {: return register(start, _symbol_t, t); :}
  ;
actor_body =
    action_decl.a                               {: return new Symbol(new AbstractMap.SimpleEntry(ActorPartKind.ACTION, a)); :}
  | init_action_decl.a                          {: return new Symbol(new AbstractMap.SimpleEntry(ActorPartKind.INIT_ACTION, a)); :}
  | var_decl.d SEMICOLON                        {: return new Symbol(new AbstractMap.SimpleEntry(ActorPartKind.DECL_VAR, d)); :}
  | fun_decl.d                                  {: return new Symbol(new AbstractMap.SimpleEntry(ActorPartKind.DECL_VAR, d)); :}
  | proc_decl.d                                 {: return new Symbol(new AbstractMap.SimpleEntry(ActorPartKind.DECL_VAR, d)); :}
  | PRIORITY pri_inequality_list.l+ END         {: return new Symbol(new AbstractMap.SimpleEntry(ActorPartKind.PRIORITY, _list_l)); :}
  | schedule.s                                  {: return new Symbol(new AbstractMap.SimpleEntry(ActorPartKind.FSM_SCHEDULE, s)); :}
  | invariant.i                                 {: return new Symbol(new AbstractMap.SimpleEntry(ActorPartKind.INVARIANT_LIST, i)); :}
  ;
invariant =
    INVARIANT expression_list.l end_invariant   {: return new Symbol(l.build()); :}
  ;
//--- Schedule ----------------------------------------------------------------
schedule =
    SCHEDULE.start FSM? IDENTIFIER.ID COLON fsm_state_transitions.trans* end_schedule.end 
      {:  ImmutableList.Builder tl = trans.length>0 ? trans[0] : new ImmutableList.Builder();
          for(int i=1; i<trans.length; i++){
            tl.addAll(trans[i].build());
          }
          return register(start, end, new ScheduleFSM(tl.build(), (String)ID.value)); :}
  | SCHEDULE.start REGEXP regexpr.r end_schedule.end
    {: IRNode pos = new ScheduleFSM(ImmutableList.<Transition>empty(), "$regexpr"); // dummy node needed for error reporting
       Symbol result = register(start, end, pos);
       em.error("Regular expression schedules is not supported", pos); 
       return result; :}
  ;
fsm_state_transitions =
    IDENTIFIER.Src_state LPAREN action_tag_list.tags RPAREN EDGE IDENTIFIER.Dst_state fsm_state_target.more* SEMICOLON.end
       {: ImmutableList.Builder result = ImmutableList.builder();
          String startState = (String)Src_state.value;
          Transition trans = new Transition(startState,
                                    (String)Dst_state.value,
                                    tags.build());
          register(Src_state, end, trans);
          result.add(trans);
          for(Transition t : more){
            trans = new Transition(startState, t.getDestinationState(), t.getActionTags());
            register(Src_state, end, trans);
            result.add(trans);
          }
          return new Symbol(result); :}
  ;
fsm_state_target =
  BAR LPAREN action_tag_list.tags RPAREN EDGE IDENTIFIER.Dst_state
       {: return new Symbol(new Transition(null,  // the start state is unknown. This is filled in later.
                                           (String)Dst_state.value,
                                           tags.build())); :}
  ;
action_tag_list =
    qual_id.id                         {: QID qid = QID.of((String[])id.toArray(new String[id.size()]));
                                          return new Symbol(ImmutableList.builder().add(qid)); :}
  | action_tag_list.l COMMA qual_id.id {: QID qid = QID.of((String[])id.toArray(new String[id.size()]));
                                          l.add(qid);
                                          return _symbol_l; :}
  ;
//TODO, reg expr schedules
regexpr =
    regexpr_kleene.r                 {: return r; :}   // error is reported in schedule. error("regexp schedules is not supported", r, r);
  | regexpr.r1 regexpr_kleene.r2     {: return r1; :}  // error("regexp schedules is not supported", r1, r2); 
  | regexpr.r1 BAR regexpr_kleene.r2 {: return r1; :}  // error("regexp schedules is not supported", r1, r2); 
  ;
regexpr_kleene =
    regexpr_simple.r        {: return r; :}
  | regexpr_simple.r MULT   {: return r; :}
  ;
regexpr_simple =
    qual_id.n               {: return _symbol_n; :}
  | LPAREN regexpr.r RPAREN {: return r; :}
  | LBRACK regexpr.r RBRACK {: return r; :}
  ;
//--- priority ----------------------------------------------------------------
pri_inequality_list =
    pri_inequality.p SEMICOLON         {: return new Symbol(p.build()); :}
  ;
pri_inequality =
    qual_id.high GT qual_id.low        {: QID lowQID = QID.of((String[])low.toArray(new String[low.size()]));
                                          QID highQID = QID.of((String[])high.toArray(new String[high.size()]));
                                          return new Symbol(ImmutableList.builder().add(highQID).add(lowQID)); :}
  | pri_inequality.l GT qual_id.n      {: QID qid = QID.of((String[])n.toArray(new String[n.size()]));
                                          l.add(qid);
                                          return _symbol_l; :}
  ;
//--- end ---------------------------------------------------------------------
end_action =
    END 
  | ENDACTION
  ;
end_actor =
    END 
  | ENDACTOR
  ;
end_invariant =
    END 
  | ENDINVARIANT
  ;
end_schedule =
    END 
  | ENDSCHEDULE
  ;

