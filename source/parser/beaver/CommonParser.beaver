/******************************************************************************
 *  Common for both Actor and Networks
 *  From file source/parser/beaver/CommonParser.beaver
 *****************************************************************************/
//--- actor parameter ---
actor_parameter_list =
    actor_parameter.p                              {: return new Symbol(ImmutableList.builder().add(p)); :}
  | actor_parameter_list.l COMMA actor_parameter.p {: l.add(p); return _symbol_l; :}
  ;
actor_parameter =
//TODO, init expression is ignored
           IDENTIFIER.id actor_parameter_init_expression.e? {: ParDeclValue decl = new ParDeclValue((String)id.value, null);
                                                               Symbol result = register(id, id, decl);
                                                               if(e != null){ register(id, e, decl); em.warning("default value for parameter " + (String)id.value + " is ignored.", decl);}; 
                                                               return result; :}
  | type.t IDENTIFIER.id actor_parameter_init_expression.e? {: ParDecl decl = new ParDeclValue((String)id.value, t);
                                                               Symbol result = register(t, id, decl);
                                                               if(e != null){ register(t, e, decl); em.warning("default value for parameter " + (String)id.value + " is ignored.", decl);}; 
                                                               return result; :}
  ;
actor_parameter_init_expression =
    EQ expression.e {: return _symbol_e; :}
  ;

//--- Qualified id
// the Symbol returned have correct start and end values for the QID.
qual_id =
    IDENTIFIER.id                     {: ArrayList l = new ArrayList(); l.add(id.value); return new Symbol(id.getId(), id.getStart(), id.getEnd(), l); :}
  | IDENTIFIER.id DOT qual_id.l       {: l.add(0, id.value); return new Symbol(id.getId(), id.getStart(), _symbol_l.getEnd(), l); :}
  ;

variable = IDENTIFIER.id {: return register(id, id, Variable.variable((String) id.value)); :} ;

field = IDENTIFIER.id {: return register(id, id, new Field((String) id.value)); :} ;

//=== Declaration =============================================================
decl_list =
    decl.d                   {: return new Symbol(ImmutableList.builder().add(d)); :}
  | decl_list.l COMMA decl.d {: l.add(d); return _symbol_l; :}
  ;
decl_block =
    VAR decl_list.d          {: return new Symbol(d.build()); :}
  ;
decl_block_opt =
                             {: return new Symbol(ImmutableList.empty()); :}
  | VAR decl_list.d          {: return new Symbol(d.build()); :}
  ;
decl =
    var_decl.d  {: return _symbol_d; :}
  | fun_decl.d  {: return _symbol_d; :}
  | proc_decl.d {: return _symbol_d; :}
  ;
//used external
var_decl =
//TODO, mutable is ignored
    MUTABLE.m var_name_type.v                         {: em.warning("mutable is ignored for " + v.getName(), v); 
                                                         register(m, v, v);
                                                         return _symbol_v; :}
  | MUTABLE.m var_name_type.v EQ expression.init      {: em.warning("mutable is ignored for " + v.getName(), v);
                                                         return register(m, init, v.copy(v.getType(), v.getName(), init, false)); :}
  | MUTABLE.m var_name_type.v COLONEQ expression.init {: em.warning("mutable is ignored for " + v.getName(), v);
                                                         return register(m, init, v.copy(v.getType(), v.getName(), init, true)); :}
  | var_name_type.v                                   {: return _symbol_v; :}
  | var_name_type.v EQ expression.init                {: return register(v, init, v.copy(v.getType(), v.getName(), init, false)); :}
  | var_name_type.v COLONEQ expression.init           {: return register(v, init, v.copy(v.getType(), v.getName(), init, true)); :}
  ;
var_name_type =
    IDENTIFIER.id           {: return register(id, id, new DeclVar(null, (String)id.value, null, true)); :}
  | type.type IDENTIFIER.id {: return register(id, id, new DeclVar(type, (String)id.value, null, true)); :}
  ;
//used external
fun_decl =
    FUNCTION.start IDENTIFIER.id lambda_expr_body.lambda   {: register(start, lambda, lambda); return register(start, lambda, new DeclVar(null, (String)id.value, lambda, false)); :}
  ;
//used external
proc_decl =
    PROCEDURE.start IDENTIFIER.id procedure_expr_body.body {: register(start, body, body); return register(start, body, new DeclVar(null, (String)id.value, body, false)); :}
  ;
port_decl =
//TODO, the keyword multi is ignored
    IDENTIFIER.id                   {: return register(id, id, new PortDecl((String)id.value, null)); :}
  | type.type IDENTIFIER.id         {: return register(type, id, new PortDecl((String)id.value, type)); :}
  | MULTI.m IDENTIFIER.id           {: em.warning("multi is ignored for " + (String)id.value, null);
                                       return register(m, id, new PortDecl((String)id.value, null)); :}
  | MULTI.m type.type IDENTIFIER.id {: em.warning("multi is ignored for " + (String)id.value, null);
                                       return register(m, id, new PortDecl((String)id.value, type)); :}
  ;
port_decl_list_opt =
                     {: return new Symbol(null); :}
  | port_decl_list.l {: return new Symbol(l.build()); :}
  ;
port_decl_list =
    port_decl.port_decl                {: return new Symbol(ImmutableList.builder().add(port_decl)); :}
  | port_decl_list.l COMMA port_decl.d {: l.add(d); return _symbol_l; :}
  ;

//=== type ====================================================================
type_bound =
    LT type.type {: return _symbol_type; :}
  ;
type_bound_opt =
                 {: return new Symbol(null); :}
  | type_bound.n {: return _symbol_n; :}  // warning is issued in type_param
  ;
type_parameter =
//TODO, type bound is ignored
    IDENTIFIER.id type_bound_opt.type_bound {: ParDeclType decl = new ParDeclType((String)id.value);
                                               Symbol result;
                                               if(type_bound == null){
                                                 result = register(id, id, decl);
                                               } else {
                                                 em.warning("type bound is ignored", type_bound);
                                                 result = register(id, type_bound, decl);
                                               }
                                               return result; :}
  ;
type_parameter_block =
  LBRACK type_parameter_list.l? RBRACK {: return new Symbol(l == null ? null : l.build()); :}
  ;
type_parameter_list =
    type_parameter.tp                             {: return new Symbol(ImmutableList.builder().add(tp)); :}
  | type_parameter_list.l COMMA type_parameter.tp {: l.add(tp); return _symbol_l; :}
  ;
type_list =
    type.t                   {: return new Symbol(ImmutableList.builder().add(t)); :}
  | type_list.l COMMA type.t {: l.add(t); return _symbol_l; :}
  ;

type =
    IDENTIFIER.id         {: return register(id, id, new TypeExpr((String)id.value)); :}
  | IDENTIFIER.id LPAREN type_attribute_list.attributes? RPAREN.end
                          {: ImmutableList.Builder valueParameters = ImmutableList.builder();
                             ImmutableList.Builder typeParameters = ImmutableList.builder();
                             for(Map.Entry map : (ArrayList<Map.Entry>)attributes){
                               if(map.getValue() instanceof Expression){
                                 valueParameters.add(ImmutableEntry.of(map.getKey(), map.getValue()));
                               } else {
                                 typeParameters.add(ImmutableEntry.of(map.getKey(), map.getValue()));
                               }
                             }
                             return register(id, end, new TypeExpr((String)id.value, typeParameters.build(), valueParameters.build()));
                           :}
//TODO, types involving '->' can not be represented in the internal representation
  | LBRACK.l type_list.param? EDGE type.result_type RBRACK.e     {: warning("types involving -> is not supported", l, e); return new Symbol(null); :}
  | LBRACK.l type_list.param? EDGE RBRACK.e                      {: warning("types involving -> is not supported", l, e); return new Symbol(null); :}
  ;
type_attribute_list =
    type_attribute.t {: ArrayList l = new ArrayList(); l.add(t); return new Symbol(l); :}
  | type_attribute_list.l COMMA type_attribute.t {: l.add(t); return _symbol_l;:}
  ;
type_attribute =
    IDENTIFIER.id COLON type.type {: return new Symbol(new AbstractMap.SimpleEntry((String)id.value, type)); :}
  | IDENTIFIER.id EQ expression.e {: return new Symbol(new AbstractMap.SimpleEntry((String)id.value, e)); :}
  ;
edge_type =
    EDGE type.t {: return _symbol_t; :}
  ;

//=== Expression ==============================================================
procedure_expr_body =
    LPAREN.start formal_parameter_list.param? RPAREN decl_block.decl? stmt_block_opt.body end_proc.end
      {:  return register(start, end,
            new ExprProc(
              ImmutableList.<ParDeclType>empty(), 
              param==null ? ImmutableList.empty() : param.build(),
              new StmtBlock(null, decl, body)
            )
          ); :}
  ;
stmt_block_opt =
                                  {: return new Symbol(ImmutableList.empty()); :}
  | do_begin statement_list_opt.s {: return _symbol_s; :}
  ;
lambda_expr_body =
    LPAREN.s formal_parameter_list.param? RPAREN expression.body end_lambda.e
         {: return register(s, e, new ExprLambda(ImmutableList.<ParDeclType>empty(),
                                             param==null ? null : param.build(),
                                             body,
                                             null)); :}
  | LPAREN.s formal_parameter_list.param? RPAREN decl_block.decl? COLON expression.body end_lambda.e
         {: return register(s, e, new ExprLambda(ImmutableList.<ParDeclType>empty(),
                                             param==null ? null : param.build(),
                                             new ExprLet(null, decl, body),
                                             null)); :}
  | LPAREN.s formal_parameter_list.param? RPAREN edge_type.t decl_block.decl? COLON expression.body end_lambda.e
         {: return register(s, e, new ExprLambda(ImmutableList.<ParDeclType>empty(),
                                             param==null ? null : param.build(),
                                             new ExprLet(null, decl, body),
                                             t)); :}
  ;
map_list =
    map_entry.m                  {: return new Symbol(ImmutableList.builder().add(m)); :}
  | map_list.l COMMA map_entry.m {: l.add(m); return _symbol_l; :}
  ;
map_entry =
    expression.e1 ARROW expression.e2 {: return new Symbol(new ImmutableEntry(e1, e2)); :}
  ;
//tail =
//    BAR expression.e {: return _symbol_e; :}
//  ;
expression_list =
    expression.e                         {: return new Symbol(ImmutableList.builder().add(e)); :}
  | expression_list.l COMMA expression.e {: l.add(e); return _symbol_l; :}
  ;
expression_list_opt =
                      {: return new Symbol(ImmutableList.empty()); :}
  | expression_list.n {: return new Symbol(n.build()); :}
  ;
method_invocation =
    indexing_expression.function LPAREN expression_list_opt.args RPAREN.end {: return register(function, end, new ExprApplication(function, args)); :}
  ;
literal =
    INTEGER_LITERAL.txt        {: return register(txt, txt, new ExprLiteral(ExprLiteral.Kind.Integer, ((String)txt.value))); :}
  | LONG_LITERAL.txt           {: return register(txt, txt, new ExprLiteral(ExprLiteral.Kind.Integer, ((String)txt.value))); :}
  | FLOATING_POINT_LITERAL.txt {: return register(txt, txt, new ExprLiteral(ExprLiteral.Kind.Real, ((String)txt.value))); :}
  | DOUBLE_LITERAL.txt         {: return register(txt, txt, new ExprLiteral(ExprLiteral.Kind.Real, ((String)txt.value))); :}
  | TRUE_LITERAL.txt           {: return register(txt, txt, new ExprLiteral(ExprLiteral.Kind.True, ((String)txt.value))); :}
  | FALSE_LITERAL.txt          {: return register(txt, txt, new ExprLiteral(ExprLiteral.Kind.False, ((String)txt.value))); :}
  | CHARACTER_LITERAL.txt      {: return register(txt, txt, new ExprLiteral(ExprLiteral.Kind.Char, ((String)txt.value))); :}
  | STRING_LITERAL.txt         {: return register(txt, txt, new ExprLiteral(ExprLiteral.Kind.String, ((String)txt.value))); :}
  | NULL_LITERAL.txt           {: return register(txt, txt, new ExprLiteral(ExprLiteral.Kind.Null, ((String)txt.value))); :}
  ;
primary =
    literal.l                                               {: return _symbol_l; :}
  | LPAREN expression.e RPAREN                              {: return new ParenthesSymbol(_symbol_e); :}
//TODO, type assertion is not supported
  | LPAREN.start expression.e DOUBLECOLON type.t RPAREN.end {: em.warning("Type assertion is not supported. Assertion is ignored at " + Symbol.getLine(start.getStart()) + ", " + Symbol.getColumn(start.getStart()), null); 
                                                               return register(start, end, new ExprLiteral(ExprLiteral.Kind.String, "type assertion"));
                                                            :}
  ;
simple_expression =
    primary.p                                                             {: return _symbol_p; :}
  | variable.v                                                            {: return register(v, v, new ExprVariable(v)); :}
//TODO, old is ignored
  | OLD.old variable.v                                                    {: em.warning("old is not supported for " + v.getName() + ", at " + Symbol.getLine(old.getStart()) + ", " + Symbol.getColumn(old.getStart()), null); 
                                                                             return register(v, v, new ExprVariable(v)); :}
  | IF.s expression.c THEN expression.e1 ELSE expression.e2 END.end       {: return register(s, end, new ExprIf(c, e1, e2)); :}
  | LBRACE.s expression_list_opt.e RBRACE.end                             {: return register(s, end, new ExprSet(e)); :}
  | LBRACE.s expression_list_opt.e COLON for_generator_list.l RBRACE.end  {: return register(s, end, new ExprSet(e, l.build())); :}
  | LBRACK.s expression_list_opt.e RBRACK.end                             {: return register(s, end, new ExprList(e)); :}
//TODO, tail is ignored
//  | LBRACK.s expression_list_opt.e tail.tail RBRACK.end                 {: return register(s, end, new ExprList(e)); :}
  | LBRACK.s expression_list_opt.e COLON for_generator_list.l RBRACK.end  {: return register(s, end, new ExprList(e, l.build())); :}
//TODO, tail is ignored
//  | LBRACK.s expression_list_opt.e COLON for_generator_list.l tail.tail RBRACK.end {: return register(s, end, new ExprList(e, l.build())); :}
  | MAP.s LBRACE map_list.m? RBRACE.end                                              {: return register(s, end, new ExprMap(m==null? null : m.build())); :}
  | MAP.s LBRACE map_list.m? COLON for_generator_list.generators RBRACE.end          {: return register(s, end, new ExprMap(m==null? null : m.build(), generators.build())); :}
  | LET.s decl_list.l COLON expression.e end_let.end                                 {: return register(s, end, new ExprLet(null, l.build(), e)); :}
  | LAMBDA.start lambda_expr_body.lambda                                  {: return register(start, lambda, lambda); :} // update the position to include LAMBDA
//TODO, const is ignored
  | CONST.start LAMBDA lambda_expr_body.lambda                            {: register(start, lambda, lambda); 
                                                                             em.warning("const is ignored in lambda expression", lambda); 
                                                                             return _symbol_lambda; :} // update the position to include LAMBDA
  | PROC.start procedure_expr_body.p                                      {: return register(start, p, p); :}
  ;
indexing_expression =
    simple_expression.e                         {: return _symbol_e; :}
  | indexer.i                                   {: return i; :}
  | indexing_expression.p DOT field.f           {: return register(p, f, new ExprField(p, f)); :}
  | method_invocation.m                         {: return _symbol_m; :}
  ;
indexer = indexer_start.s expression.i RBRACK.e {: return register(s,e, new ExprIndexer(s, i)); :} ;
indexer_start =
    indexing_expression.e LBRACK                {: return _symbol_e; :}
  | indexer_start.s expression.i COMMA.e        {: return register(s, e, new ExprIndexer(s, i)); :}
  ;

unary_expression =
    indexing_expression.e                       {: return _symbol_e; :}
  | operator.operator unary_expression.expr     {: return register(_symbol_operator, expr, new ExprUnaryOp(operator, expr)); :}
  ;
expression =
    unary_expression.e {: return _symbol_e; :}
  // binary expression
  | expression.arg1 operator.operator unary_expression.arg2 {: ImmutableList<String> operators;
                                                               ImmutableList<Expression> operands;
                                                               boolean arg1IsPar = _symbol_arg1 instanceof ParenthesSymbol;
                                                               ExprBinaryOp expr = null;
                                                               if((arg1 instanceof ExprBinaryOp) && !(arg1IsPar)){
                                                                 expr = (ExprBinaryOp)arg1;
                                                                 operators = ImmutableList.<String>builder().addAll(expr.getOperations()).add(operator).build();
                                                                 operands = ImmutableList.<Expression>builder().addAll(expr.getOperands()).add(arg2).build();
                                                               } else {
                                                                 operators = ImmutableList.of(operator);
                                                                 operands = ImmutableList.of(arg1, arg2);
                                                               }
                                                               return register(operands.get(0), arg2, new ExprBinaryOp(expr, operators, operands));  // reuse the Identifier from the previous expr.
                                                            :}
  ;
operator =
    OPERATOR.op {: return op; :}
  | EQ.op       {: return op; :}
  | IN.op       {: return op; :}
  | GT.op       {: return op; :}
  | LT.op       {: return op; :}
  | MULT.op     {: return op; :}
  | BAR.op      {: return op; :}  //TODO, update 2013-05-08 BAR is treated as an operator, ambiguous with list comprehension. It can either a list tail, or binary operation in: (c|d): [a, b, c | d]
  ;
//--- formal parameter
formal_parameter =
    IDENTIFIER.id        {: return register(id, id, new ParDeclValue((String)id.value, null)); :}
  | type.t IDENTIFIER.id {: return register(t, id, new ParDeclValue((String)id.value, t)); :}
  ;
formal_parameter_list =
    formal_parameter.p                               {: return new Symbol(ImmutableList.builder().add(p)); :}
  | formal_parameter_list.l COMMA formal_parameter.p {: l.add(p);  return _symbol_l; :}
  ;
//=== Statement ===============================================================
statement =
    // NOTE lhs must be an expression to avoid a shift reduce conflict with method calls.
    expression.lhs COLONEQ expression.value SEMICOLON.end {: LValue lvalue = expressionToLValue(lhs);
                                                             if (lvalue != null) return register(lhs, end, new StmtAssignment(lvalue, value));
                                                             em.error("Illegal left hand sign of assignment.", lhs);
                                                             return register(lhs, end, new StmtAssignment(new LValueVariable(Variable.variable("$illegal")), value));
                                                           :}
  | method_invocation.m SEMICOLON.end                           {: return register(m, end, new StmtCall(m.getFunction(), m.getArgs())); :}
  | BEGIN.start statement_list_opt.s END.end                    {: return register(start, end, new StmtBlock(null, null, s)); :}
  | BEGIN.start VAR decl_list.d DO statement_list_opt.s END.end {: return register(start, end, new StmtBlock(null, d.build(), s)); :}
  | IF.start expression.e THEN statement_list_opt.s end_if.end  {: return register(start, end, new StmtIf(e, new StmtBlock(null, null, s), null)); :}
  | IF.start expression.e THEN statement_list_opt.s1 ELSE statement_list_opt.s2 end_if.end {: return register(start, end, new StmtIf(e, 
                                                                                                                                     new StmtBlock(null, null, s1),
                                                                                                                                     new StmtBlock(null, null, s2))); :}
  | WHILE.start expression.e decl_block_opt.d DO statement_list_opt.s end_while.end {: return register(start, end, new StmtWhile(e, new StmtBlock(null, d, s))); :}

//TODO choose statements are ignored
  | choose_generator_list.l decl_block_opt.do_v DO.c statement_list_opt.do_s end_choose.end                                                            
    {: Statement stmt = new StmtBlock(null, null, ImmutableList.<Statement>empty());
       Symbol result = register((GeneratorFilter)l.build().get(0), end, stmt);
       em.error("choose statement is not supported", stmt);
       return result; :}
  | choose_generator_list.l decl_block_opt.do_v DO.c statement_list_opt.do_s ELSE statement_list_opt.else_s end_choose.end                             
    {: Statement stmt = new StmtBlock(null, null, ImmutableList.<Statement>empty());
       Symbol result = register((GeneratorFilter)l.build().get(0), end, stmt);
       em.error("choose statement is not supported", stmt);
       return result; :}
  | choose_generator_list.l decl_block_opt.do_v DO.c statement_list_opt.do_s ELSE decl_block_opt.else_v DO statement_list_opt.else_s end_choose.end    
    {: Statement stmt = new StmtBlock(null, null, ImmutableList.<Statement>empty());
       Symbol result = register((GeneratorFilter)l.build().get(0), end, stmt);
       em.error("choose statement is not supported", stmt);
       return result; :}

  | for_generator_list.g DO.doSymbol statement_list_opt.s end_foreach.end              {: return register(doSymbol, end, new StmtForeach(g.build(), new StmtBlock(null, null, s))); :}
  | for_generator_list.g decl_block.d DO.doSymbol statement_list_opt.s end_foreach.end {: return register(doSymbol, end, new StmtForeach(g.build(), new StmtBlock(null, d, s))); :}
  ;

// note, using the normal left recursion will cause an ambiguity between "COMMA expression" and "COMMA generator"
choose_generator_list =
    CHOOSE.start        generator_variable_list.vars IN expression.e
    {: return makeGeneratorFilter(start, null, vars.build(), e, null, null); :}

  | CHOOSE.start type.t generator_variable_list.vars IN expression.e
    {: return makeGeneratorFilter(start, t, vars.build(), e, null, null); :}

  | CHOOSE.start        generator_variable_list.vars IN expression.e COMMA expression_list.filters
    {: return makeGeneratorFilter(start, null, vars.build(), e, filters.build(), null); :}

  | CHOOSE.start type.t generator_variable_list.vars IN expression.e COMMA expression_list.filters
    {: return makeGeneratorFilter(start, t, vars.build(), e, filters.build(), null); :}

  | CHOOSE.start        generator_variable_list.vars IN expression.e COMMA choose_generator_list.l
    {: return makeGeneratorFilter(start, null, vars.build(), e, null, l.build()); :}

  | CHOOSE.start type.t generator_variable_list.vars IN expression.e COMMA choose_generator_list.l
    {: return makeGeneratorFilter(start, t, vars.build(), e, null, l.build()); :}

  | CHOOSE.start        generator_variable_list.vars IN expression.e COMMA expression_list.filters COMMA choose_generator_list.l
    {: return makeGeneratorFilter(start, null, vars.build(), e, filters.build(), l.build()); :}

  | CHOOSE.start type.t generator_variable_list.vars IN expression.e COMMA expression_list.filters COMMA choose_generator_list.l
    {: return makeGeneratorFilter(start, t, vars.build(), e, filters.build(), l.build()); :}
  ;
  
// note, using the normal left recursion will cause an ambiguity between "COMMA expression" and "COMMA generator"
for_generator_list =
    for_foreach.start        generator_variable_list.vars IN expression.e
    {: return makeGeneratorFilter(start, null, vars.build(), e, null, null); :}

  | for_foreach.start type.t generator_variable_list.vars IN expression.e
    {: return makeGeneratorFilter(start, t, vars.build(), e, null, null); :}

  | for_foreach.start        generator_variable_list.vars IN expression.e COMMA expression_list.filters
    {: return makeGeneratorFilter(start, null, vars.build(), e, filters.build(), null); :}

  | for_foreach.start type.t generator_variable_list.vars IN expression.e COMMA expression_list.filters
    {: return makeGeneratorFilter(start, t, vars.build(), e, filters.build(), null); :}

  | for_foreach.start        generator_variable_list.vars IN expression.e COMMA for_generator_list.l
    {: return makeGeneratorFilter(start, null, vars.build(), e, null, l.build()); :}

  | for_foreach.start type.t generator_variable_list.vars IN expression.e COMMA for_generator_list.l
    {: return makeGeneratorFilter(start, t, vars.build(), e, null, l.build()); :}

  | for_foreach.start        generator_variable_list.vars IN expression.e COMMA expression_list.filters COMMA for_generator_list.l
    {: return makeGeneratorFilter(start, null, vars.build(), e, filters.build(), l.build()); :}

  | for_foreach.start type.t generator_variable_list.vars IN expression.e COMMA expression_list.filters COMMA for_generator_list.l 
    {: return makeGeneratorFilter(start, t, vars.build(), e, filters.build(), l.build()); :}
  ;
generator_variable_list =
    IDENTIFIER.id                                 {: return new Symbol(ImmutableList.builder().add(id)); :}
  | generator_variable_list.l COMMA IDENTIFIER.id {: l.add(id); return _symbol_l; :}
  ;
for_foreach =
    FOREACH.FOREACH 
  | FOR.FOR   ;
do_begin =
    BEGIN.BEGIN 
  | DO.DO   ;
end_choose =
    END.END 
  | ENDCHOOSE.ENDCHOOSE   ;
end_foreach =
    END.END 
  | ENDFOREACH.ENDFOREACH   ;
//used by NlParser
end_if = 
    END.END 
  | ENDIF.ENDIF   ;
end_lambda =
    END.END 
  | ENDLAMBDA.ENDLAMBDA   ;
end_let =
    END.END 
  | ENDLET.ENDLET   ;
end_proc =
    END.END 
  | ENDPROC.ENDPROC   ;
end_while =
    END.END 
  | ENDWHILE.ENDWHILE   ;

statement_list_opt =
                       {: return new Symbol(ImmutableList.empty()); :}
  | statement_list.l   {: return new Symbol(l.build()); :}
  ;
statement_list =
    statement.n                  {: return new Symbol(ImmutableList.builder().add(n)); :}
  | statement_list.l statement.n {: l.add(n); return _symbol_l; :}
  ;