%header {: 
/* 
 *  @author Per Andersson<Per.Andersson@cs.lth.se>, Lund University
 *  To parse a NL file use one of the methods:
 *  - public net.opendf.ir.entity.cal.NetworkDefinition parse(String path, String fileName)
 *  - public net.opendf.ir.entity.cal.NetworkDefinition parse(File file)
 *
 *  After parsing check for errors in the attribute parseProblems.
 *
 *  The parser is created using jflex and beaver.
 */
 :} ;
%package "net.opendf.parser.lth";
%import "net.opendf.ir.*";
%import "net.opendf.ir.decl.*";
%import "net.opendf.ir.expr.*";
%import "net.opendf.ir.stmt.lvalue.*";
%import "net.opendf.ir.stmt.*";
%import "net.opendf.ir.util.ImmutableList";
%import "net.opendf.ir.util.ImmutableEntry";
%import "net.opendf.ir.entity.*";
%import "net.opendf.ir.entity.nl.NetworkDefinition";
%import "net.opendf.ir.entity.nl.EntityExpr";
%import "net.opendf.ir.entity.nl.EntityIfExpr";
%import "net.opendf.ir.entity.nl.EntityInstanceExpr";
%import "net.opendf.ir.entity.nl.EntityListExpr";
%import "net.opendf.ir.entity.nl.PortReference";
%import "net.opendf.ir.entity.nl.StructureConnectionStmt";
%import "net.opendf.ir.entity.nl.StructureIfStmt";
%import "net.opendf.ir.entity.nl.StructureForeachStmt";
%import "net.opendf.ir.entity.nl.StructureStatement";
%import "net.opendf.ir.net.ToolAttribute";
%import "net.opendf.ir.net.ToolTypeAttribute";
%import "net.opendf.ir.net.ToolValueAttribute";
%import "net.opendf.errorhandling.BasicErrorModule";
%import "net.opendf.errorhandling.ErrorModule";
%import "java.io.PrintStream";
%import "java.util.Map";
%import "java.util.TreeSet";
%import "java.util.AbstractMap";
%import "net.opendf.ir.IRNode.Identifier";
%import "net.opendf.parser.SourceCodeOracle";
%import "net.opendf.parser.SourceCodeOracle.SourceCodePosition";
%import "net.opendf.ir.IRNode";
%import "java.io.File";

%embed {:
/*******************************************************
 *  Code for error handling in the parser class.
 *******************************************************/
  // all errors encountered during parsing is stored in the array parseProblems. This includes lexical, syntactical and semantic error (multiple initialization actors et.c.)
  BasicErrorModule em;

  private void warning(String msg, Symbol startS, Symbol endS){
    int start = startS.getStart();
    int end = endS.getEnd();
    em.warning(msg + " between " + Symbol.getLine(start) + ":" + Symbol.getColumn(start) + " and " + Symbol.getLine(end) + ":" + Symbol.getColumn(end) + " in " + file.getName(), null);
  }

  public ErrorModule getErrorModule(){ return em; }

  private void warnPortIndex(Expression[] index){
    if(index != null && index.length != 0){
      em.warning("port index is ignored", index[0]);
    }
  }

  // parser plug-in methods that are called when the parser encounters a syntactical problem
  class Events extends Parser.Events {
    public void scannerError(Scanner.Exception e) {
      em.error(e.getMessage(), null);
    }
    public void syntaxError(Symbol token) {
      // This method is always called when a problem is encountered, even if it is repaired.
      // beaver.Parser$Exception is thrown if recovery fails.
      String value = token.value != null ? token.value.toString() : Terminals.NAMES[token.getId()];
      em.error("unexpected token \"" + value + "\" at " + Symbol.getLine(token.getStart()) + ", " + Symbol.getColumn(token.getStart()), null);
    }
    public void unexpectedTokenRemoved(Symbol token) {
      String value = token.value != null ? token.value.toString() : Terminals.NAMES[token.getId()];
      em.warning("parser recovered after removing token \"" + value + "\" at " + Symbol.getLine(token.getStart()) + ", " + Symbol.getColumn(token.getStart()), null);
    }
    public void missingTokenInserted(Symbol token) {
      String value = token.value != null ? token.value.toString() : Terminals.NAMES[token.getId()];
      em.warning("parser recovered after inserting token \"" + value + "\" at " + Symbol.getLine(token.getStart()) + ", " + Symbol.getColumn(token.getStart()), null);
    }
    public void misspelledTokenReplaced(Symbol token) {
      String value = token.value != null ? token.value.toString() : Terminals.NAMES[token.getId()];
      em.warning("parser recovered after replacing token \"" + value + "\" at " + Symbol.getLine(token.getStart()) + ", " + Symbol.getColumn(token.getStart()), null);
    }
    public void errorPhraseRemoved(Symbol token) {
      String value = token.value != null ? token.value.toString() : Terminals.NAMES[token.getId()];
      em.warning("parser recovered after removing token \"" + value + "\" at " + Symbol.getLine(token.getStart()) + ", " + Symbol.getColumn(token.getStart()), null);
    }
  }

  {
    // initialization, before the constructor
    report = new Events(); // Use error handler in parser
  }

/********************************************************
 * Store the source code position of the symbols.
 * The following IR-nodes have source file information:
 * Registered by NLParser.beaver:
 * - EntityIfExpr
 * - EntityInstanceExpr
 * - EntityListExpr
 * - NetworkDefinition
 * - PortReference
 * - StructureConnectionStmt
 * - StructureForeachStmt
 * - StructureIfStmt
 * - ToolValueAttribute
 * - ToolTypeAttribute
 *
 * Registered by CommonParser.beaver
 * - ExprLiteral
 * - Field
 * - Variable
 * - ExprVariable
 * - LocalVarDecl
 * - ExprApplication
 * - ExprLiteral
 * - ExprIf
 *
 * The following IRNodes do not have source code info:
 * - GeneratorFilter
 * - Import
 * - LValue
 ********************************************************/

  private File file;
  private Map<Identifier, SourceCodePosition> srcLocations;
  public Symbol register(Symbol start, Symbol end, IRNode node){
    if(srcLocations != null){
      srcLocations.put(node.getIdentifier(), SourceCodePosition.newIncluding(start, end, file));
    }
    return new Symbol(node);
  }
  public Symbol register(IRNode start, Symbol end, IRNode node){
    if(srcLocations != null){
      srcLocations.put(node.getIdentifier(), SourceCodePosition.newIncluding(srcLocations.get(start.getIdentifier()), end));
    }
    return new Symbol(node);
  }
  public Symbol register(Symbol start, IRNode end, IRNode node){
    if(srcLocations != null){
      srcLocations.put(node.getIdentifier(), SourceCodePosition.newIncluding(start, srcLocations.get(end.getIdentifier())));
    }
    return new Symbol(node);
  }
  public Symbol register(IRNode start, IRNode end, IRNode node){
    if(srcLocations != null){
      srcLocations.put(node.getIdentifier(), SourceCodePosition.newIncluding(srcLocations.get(start.getIdentifier()), srcLocations.get(end.getIdentifier())));
    }
    return new Symbol(node);
  }

/*******************************************************
 *  Help routine that parses a file, given its name.
 *  If a Parser.exception is thrown a CompilationUnit with an empty network is returned.
 *******************************************************/

  public GlobalEntityDecl parse(String fileName, Map<Identifier, SourceCodePosition> srcLocations, SourceCodeOracle scOracle){
    return parse(new File(fileName), srcLocations, scOracle);
  }
  public GlobalEntityDecl parse(String path, String fileName, Map<Identifier, SourceCodePosition> srcLocations, SourceCodeOracle scOracle){
    return parse(new java.io.File(path + File.separatorChar + fileName), srcLocations, scOracle);
  }
  public GlobalEntityDecl parse(File file, Map<Identifier, SourceCodePosition> srcLocations, SourceCodeOracle scOracle){
    this.file = file;
    this.srcLocations = srcLocations;
    em = new BasicErrorModule(scOracle);
    GlobalEntityDecl network;
    java.io.FileReader fr = null;
    try {
      try {
        fr = new java.io.FileReader(file);
        NlScanner scanner = new NlScanner(new java.io.BufferedReader(fr));
        network = (GlobalEntityDecl)parse(scanner);
        fr.close();
      } catch(CalParser.Exception e) {
        // build empty compilation unit for failed error recovery
        // The problem is added to parseProblems[] by the syntaxError() method added to the parser above.
        network = new GlobalEntityDecl(file.getName(), null);
      } finally {
        if(fr != null){ fr.close(); }
      }
    } catch (java.io.FileNotFoundException e){
      em.error("file not found: " + e.getMessage(), null);
      network = new GlobalEntityDecl(file.getName(), null);
    } catch (java.io.IOException e){
      em.error("error reading file: " + e.getMessage(), null);
      network = new GlobalEntityDecl(file.getName(), null);
    }
    return network;
   }

  private enum NetworkBodyPartKind{ IMPORT, VAR_DECL, ENTITIES, STRUCTURE, TOOL_ATTRIBUTE; }

/******************************************************************************
 * Needed by CommonParser.beaver
 * Repeated in both NlParser.beaver and CalParser.beaver
 *****************************************************************************/
  private Symbol makeGeneratorFilter(Symbol start, TypeExpr t, ImmutableList<Symbol>varList, Expression e, ImmutableList<Expression> filterList, ImmutableList l){
    GeneratorFilter gen = makeGeneratorFilter2(t, varList, e, filterList);
    Expression end = e;
    if(filterList != null && !filterList.isEmpty()){
   	 end = filterList.get(filterList.size()-1);
    }
    register(start, end, gen);
    ImmutableList.Builder newList = ImmutableList.builder().add(gen);
    if(l != null){
   	 newList.addAll(l);
    }
    return new Symbol(newList);
  }
  private GeneratorFilter makeGeneratorFilter2(TypeExpr type, ImmutableList<Symbol> varList, Expression e, ImmutableList<Expression> filterList){
    ImmutableList.Builder<LocalVarDecl> vars = ImmutableList.builder();
    for(Symbol var : varList){
      LocalVarDecl decl = new LocalVarDecl(type, (String)var.value);
      register(var, var, decl);
      vars.add(decl);
    }
    return new GeneratorFilter(vars.build(), e, filterList);
  }
  class ParenthesSymbol extends Symbol{ // used by the parser to wrap subexpressions that are enclosed by parentheses, i.e. do not add them to a ExprBinaryOp sequence.
     ParenthesSymbol(Symbol s){
       super(s.getId(), s.getStart(), s.getEnd(), s.value);
     }
  }
   
  private LValue expressionToLValue(Expression expression) {
    if (expression instanceof ExprVariable) {
      Variable var = ((ExprVariable) expression).getVariable();
      return new LValueVariable(var, var);             // use the same Variable as the Variable node
    } else if (expression instanceof ExprIndexer) {
      ExprIndexer exprIndexer = (ExprIndexer) expression;
      LValue structure = expressionToLValue(exprIndexer.getStructure());
      if (structure == null) return null;
      LValue result = new LValueIndexer(structure, exprIndexer.getIndex());
      register(structure, exprIndexer, result);
      return result;
    } else if (expression instanceof ExprField) {
      ExprField exprField = (ExprField) expression;
      LValue structure = expressionToLValue(exprField.getStructure());
      if (structure == null) return null;
      LValue result = new LValueField(structure, exprField.getField());
      register(structure, exprField, result);
      return result;
    } else {
      return null;
    }
  }
:};
// common terminals
%terminals ARROW;
%terminals BAR;
%terminals BEGIN;
%terminals CHARACTER_LITERAL;
%terminals CHOOSE;
%terminals COMMA;
%terminals COLON;
%terminals COLONEQ;
%terminals CONST;
%terminals DO;
%terminals DOT;
%terminals DOUBLECOLON;
%terminals DOUBLE_LITERAL;
%terminals EDGE;
%terminals ELSE;
%terminals END;
%terminals ENDCHOOSE;
%terminals ENDFOREACH;
%terminals ENDIF;
%terminals ENDLAMBDA;
%terminals ENDLET;
%terminals ENDPROC;
%terminals ENDWHILE;
%terminals EQ;
%terminals FALSE_LITERAL;
%terminals FLOATING_POINT_LITERAL;
%terminals FOR;
%terminals FOREACH;
%terminals FUNCTION;
%terminals GT;
%terminals IDENTIFIER;
%terminals IF;
%terminals IN;
%terminals INTEGER_LITERAL;
%terminals LAMBDA;
%terminals LBRACE;
%terminals LBRACK;
%terminals LONG_LITERAL;
%terminals LPAREN;
%terminals LET;
%terminals LT;
%terminals MAP;
%terminals MULT;
%terminals MULTI;
%terminals MUTABLE;
%terminals NULL_LITERAL;
%terminals OLD;
%terminals OPERATOR;
%terminals PROC;
%terminals PROCEDURE;
%terminals RBRACE;
%terminals RBRACK;
%terminals RPAREN;
%terminals SEMICOLON;
%terminals STRING_LITERAL;
%terminals THEN;
%terminals TRUE_LITERAL;
%terminals VAR;
%terminals WHILE;

// Network specific terminals
%terminals ALL;
%terminals ENTITIES;
%terminals ENTITY;
%terminals ENDNETWORK;
%terminals IMPORT;
%terminals NETWORK;
%terminals PORTCONN;
%terminals STRUCTURE;


//--- rules from CommonParser.beaver 
%typeof actor_parameter_list = "ImmutableList.Builder";
%typeof actor_parameter = "ParDeclValue";
%typeof actor_parameter_init_expression = "Expression";
%typeof qual_id = "ArrayList";
%typeof variable = "Variable";
%typeof field = "Field";
%typeof decl_list = "ImmutableList.Builder";
%typeof decl_block = "ImmutableList";
%typeof decl_block_opt = "ImmutableList";
%typeof decl = "LocalVarDecl";
%typeof var_decl = "LocalVarDecl";
%typeof var_name_type = "LocalVarDecl";
%typeof fun_decl = "LocalVarDecl";
%typeof proc_decl = "LocalVarDecl";
%typeof port_decl = "PortDecl";
%typeof port_decl_list = "ImmutableList.Builder";
%typeof port_decl_list_opt = "ImmutableList";
%typeof type_bound = "TypeExpr";
%typeof type_bound_opt = "TypeExpr";
%typeof type_parameter = "ParDeclType";
%typeof type_parameter_block = "ImmutableList";
%typeof type_parameter_list = "ImmutableList.Builder";
%typeof type_list = "ImmutableList.Builder";
%typeof type = "TypeExpr";
%typeof type_attribute = "Map.Entry";
%typeof type_attribute_list = "ArrayList";
%typeof edge_type = "TypeExpr";
%typeof procedure_expr_body = "ExprProc";
%typeof stmt_block_opt = "ImmutableList";
%typeof lambda_expr_body = "ExprLambda";
%typeof map_list = "ImmutableList.Builder";
%typeof map_entry = "Map.Entry";
//%typeof tail = "Expression";
%typeof expression_list = "ImmutableList.Builder";
%typeof expression_list_opt = "ImmutableList";
%typeof method_invocation = "ExprApplication";
%typeof literal = "ExprLiteral";
%typeof primary = "Expression";
%typeof simple_expression = "Expression";
%typeof unary_expression = "Expression";
%typeof indexing_expression = "Expression";
%typeof indexer_start = "Expression";
%typeof expression = "Expression";
%typeof operator = "String";
%typeof formal_parameter = "ParDeclValue";
%typeof formal_parameter_list = "ImmutableList.Builder";
%typeof statement = "Statement";
%typeof choose_generator_list = "ImmutableList.Builder";
%typeof for_generator_list = "ImmutableList.Builder";
%typeof generator_variable_list = "ImmutableList.Builder";  //<Symbol>  (type information is not available, so I can not build the LocalVarDecl object)
%typeof statement_list = "ImmutableList.Builder";
%typeof statement_list_opt = "ImmutableList";

//--- Network specific keywords
%typeof entities = "ArrayList";
%typeof entity = "java.util.Map.Entry";
%typeof entity_expr = "EntityExpr";
%typeof entity_expr_list = "ImmutableList.Builder";
%typeof entity_indexing = "Expression";
%typeof entity_port = "PortReference";
%typeof entity_statement = "StructureStatement";
%typeof import_group = "ArrayList";  //TODO
%typeof import_part = "ArrayList";   //TODO
%typeof import_single = "ArrayList"; //TODO
%typeof network = "net.opendf.ir.net.NetworkBuilder";
%typeof network_body_part = "Map.Entry";
%typeof network_decl = "LocalVarDecl";
%typeof network_decl_block = "ArrayList";
%typeof param_assign = "Map.Entry";
%typeof param_assign_list = "ImmutableList.Builder";
%typeof structure = "ArrayList";
%typeof tool_attribute = "ToolAttribute";
%typeof tool_attribute_block = "ImmutableList";

%goal network;

network =
    NETWORK.startSymbol
    IDENTIFIER.name
    type_parameter_block.typePars?
    LPAREN actor_parameter_list.valuePars? RPAREN 
    port_decl_list_opt.inputPorts
    PORTCONN
    port_decl_list_opt.outputPorts
    COLON
    network_body_part.body*
    end_network.endSymbol
    SEMICOLON?
    {:
        NamespaceDecl ns = null;
        ImmutableList.Builder varDecls = ImmutableList.builder();
        ImmutableList.Builder structure = ImmutableList.builder();
        ImmutableList.Builder<java.util.Map.Entry<String,EntityExpr>> entities = ImmutableList.builder();
        ImmutableList.Builder<ToolAttribute> toolAttributes = ImmutableList.builder();
        for(Map.Entry part : body){
            ImmutableList all;
            if(part.getValue() != null){  // entities and structure may be empty. Then the parser return null.
                switch((NetworkBodyPartKind)part.getKey()){
                case IMPORT:
                     System.out.println("UNSUPPORTED, import is ignored.");
                     //TODO
                     break;
                case VAR_DECL:
                    varDecls.addAll((ArrayList)part.getValue());
                    break;
                case ENTITIES:
                    entities.addAll((ArrayList)part.getValue());
                    break;
                case STRUCTURE:
                    structure.addAll((ArrayList)part.getValue());
                    break;
                case TOOL_ATTRIBUTE:
                    toolAttributes.addAll((ImmutableList)part.getValue());
                    break;
                }
            }
        }
        
        return register(startSymbol, endSymbol, new GlobalEntityDecl((String) name.value,
        		new NetworkDefinition( 
                          typePars,     // typePars,
                          valuePars == null ? null : valuePars.build(), // valuePars,
                          null,      // typeDecls, NOTE, can not be expressed in NL
                          varDecls.build(),             // varDecls
                          inputPorts,
                          outputPorts,
                          entities.build(), // entities
                          structure.build(), // structure
                          toolAttributes.build()
                          )));
    :}
  ;
  
network_body_part =
    import_part.part          {: return new Symbol(new AbstractMap.SimpleEntry(NetworkBodyPartKind.IMPORT, part)); :}
  | network_decl_block.part   {: return new Symbol(new AbstractMap.SimpleEntry(NetworkBodyPartKind.VAR_DECL, part)); :}  // variables, functions and procedures
  | entities.part             {: return new Symbol(new AbstractMap.SimpleEntry(NetworkBodyPartKind.ENTITIES, part)); :}
  | structure.part            {: return new Symbol(new AbstractMap.SimpleEntry(NetworkBodyPartKind.STRUCTURE, part)); :}
  | tool_attribute_block.part {: return new Symbol(new AbstractMap.SimpleEntry(NetworkBodyPartKind.TOOL_ATTRIBUTE, part)); :}
  ;

network_decl_block =
    VAR network_decl.d*       {: return _symbol_d; :}
  ;

network_decl =
    var_decl.d SEMICOLON {: return _symbol_d; :}
  | fun_decl.d           {: return _symbol_d; :}
  | proc_decl.d          {: return _symbol_d; :}
  ;

entities =
    ENTITIES entity.l* {: return _symbol_l; :}
  ;

entity =
    IDENTIFIER.ID EQ entity_expr.e SEMICOLON {: return new Symbol(new java.util.AbstractMap.SimpleEntry((String)ID.value, e)); :}
  ;

entity_expr =
    IDENTIFIER.id LPAREN param_assign_list.l? RPAREN.end tool_attribute_block.a? {: return register(id, end, new EntityInstanceExpr((String)id.value, l == null ? null : l.build(), a));
                                                                             :}
  | IF.start expression.e THEN entity_expr.t ELSE entity_expr.f end_if.end       {: return register(start, end, new EntityIfExpr(e, t, f)); :}
  | LBRACK.start entity_expr_list.e? RBRACK.end                                  {: return register(start, end, new EntityListExpr(e==null ? null : e.build(), null)); :}
  | LBRACK.start entity_expr_list.e COLON for_generator_list.g RBRACK.end        {: return register(start, end, new EntityListExpr(e.build(), g.build())); :}
  ;
param_assign_list =
    param_assign.p                           {: return new Symbol(ImmutableList.builder().add(p)); :}
  | param_assign_list.l COMMA param_assign.p {: l.add(p); return _symbol_l; :}
  ;
entity_expr_list =
    entity_expr.e                            {: return new Symbol(ImmutableList.builder().add(e)); :}
  | entity_expr_list.l COMMA entity_expr.e   {: l.add(e); return _symbol_l; :}
  ;
param_assign =
    IDENTIFIER.ID EQ expression.expression   {: return new Symbol(new java.util.AbstractMap.SimpleEntry((String)ID.value, expression)); :}
  ;

structure =
    STRUCTURE entity_statement.l* {: return _symbol_l; :}
  ;
entity_statement =
    entity_port.src EDGE entity_port.dst tool_attribute_block.a? SEMICOLON.end                {: return register(src, end, new StructureConnectionStmt(src, dst, a==null ? null : a)); :}
  | for_generator_list.g DO.doSymbol entity_statement.s* END.end                              {: ImmutableList<GeneratorFilter> genList = g.build();
                                                                                                 if(genList.isEmpty()){
                                                                                                   return register(doSymbol, end, new StructureForeachStmt(genList, ImmutableList.copyOf(s)));
                                                                                                 } else {
                                                                                                   return register(genList.get(0), end, new StructureForeachStmt(genList, ImmutableList.copyOf(s)));
                                                                                                 }
                                                                                               :}
  | IF.start expression.e THEN entity_statement.t_stmt* END.end                               {: return register(start, end, new StructureIfStmt(e, ImmutableList.copyOf(t_stmt), null)); :}
  | IF.start expression.e THEN entity_statement.t_stmt* ELSE entity_statement.f_stmt* END.end {: return register(start, end, new StructureIfStmt(e, ImmutableList.copyOf(t_stmt), ImmutableList.copyOf(f_stmt))); :}
  ;

entity_port =
//TODO, port index is not supported
    IDENTIFIER.id_port entity_indexing.index_port*                                                        {: warnPortIndex(index_port); return register(id_port, id_port, new PortReference(null, null, (String)id_port.value)); :}
  | IDENTIFIER.id_entity entity_indexing.index_entity* DOT IDENTIFIER.id_port entity_indexing.index_port* {: warnPortIndex(index_port); return register(id_entity, id_port, new PortReference((String)id_entity.value, ImmutableList.copyOf(index_entity) , (String)id_port.value)); :}
  ;
entity_indexing =
    LBRACK.LBRACK expression.e RBRACK.RBRACK {: return _symbol_e; :}
  ;

//TODO imports are not represented in the IR
import_part =
    import_single.i {: return _symbol_i; :}
  | import_group.i  {: return _symbol_i; :}
  ;
import_single =
    IMPORT import_kind.k qual_id.qual_id SEMICOLON                     {: return new Symbol(qual_id); :}
  | IMPORT import_kind.k qual_id.qual_id EQ IDENTIFIER.alias SEMICOLON {: return new Symbol(qual_id); :}
  ;
import_group =
    IMPORT import_kind.k ALL qual_id.qual_id SEMICOLON                 {: return new Symbol(qual_id); :}
  ;
import_kind =
                {: return new Symbol(""); :}
  | ENTITY.kind {: return kind; :}
  | VAR.kind    {: return kind; :}
  ;
tool_attribute_block =
    LBRACE tool_attribute.a* RBRACE {: return new Symbol(ImmutableList.builder().addAll(a).build()); :}
  ;
tool_attribute =
    IDENTIFIER.ID EQ expression.expression SEMICOLON.end {: return register(ID, end, new ToolValueAttribute((String)ID.value, expression)); :}
  | IDENTIFIER.ID COLON type.type SEMICOLON.end          {: return register(ID, end, new ToolTypeAttribute((String)ID.value, type)); :}
  ;
end_network =
    END 
  | ENDNETWORK   ;
